CSS:
	Abbreviations:
		CSS: 					Cascading Style Sheets.

		BEM:					Block-Element-Modifier.
	
	Description:
		
	
	Resources:
		
	
	Concepts:
		CSS Reset:				Removes all CSS that a Browser automatically adds - make design consistent amongst different Browsers, which may have their own implicit styling for some Elements.

		Inline CSS: 			CSS defined with the style attribute of the HTML Element. Performance friendly.

		CSS-in-JS: 				The idea of writing CSS within JS Files, instead of with separate CSS External Files.
			Note: Not the same as Inline CSS. Inline CSS only offers a subset of CSS Functionality.

			Pros:
				JS Interactivity: Allows for JS to better interact and control the Styling of UI Elements in the many suitable scenarios.
				Colocation of CSS with Components: There is now just one File to define a UI Element, rather than two.

			Cons:
				Single Responsibility: Each File now handles both Styling and Functionality.
				Separation of Concerns: To modify the Styling, you would have to edit the File that also controls Functionality.

		Internal CSS: 			CSS defined with the <style> </style> tags. Performance friendly.

		External CSS: 			CSS defined in an External File, referenced by the current file through the <link> tag. Less Performance friendly.
			CSS Architecture:
				BEM:					Naming Convention for CSS Classes.
					Block:				Class for a reusable 'Component'.
						/* Block */
						.block {}

					Modifier:			Class to modify the Block thematically.
						/* Modifier */
						.block--modifier {}

					Element:			Class for child HTML Elements (that are not Blocks themselves).
						/* Element */
						.block__element {}

				Atomic CSS: 			The idea of splitting up a CSS Rule-Set into multiple CSS Rule-Sets that each contain only a single CSS Rule specification.
					Pros:
						Lean CSS: 		CSS Code Duplication is reduced.
						Predictable Changes: Following the Single Responsibility Principle, it's easy to understand what Adding / Removing a CSS Rule Set would do.

		CSS Modules: 			Technique for enforcing Scope on traditionally Global CSS Content.

		Autoprefixing:			Technique used to transform CSS Syntax to Browser-Specific variants.
	
	Details:
		CSS Specificity:
			The Higher a CSS Rule-Set's Specificity, the Greater its Priority.
				Increasing from Top to Bottom:
					Type Selectors and Pseudo Elements.
					Class Selectors.
					ID Selectors.

					Inline CSS.

					!important.

				/* Note: When Multiple Applicable Selectors have the same specificity, the one defined last (NOT applied last) will be the one applied.*/

		Syntax and Markup Layout:
			/* General Form */
				<css-selector> { 
					<rule>: <value>; 
				}

			/* id */
				#id {}
			
			/* class */
				.class {}
			
			/* media conditional - apply css only if conditional is satisfied */
				@media all and (conditional) {
					// css here
				}

			/* Selector Forms */
				/* To select for HTML Elements, but only under a certain condition. */
				selector1:pseudo-class ... {}

				/* To introduce new HTML Elements not specified in the Document Markup. */
				selector1::pseudo-element ... {}
				
				/* To select for HTML Elements are either selector1 OR selector2. */
				selector1,selector2 ... {}

				/* To select for HTML Elements that satisfy both selector1 AND selector2. */
				selector1selector2 ... {}

				/* To select an immediate selector2 HTML Element that follows after a sibling selector1 HTML Element. */
				selector1+selector2 ... {}

				/* To select any selector2 HTML Element that follows after a sibling selector1 HTML Element. */
				selector1~selector2 ... {}

				/* To select only direct selector2 HTML Elements contained within a selector1 HTML Element. */
				selector1>selector2 ... {}

				/* To select all selector2 HTML Elements contained within a selector1 HTML Element. */
				selector1 selector2 ... {}

		Unit Specification:
			x vw, y vh - Relatively scale Element by x% of the viewport width and y% of the viewport height.
			
			em - Relative to font-size of the current Element (2em === 200% of current Font-Size).
			rem - Relative to font-size of the HTML Root Element (2em === 200% of current Font-Size).

		Spacing Properties: 
			Specification Order: Top Right Bottom Left.

			Box Model:
				Margin: Outer Separation from other neighbouring Elements.
				
				/* Border-Box */
				Border: A Border around the Element.
				Padding: Inner Separation between the Content and the Border of the Element.

				/* Content-Box */
				Content: Element Children.

		CSS Rules and Values:
			Hiding an Element:
				display: none 		- The HTML DOM Node is created. It is not placed into the Document Flow, and other neighbouring Elements will take its place.
				visibility: hidden 	- The HTML DOM Node is created. It is placed into the Document Flow, but an (empty) space is allocated in its place visually. It cannot receive Events.
				opacity: 0			- The HTML DOM Node is created. It is placed into the Document Flow, and is invisible. It can still receive Events.

			Arrangement:
				position: Specify how the Element is to interpret its Positional Specifications.
					static: 
						Default.
						Adheres to Document Flow.
						Ignores Top, Bottom, Left, Right, and z-index settings.

					relative:
						Adheres to Document Flow.
						Interprets Top, Bottom, Left, and Right settings with respect to position derived from Document Flow.
						Creates a new Stacking Context (for descendants) when a z-index specification is set.

					absolute:
						Removed from Document Flow.
							Ignores Parent Padding.
							Parent Element cannot account for Element Size.

						Interprets Top, Bottom, Left, and Right settings with respect to position derived from closest Ancestor Element with non-static positioning, or <body> </body> if there is none.
						Creates a new Stacking Context (for descendants) when a z-index specification is set.

					fixed:
						Removed from Document Flow.
						Interprets Top, Bottom, Left, and Right settings with respect to the Browser Viewport.
						Creates a new Stacking Context (for descendants) when a z-index specification is set.

					sticky:
						Whilst the position derived from Document Flow is in Browser Viewport: follows the 'relative' positioning.
						Whilst the position derived from Document Flow is outside Browser Viewport: follows the 'fixed' positioning.
						Interprets Top, Bottom, Left, and Right settings when 'fixed' positioning is active.
						Creates a new Stacking Context (for descendants) when a z-index specification is set.
			
				display: Specify if the Element is block or inline, and the layout of Child Elements.
					Element Display:
						block:
							Normally takes up the whole Width of the Parent Container.
							Force a Line Break after the block Element regardless of Width; Elements are laid out vertically one after the other.
							Default Element: <div> </div>

						inline:
							Respect Left & Right Margins and Padding, but not Top & Bottom.
							Cannot have a Width and Height set - fully accommodates Children.
							Allow other Elements to sit to their Left and Right if their total Width can fit into the Parent Container ; Elements are laid out horizontally one after the other.
							Default Element: <span> </span>
						
						inline-block:
							Respect Top & Bottom Margins and Padding.
							Respect Width and Height.
							Allow other Elements to sit to their Left and Right if their total Width can fit into the Parent Container ; Elements are laid out horizontally one after the other.

					Children Element Layout:
						flex / inline-flex: 
							One Dimensional Layout Model which allows the assigned Container to determine Children proportions for the best utilization of available space.
							The Main Axis is the direction in which Children are placed along, whilst the Cross Axis is perpendicular to it.
								The size of Children corresponding to the Main Axis will be overriden by flex behaviour.
									By default, flex-items have min-width / min-height set to auto rather than 0, which is the default for other display modes. Set it to 0 to override this behaviour.

								The size of Children corresponding to the Cross Axis will be honored by the Parent.

							Children Margins (and directional variants) will automatically expand to consume available space if set to auto.

							Children with z-index specifications will always create a new Stacking Context, even when not positioned.

							/* Container-Defined Rules */
								/* Determine Main Axis (and implicitly, Cross Axis). */
								flex-direction: <'row' | 'column' | 'row-reverse' | 'column-reverse'>

								/* Determine Children Layout Behaviour / Proportion along the Main Axis. */
								justify-content: <'flex-start' | 'flex-end' | 'center' | 'space-between' | 'space-evenly'>

								/* Determine Children Behaviour / Proportion along the Cross Axis. */
								align-items: <'flex-start' | 'flex-end' | 'center' | 'stretch' | 'baseline'>

								/* Determine Children Wrapping Behaviour along the Main Axis. */
								/* Main Axis will wrap to another 'line' if set to wrap, potentially causing Overflow along the Cross Axis if there's not enough space. */
								flex-wrap: <'nowrap' | 'wrap' | 'wrap-reverse'>

								/* Determine how space between multiple 'lines' of the Main Axis is distributed along the Cross Axis. */
								align-content: <'flex-start' | 'flex-end' | 'center' | 'space-between' | 'space-evenly'>

							/* Children-Defined Rules */
								/* Determine Child's order of appearance w.r.t Main Axis. */
								order: <number>;

								/* Determine ideal size of Child before taking into account flex behaviour. */
								/* Note: There is an existing bug on all major browsers that causes a nested flex Parent to not account for Children flex-basis specifications, causing unneccessary wrapping or overflow along its Main Axis. Specify Children width / height instead to correct it, which functions similarly to flex-basis in the context of a flex Parent. */
								flex-basis: <size>;

								/* Determine capability for Child to grow to consume free space <number>-times proportionally w.r.t other Siblings along the Main Axis. */
								flex-grow: <number>;

								/* Determine capability for Child to shrink to fit into space <number>-times proportionally w.r.t other Siblings along the Main Axis. */
								flex-shrink: <number>;

			Alternative to Element Borders:
				box-shadow: inset <x-offset> <y-offset> <blur> <color>;

	Commands:
		
	
