(DOM) Testing Library
	Abbreviations:
	
	Description: Allows for Testing of UI Components in a User-centric Way.
	
	Resources:
	
	Concepts:
		data-testid: 			Convention: Custom Element Property that allows for quick test-only lookups via queryById. Can be stripped away during Compilation via babel-plugin-react-remove-properties.
	
	Details:
		Function: UI Component Framework Representation -> DOM Nodes -> Test on DOM Nodes

		Packages:
			@testing-library/dom: Lightweight Solution for testing Web Pages by providing Utilities for querying and interacting with DOM Nodes.
				// Tip: During Test Setup, we can change what the Testing Library treats as a data-testid attribute:
					import { configure } from '@testing-library/dom'
					configure({ testIdAttribute: '<id>' })

					// Tip: data-testid can be changed to id for better compatibility with vanilla DOM Selector Mechanisms.

				// Tip: Useful DOM Node Methods and Patterns: 
					// To get the data-testid specified on a DOM Node, use <dom-node>.getAttribute('data-testid')

					// To get the closest Ancestrial DOM Node that fulfills a criteria, use <dom-node>.closest('<dom-selector>')

					// To get the closest Descendent DOM Nodes that fulfills a criteria, use <dom-node>.querySelectorAll(':scope > <dom-selector>')

				// screen: Interface for obtaining Nodes from the DOM State. Re-exported by the Wrapper Packages.
					// Query Types:
						// query* - Functions will return the DOM Node or null if it can't be found.
							// Tip: Use these only when asserting an DOM Node's existence.

						// get* - Functions will return the DOM Node or throw an Error (with the full DOM Structure in readable format) if it can't be found.

						// find* - Asynchronous Functions that will resolve with the DOM Node or reject if the default timeout of 10000ms is exceeded.
							// Note: Useful to avoid the 'act' Error Output by waiting for a Component to finish loading when it calls an API on Mount.
							// Note: Calls cannot be run concurrently via Promise.all.
								// Tip: Just await each Call - it will immediately resolve if it can be found.

					// Query Methods
						// *ByText - Search for Text Nodes with a particular <value>.
							*byText(
								<render-results> | <dom-node>,
								<value>,
								{
									selector = "<dom-selector>", // Defaults to *
									exact = false, // Defaults to true
									// ...
								}
							)

			@testing-library/jest-dom: Provides custom Jest Matchers for testing DOM State.
				// expect( <dom-node> ).toBeInTheDocument(): Jest Matcher for checking if DOM Nodes are in the DOM State.
				// expect( <dom-node> ).toBeDisabled(): Jest Matcher to check if an DOM Node is correctly disabled.

				// expect( <dom-node> ).toHaveTextContent( '<text-content>' ): Jest Matcher to check if the DOM Node has the specified <text-content> anywhere within.

			@testing-library/user-event: Provides Utility Methods to simulate User Events.
				import userEvent from '@testing-library/user-event';

				userEvent.click(<dom-node>)

				userEvent.type(<dom-node>, <input>)
					// Special <input> (can be combined with regular input in the same line)
						// {enter}
						// {selectall}

			@testing-library/react: Renders React Components into DOM Nodes.
				// render: Render a React Component onto the DOM State.
				// Tip: 'renderResults' have the same Methods as 'screen', except there is no need to specify the DOM Node to start the search from.
				// Tip: Already wrapped with 'act'.
				// Note: If calling 'render' multiple times within the same Test, be sure to invoke 'cleanup' or 'unmount' before each subsequent 'render' Call to remove the rendered results from the DOM State.
					const renderResults = render(<element />, {
						// Specify a DOM Node to append the <element /> to.
						// Defaults to document.body.
						container: <dom-node>, // document.body.appendChild(document.createElement('<html-element-type>'))
					})

					// Preview DOM Tree Structure
						// Entire DOM:
						screen.debug(undefined, Infinity)

						// Specific DOM:
						renderResults.debug(undefined, Infinity)

					// ...

					renderResults.unmount()
					cleanup()

				// fireEvent: Use when doing programmatic interaction with the Component; otherwise go for @testing-library/user-event over this - the methods more closely resemble typical User Interactions.
					// Tip: Already wrapped with 'act'.
					fireEvent.<event-type>(<dom-element>, ... )

				// waitFor: Wait until some Assertion becomes true / Asynchronous Condition resolves.
					// Note: For Synchronous Conditions, waitFor will re-call the Callback on a set Interval (default: 50ms).
					await waitFor(() => { <assert-fn>( ... ).toBe( ... ) })

					// Note: For Asynchronous Conditions, waitFor will re-call the Callback only once it rejects.
					await waitFor(async () => { <assert-fn>( await ... ).toBe( ... ) })
					await waitFor(async () => <boolean-expression>)

				// waitForElementToBeRemoved: Will resolve once the specified DOM Node has been removed - it will check each time there is a mutation to the DOM State.
					// Note: Will throw an Error if the DOM Node does not already exist on the first check.
					await waitForElementToBeRemoved(async () => <dom-node>)

				// act: Wrapper Function to wrap any Code that would trigger a State Update.
					act(() => { ... })
					await act(async () => { ... })

			@testing-library/react-hooks: Creates a simple Test Harness for React Hooks, avoiding the need to create unnecessary Function Components in tests.
				// The package will auto-detect which Renderer is available to use for the Test Harness.
				// If a Renderer is required, use more specific Import Paths:
					'@testing-library/react-hooks/dom'
					'@testing-library/react-hooks/native'
					'@testing-library/react-hooks/server'

				// Note: console.error gets mocked when importing from this library. This can affect Tests that rely on asserting an output from console.error.

				// renderHook: Render a Test Component that will call <custom-hook> each time it renders.
					const { result, waitForValueToChange, waitForNextUpdate,  waitFor } = renderHook(() => <custom-hook>( ... ))
						// Tip: Avoid destructuring the 'result' Object to prevent Closure-related Issues.

						// result.current: The current Return Value from <custom-hook>.
						// result.error: Any thrown Errors from the <custom-hook>.
						// result.all: An Array of the Return Values from <custom-hook> thus far, per Render. Each Element is either an instance of result.current or result.error.

					// Tip: Render a Hook within some Context.
					const wrapper = ({ children }) => <Context ... > { children } </Context>
					const { result, waitFor, waitForValueToChange, waitForNextUpdate } = renderHook(() => <custom-hook>( ... ), { wrapper })

					// Wait for result to update.
					await waitForValueToChange(async () => result.<{ current | error | all }>)

					// Wait for Hook to trigger all re-Renders associated with prior State Updates.
					// Note: If using this, can omit any act() calls before it.
					await waitForNextUpdate()

					// Note: Don't use the waitFor from @testing-library/react!
					// waitFor: Wait until some Assertion becomes true / Asynchronous Condition resolves.
						// Note: For Synchronous Conditions, waitFor will re-call the Callback on a set Interval (default: 50ms).
						await waitFor(() => { <assert-fn>( ... ).toBe( ... ) })

						// Note: For Asynchronous Conditions, waitFor will re-call the Callback only once it rejects.
						await waitFor(async () => { <assert-fn>( await ... ).toBe( ... ) })
						await waitFor(async () => <boolean-expression>)

				// act: Wrapper Function to wrap any Code that would trigger a State Update.
					act(() => { ... })
					await act(async () => { ... })

				// cleanup: Unmounts all Rendered Hooks, ensuring all Effects have been flushed.
					// Tip: Automatically called if Testing Framework supports the afterEach global.

	Commands:
		
	
