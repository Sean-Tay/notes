Typescript:
	Abbreviations:
		OOP: 					Object-Oriented Programming.
	
	Description: An extension to Javascript.
	
	Resources:
		
	
	Concepts:
		
	
	Details:
		Note: The use of Types below may reference either Type Aliases or Interfaces.

		Features:
			Static Typing: 		Allows for optional explicit declaration of Variable Types. Compiler will ensure Variables are not assigned Values of the wrong Type.
				// Compare this with Dynamic Typing, which can only perform Type-Checks during runtime.

				const <variable>: <variable-type> = <value>;

				// Primitive Types:
					// any: For when the intended Type is unknown.
						let <any-type-variable>: any = <value>;

					// void: For when there should be no Type.
						let <void-type-variable>: void; 

					// never: For when the value should never occur.
						let <never-type-variable>: never;

						(): never => {
							// Functions with unreachable end-points should have a 'never' return value.
							throw new Error();
						}

				// Arrays
					let <array-variable>: <type>[] = <value-array>;
					// OR
					let <array-variable>: Array<<type>> = <value-array>; // Include one set of Angled Brackets.

					const <nested-array-variable>: <type>[][] = [[]];

				// Tuples: For Arrays that hold different Types.
					let <tuple-variable>: [<type>, ...] = [<value>, ...];

				// Functions
					const <function> = ( arg:<arg-type>, ... ): <return-type> => {
						// ...
					};

					// Function with Object Destructuring
					const <function> = ( { <key-1> , ... }: { <key-1>: <value-type-1> , ... }) => {
						// ... 
					};

					// Function with Generics
					const <function> = <<Generic-Type>, > ( arg:<Generic-Type>, ... ): <return-type> => {
						// ...
					};

					// Asynchronous Function
					const <async-function> = async (): Promise<<return-type>> => { // Include one set of Angled Brackets.
						// ...
					};

					// Reference Function Return Type
						type <function-return-type> = ReturnType<<function>>; // Include one set of Angled Brackets.

				// Utility Types:
					// Partial: To allow partial fulfillment of a Type.
						// Useful for Prop instantiation?
						let <partial-type-variable>: Partial<<type>> = {}; // Include one set of Angled Brackets.

					// Pick: To specify a subset of Type Properties from another Type through a 'whitelist' approach.
						let <pick-type-variable>: Pick<<type>, '<property>' | ... > = {};

					// Omit: To specify a subset of Type Properties from another Type through a 'blacklist' approach.
						let <omit-type-variable>: Omit<<type>, '<property>' | ... > = {};

					// Extract: To select for a subset of Type Properties from a Type that matches a certain specified Type.
						let <extract-type-variable>: Extract<<type>, <specified-type>> = {};

				// Intersection Types: Combines multiple Types into one.
					// Union of Member Attributes.
					let <union-type-variable>: <type> & ... = <value>;

				// Union Types: Designate one of the following Types.
					// Intersection of Member Attributes.
					let <intersection-type-variable>: <type> | ... = <value>;

				// Type Assertion
					<value> as <type>
					// OR
					<<type>><value> // Include one set of Angled Brackets.

			Enums: To provide more friendly names to sets of Numeric Values.
				enum <enum-name> { <key>: <numeric-value>, ... };
				let <example-variable>: <enum-name> = <enum-name>.<key>; 

			Type Alias:			Declare custom Types that can be reused in other Types or Interfaces.
				type <type-alias> = <type> | ... ;

				// ...

				const <variable>: <type-alias> = <value>;

			Interfaces:			Allows for explicit structure declaration of Values.
				interface <interface-name> {
					<property>: <type>;
					<optional-property>?: <type>;
					readonly <readonly-property>: <type>;

					<function-property>: ( arg:<arg-type>, ... ) => <return-type>;

					// ...
				};

				// Reference a Type of a Property from an Interface
				// Note: Different from Pick - Pick creates another Interface - the resultant Type will still refer to an Object.
				type <type-name> = <interface-name>['<property>']

				// Extending an existing Interface
				interface <extended-interface-name> extends <existing-interfce-name> {
					<additional-property>: <type>;

					// ...
				};

				// Generic Interface
				interface <generic-interface-name><<Generic-Type>> {
					// ...
				}

				// Indexable Interface
				interface <indexable-interface-name> {
					[string]: <type>;
					//OR
					[number]: <type>;
				}

				// Mapped Indexable Types over Enums
				// Note: For declaring possible Interface Keys via Enums.
				type <type-name> = {
					[key in <enum>]: <any>;
				}

				// keyof: To specify for a Type that contains all accessible Interface Properties.
				// string | number | symbol
				type <type-name> = keyof <interface>;

			Modules
			Namespaces
			OOP Support

		Typescript code will eventually be compiled down to Javascript code. This additional step serves as another point whereby problematic code can be caught.

		Typescript Definitions:
			If the original Javascript Library does not already have Typescript definitions, it may be possible to install the definitions via:
				npm: 			npm install --save-dev '@types/<library>'
				yarn: 			yarn add '@types/<library>'

				The Typescript definitions are at: https://github.com/DefinitelyTyped/DefinitelyTyped

		Typescript Compiler / Transpiler Configuration:
			// Typescript will read in specified configuration parameters in a tsconfig.json File by default.

			// tsconfig.json
			{
				"extends": "<base-tsconfig-json-path>", // Specify parent tsconfig.json File to inherit Settings from.
				"include": [			// Specify Directories and Files to compile. Dependencies in Files are automatically recursively traversed. Overrides any inherited include Settings.					
					"./src/index.js",
					// "./src/**/*",
				],
				"exclude": [			// Specify Directories or Files to not compile. Overrides any inherited exclude Settings.
					"./node_modules",
					"**/*.spec.ts"
				],
				"compilerOptions": {
					"types": ['<package>', ... ], // Specify that TypeScript should only Type Check the following Library Packages (which have the corresponding @types/'<package>' Scoped Package installed). Note: This Option is independent of the 'exclude' Option specified above.
					
					"noImplicitAny": true, // Raise Error on Expressions with an implicit 'any' Type.
					"strict": true,		// Enables some Syntax Rules.

					"allowJs": true,	// Allow JS Files to be processed with Type Checking.
					"jsx": true | "react", // Support JSX usage, usually from React.

					"moduleResolution": { "Classic" | "Node" }, // Specify the in-built Method for resolving a Module's Dependencies.
						// "Node" Module Resolution will set Typescript to search in the node_modules Folder too.

					"esModuleInterop": true, // Allow and Support import / export between CommonJS Modules and ES Modules.
					"isolatedModules": true, // Disallow Features that requires Cross-File Analysis. Useful when Babel is to be used for compilation and transpilation instead.
					"lib": ["DOM", "ES6", ...], // Specify which Language Features will be available in the Target Runtime Environment. Injects in-built API TypeScript Declarations to avoid Compilation Errors.
					"module": "CommonJS", // Specify the Module Resolution System of the Target Runtime Environment.
					"target": "ES5", 	// Specify which Version of the Language should the Source be compiled down to, for the Target Runtime Environment.

					"noEmit": true, 	// Do not emit any Artifacts once checking is done. Useful with the @babel/preset-typescript Package.
					"outDir": "<output-path>", // Specify Directory that will house the compiled Artifacts.
				}
			}

		External Libraries:
			React:
				// The Type for the children argument passed in via Component Props should be specified as React.ReactNode.
				// children?: React.ReactNode

				// Forwarding Refs
				const component = React.forwardRef<<html-element-tag-type>, <component-prop-type>>(
					(props, ref) => { 
						// ... 
					}
				);

				// Useful Types:
					React.FC<<component-props>>: To specify the Type for a Functional Component. Keep only one set of Angled Brackets.
						// Note: Do not explicitly specify if forwarding Refs; let Typescript infer this.

					React.ComponentPropsWithoutRef<'<html-element-tag-type>'>: For default attributes available to Components / native HTML DOM Elements. The Quotes are required.

					React.CSSProperties: To specify the inline-CSS Styles Object within JSX.

					React.RefObject<<html-element-tag-type>>: To specify the type for a Ref Object. Keep only one set of Angled Brackets.

					React.ReactText: To specify for a string | number Value.
					React.ReactElement: To specify for the JS Object implicitly produced through the compilation of JSX.
						// Note: JSX.Element is a more generic version of React.ReactElement.

					React.ReactChild: To specify the Type for valid children of React Elements. Does not allow for falsy values.
					React.ReactNode: A superset of React.ReactChild, with the same purpose as React.ReactChild. Allows for falsy values.
					
					React.FormEvent<<html-form-element-tag-name>>: To specify for the JS Event Object of a Form Element. Keep only one set of Angled Brackets.
					React.FormEventHandler<<html-form-element-tag-name>>: To specify for a JS Event Handler Function for a Form Element. Keep only one set of Angled Brackets.

	Commands:
		tsc *.ts[x]				Compiles Typescript code in relevant .ts or .tsx files to Javascript code in .js or .jsx files.
			--watch 			Auto-Compile when Typescript code changes are detected.
	
