Typescript:
	Abbreviations:
		OOP: 					Object-Oriented Programming.
	
	Description: An extension to Javascript.
	
	Resources:
		
	
	Concepts:
		
	
	Details:
		Note: The use of Types below may reference either Type Aliases or Interfaces.

		Features:
			Static Typing: 		Allows for optional explicit declaration of Variable Types. Compiler will ensure Variables are not assigned Values of the wrong Type.
				// Compare this with Dynamic Typing, which can only perform Type-Checks during runtime.

				const <variable>: <variable-type> = <value>;

				// Primitive Types:
					// any: For when the intended Type is unknown.

					// unknown: A type-safe counterpart to the any Type.

					// object: Represents all non-primitive Types.
					// Object: Describes functionality common to all Javascript Objects.

					// never: For when the value should never occur.
						let <never-type-variable>: never;

						(): never => {
							// Functions with unreachable end-points should have a 'never' return value.
							throw new Error();
						}

						// Can also be used to exclude undesirable Types from Type Unions:
						type NonType<T, NT> = T extends NT ? never : T;

					// void: For when there should be no Type.

				// Arrays
					let <array-variable>: <type>[] = <value-array>;
					// OR
					let <array-variable>: Array<<type>> = <value-array>; // Include one set of Angled Brackets.

					const <nested-array-variable>: <type>[][] = [[]];

				// Tuples: For Arrays that hold different Types.
					let <tuple-variable>: [<type>, ...] = [<value>, ...];

					const <tuple-variable> =  [<value>, ...] as const;

				// Functions
					const <function> = ( arg:<arg-type>, ... ): <return-type> => {
						// ...
					};

					// Function with Object Destructuring
					const <function> = ( { <key-1> , ... }: { <key-1>: <value-type-1> , ... }) => {
						// ... 
					};

					// Function with Generics
					const <function> = <<generic-type> extends <base-type>, ... > ( arg:<generic-type>, ... ): <generic-type> => {
						// ...
					};

					// Asynchronous Function
					const <async-function> = async (): Promise<<return-type>> => { // Include one set of Angled Brackets.
						// ...
					};

					// Reference Function Return Type
						type <function-return-type> = ReturnType<typeof <function>>; // Include one set of Angled Brackets.

						type <async-function-return-type> = awaited ReturnType<typeof <function>> // Include one set of Angled Brackets.

				// Classes
					// Classes with Generics
					// Note: Static Members cannot use Generics, as Generics only apply to the Instances of a Class.
					class <class-name><generic-type> {
						// ...
					}

				// Intersection Types: Combines multiple Types into one.
					// Union of Member Attributes.
					let <union-type-variable>: <type> & ... = <value>;

				// Union Types: Designate one of the following Types.
					// Intersection of Member Attributes.
					let <intersection-type-variable>: <type> | ... = <value>;

					// Discriminatory Unions:
					// Allows TypeScript to automatically infer individual Types from a Union Type when appropriate.
						enum E {
							ONE = 'one',
							TWO = 'two'
						}

						interface I1 {
							<common-literal-field>: E.ONE,

							<I1-prop>: <type>,
							// ...
						}

						interface I2 {
							<common-literal-field>: E.TWO,

							<I2-prop>: <type>,
							// ...
						}

						type TDU = I1 | I2;

						const example: TDU = {
							<common-literal-field>: E.ONE,

							// Typescript will automatically infer further I1 Props based on value set for the <common-literal-field>.
						};

				// Utility Types:
					// Extract: To select for a subset of Types from a Union Type.
						let <extract-type-variable>: Extract<<type>, <specified-type>> = ... ;

					// Exclude: To remove a subset of Types from a Union Type.
						let <exclude-type-variable>: Exclude<<type>, <specified-type>> = ... ;

				// Type Guards: A Function that returns a boolean Value, letting TypeScript remove some possible Types during analysis of a Variable's Type when it is used.
					function isType(arg: <type>): arg is <stricter-type> {
						// ...

						return <boolean>;
					}
					// Type Guard Type: (arg: <type>) => arg is <stricter-type>

					function isNotType<T extends unknown>(arg: T): arg is Exclude<T, <type>> {
						// ...
						
						return <boolean>;
					}

					const variable: unknown = <value>;
					const strictVariable: <stricter-type> = isType(variable);

				// Type Assertion
					<value> as <type>
					// OR
					<<type>><value> // Include one set of Angled Brackets.

			Enums: To provide more friendly names to sets of Numeric Values.
				enum <enum-name> { <key>: <numeric-value>, ... };
				let <example-variable>: <enum-name> = <enum-name>.<key>; 

			Type Alias:			Declare custom Types that can be reused in other Types or Interfaces.
				type <type-alias> = <type> | ... ;

				// ...

				const <variable>: <type-alias> = <value>;

			Interfaces:			Allows for explicit structure declaration of Values.
				/** <interface-documentation */
				interface <interface-name> {
					<property>: <type>;
					<optional-property>?: <type>;
					readonly <readonly-property>: <type>;

					<function-property>: ( arg:<arg-type>, ... ) => <return-type>;

					/** <text> */
					<documented-property>: <type>;

					// ...
				};

				// Reference a Type of a Property from an Interface
				// Note: Different from Pick - Pick creates another Interface - the resultant Type will still refer to an Object.
					type <type-name> = <interface-name>['<property>']

				// Extending an existing Interface
					interface <extended-interface-name> extends <existing-interfce-name> {
						<additional-property>: <type>;

						// ...
					};

				// Generic Interface
					interface <generic-interface-name><<generic-type>> {
						// ...
					}

				// Indexable Interface
					interface <indexable-interface-name> {
						[key: string]: <type>;
						//OR
						[key: number]: <type>;

						// ...
					}

				// Mapped Indexable Types
				// Note: For declaring possible Interface Keys.
				// Tip: Use the Record Utility Type here.
					type <type-name> = 'key-a' | 'key-b' | // ... | 'key-n' ;
					type <indexable-type-name> = {
						[key in <type-name>]: <type>;

						// ...
					}

				// Mapped Indexable Types over Enums
				// Note: For declaring possible Interface Keys via Enums.
					type <indexable-type-name> = {
						[key in <enum>]: <type>;

						// ...
					}

				// keyof: To specify for a Type that contains all accessible Interface Properties.
				// string | number | symbol
					type <type-name> = keyof <interface>;

				// Utility Types:
					// Partial: To allow partial fulfillment of a Type (set all Properties to allow for undefined values).
						// Useful for Prop instantiation?
						let <partial-type-variable>: Partial<<type>> = {}; // Include one set of Angled Brackets.

					// Required: To demand full fulfillment of a Type (set all Properties to not allow for undefined values).
						let <required-type-variable>: Required<<type>> = {}; // Include one set of Angled Brackets.

					// Pick: To specify a subset of Type Properties from another Type through a 'whitelist' approach.
						let <pick-type-variable>: Pick<<type>, '<property>' | ... > = {};

					// Omit: To specify a subset of Type Properties from another Type through a 'blacklist' approach.
						let <omit-type-variable>: Omit<<type>, '<property>' | ... > = {};

					// Record: To create a Type whose possible keys are defined in another Type, and map them to a value Type.
						type <keys-type> = 'key-a' | 'key-b' | ... | 'key-n';
						let <record-type-variable>: Record<<keys-type>, <value-type>> = {};

						// Dictionary Map Types, where one set of Keys can be mapped to another set of Keys, may also be defined with Record:
						type <keys-type-a> = 'key-a' | ... ;
						type <keys-type-b> = 'key-b' | ... ;

						type <map> = Record<<keys-type-a> , <keys-type-b>>; // Include one set of Angled Brackets.

					// NonNullable: To remove null and undefined from a Type.
						let <non-null-non-undefined-type-variable>: NonNullable<<type>> = {}; // Include one set of Angled Brackets.

			Modules
			Namespaces
			OOP Support

		Typescript code will eventually be compiled down to Javascript code. This additional step serves as another point whereby problematic code can be caught.

		Typescript Definitions:
			If the original Javascript Library does not already have Typescript definitions, it may be possible to install the definitions via:
				npm: 			npm install --save-dev '@types/<library>'
				yarn: 			yarn add '@types/<library>'

				The Typescript definitions are at: https://github.com/DefinitelyTyped/DefinitelyTyped

		Typescript Compiler / Transpiler Configuration:
			// Typescript will read in specified configuration parameters in a tsconfig.json File by default.

			// tsconfig.json
			{
				"extends": "<base-tsconfig-json-path>", // Specify parent tsconfig.json File to inherit Settings from.
				"include": [			// Specify Directories and Files to process. 
					"src",

					// Dependencies in Files are automatically recursively traversed. Overrides any inherited include Settings.
						// "./src/index.js",
				],
				"exclude": [			// Specify Directories or Files to not compile. Overrides any inherited exclude Settings.
					"./node_modules",
					"**/*.spec.ts"
				],
				"compilerOptions": {
					"types": ['<package>', ... ], // Specify which Type Definitions are 'visible' in the Global Scope, in addition to which are 'visible' in the Local Scope. Note: This Option is independent of the 'exclude' Option specified above.
					
					"noImplicitAny": true, // Raise Error on Expressions with an implicit 'any' Type.
					"strict": true,		// Enables some Syntax Rules.

					"allowJs": true,	// Allow JS Files to be processed with Type Checking.
					"jsx": true | "react", // Support JSX usage, usually from React.

					"moduleResolution": { "Classic" | "Node" }, // Specify the in-built Method for resolving a Module's Dependencies.
						// "Node" Module Resolution will set Typescript to search in the node_modules Folder too.

					// Specify Aliases that can be used to shorten import or require declarations in Files.
					"baseUrl": ".",
					"paths": {
						"<path-alias>/*": ["<path-relative-to-baseUrl>/*"]
					},

					"esModuleInterop": true, // Allow and Support import / export between CommonJS Modules and ES Modules.
					"isolatedModules": true, // Disallow Features that requires Cross-File Analysis. Useful when Babel is to be used for compilation and transpilation instead.
					"lib": ["DOM", "ES6", ...], // Specify which Language Features will be available in the Target Runtime Environment. Injects in-built API TypeScript Declarations to avoid Compilation Errors.
					"module": "CommonJS", // Specify the Module Resolution System of the Target Runtime Environment.
					"target": "ES5", 	// Specify which Version of the Language should the Source be compiled down to, for the Target Runtime Environment.

					"downlevelIteration": true,	// Explicitly allows iterating through Iterables with for-of Loops.

					"noEmit": true, 	// Do not emit any Artifacts once checking is done. Useful with the @babel/preset-typescript Package.
					"outDir": "<output-path>", // Specify Directory that will house the compiled Artifacts.
				}
			}

		External Libraries:
			React:
				// The Type for the children argument passed in via Component Props should be specified as React.ReactNode.
				// children?: React.ReactNode

				// Forwarding Refs
				const component = React.forwardRef<<html-element-tag-type>, <component-prop-type>>(
					(props, ref) => { 
						// ... 
					}
				);

				// Useful Types:
					React.ComponentPropsWithoutRef<'<html-element-tag-type>'>: For default attributes available to Components / native HTML DOM Elements. The Quotes are required.

					React.FC<<component-props>>: To specify the Type for a Functional Component. Keep only one set of Angled Brackets.
						// Alias for React.FunctionComponent.
						// Note: Do not explicitly specify if forwarding Refs; let Typescript infer this.

					React.Component<<component-props>>: Represents a Component Instance.
					React.ComponentType<<component-props>>: To specify the Type for either a Functional or Class Component.
						// React.FunctionComponent<P> | React.ComponentClass<P>
						// Specify 'any' for the type of <component-props> for the least restrictions.

					React.CSSProperties: To specify the inline-CSS Styles Object within JSX.

					React.DependencyList: To specify the Type for the Dependency Array of a Hook.

					React.RefObject<<html-element-tag-type>>: To specify the type for a Ref Object. Used in scenarios where React is to 'maintain control' of the Ref Object. Keep only one set of Angled Brackets.
					React.MutableRefObject<<value> | null>: To specify the type for a mutable Ref Object. Used in scenarios where the User is the one 'maintaining control' of the Ref Object. Keep only one set of Angled Brackets.

					React.ReactText: To specify for a string | number Value.
					React.ReactElement: To specify for the JS Object implicitly produced through the compilation of JSX.
						// Note: JSX.Element is a more generic version of React.ReactElement.

					React.ReactChild: To specify the Type for valid children of React Elements. Does not allow for falsy values.
					React.ReactNode: A superset of React.ReactChild, with the same purpose as React.ReactChild. Allows for falsy values.
					
					React.SynthenticEvent<<html-element-tag-name>>: Base React-Augmented Event Object. Keep only one set of Angled Brackets.

					React.MouseEvent: To specify for the React-Augmented Click Event Object.
					
					React.ChangeEvent<<html-input-element-tag-name>>: To specify for the React-Augmented onChange Event Object of an Input Element. Keep only one set of angled brackets.
					React.ChangeEventHandler<<html-form-element-tag-name>>: To specify for a JS onChange Event Handler Function for a Form Element. Keep only one set of Angled Brackets.
					React.FormEvent<<html-form-element-tag-name>>: To specify for the React-Augmented Event Object of a Form Element. Keep only one set of Angled Brackets.
					React.FormEventHandler<<html-form-element-tag-name>>: To specify for a JS Event Handler Function for a Form Element. Keep only one set of Angled Brackets.

	Commands:
		tsc *.ts[x]				Compiles Typescript code in relevant .ts or .tsx files to Javascript code in .js or .jsx files.
			--watch 			Auto-Compile when Typescript code changes are detected.
	
