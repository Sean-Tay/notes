Typescript:
	Abbreviations:
		OOP: 					Object-Oriented Programming.
	
	Description: An extension to Javascript.
	
	Tutorials:
		
	
	Concepts:
		
	
	Details:
		Note: The use of Types below may reference either Typescript Types or Typescript Interfaces.

		Features:
			Static Typing: 		Allows for optional explicit declaration of Variable Types. Compiler will ensure Variables are not assigned Values of the wrong Type.
				// Compare this with Dynamic Typing, which can only perform Type-Checks during runtime.

				const <variable>: <variable-type> = <value>;

				const <function> = ( arg:<arg-type>, ... ): <return-type> => {
					// ...
				}

				// Function with Object Destructuring
				const <function> = ( { <key-1> , ... }: { <key-1>: <value-type-1> , ... }) => {
					// ... 
				}

				// Function with Generics
				const <function> = <<Generic-Type>> ( arg:<Generic-Type>, ... ): <return-type> => {
					// ...
				}

				// Arrays
					let <array-variable>: <type>[] = <value-array>;
					// OR
					let <array-variable>: Array<<type>> = <value-array>; // Include one set of Angled Brackets.

					const <nested-array-variable>: <type>[][] = [[]];

				// Tuples: For Arrays that hold different Types.
					let <tuple-variable>: [<type>, ...] = [<value>, ...];

				// enums: To provide more friendly names to sets of Numeric Values.
					enum <enum-name> { <key>: <numeric-value>, ... }
					let <example-variable>: <enum-name> = <enum-name>.<key>; 
				
				// any: For when the intended Type is unknown.
					let <any-type-variable>: any = <value>;

				// void: For when there should be no Type.
					let <void-type-variable>: void; 

				// never: For when the value should never occur.
					let <never-type-variable>: never;

					(): never => {
						// Functions with unreachable end-points should have a 'never' return value.
						throw new Error();
					}

				// Partial: To allow partial fulfillment of a Type.
					// Useful for Prop instantiation?
					let <partial-type-variable>: Partial<<type>> = {}; // Include one set of Angled Brackets.

				// Pick: To specify a subset of Type Properties from another Type through a 'whitelist' approach.
					let <pick-type-variable>: Pick<<type>, '<property>' | ... > = {};

				// Omit: To specify a subset of Type Properties from another Type through a 'blacklist' approach.
					let <omit-type-variable>: Omit<<type>, '<property>' | ... > = {};

				// Intersection Types: Combines multiple Types into one.
					// Union of Member Attributes.
					let <union-type-variable>: <type> & ... = <value>;

				// Union Types: Designate one of the following Types.
					// Intersection of Member Attributes.
					let <intersection-type-variable>: <type> | ... = <value>;

				// Type Assertion
					<value> as <type>
					// OR
					<<type>><value> // Include one set of Angled Brackets.

			Interfaces:			Allows for explicit structure declaration of Values.
				interface <interface-name> {
					<property>: <type>, 
					<optional-property>?: <type>, 
					readonly <readonly-property>: <type>,
					// ...
				}

				Strictness can change in different scenarios:
					1. At least the required Types are accounted for in the Value.
					2. Only the required Types are accounted for in the Value.

			Modules
			Namespaces
			OOP Support

		Typescript code will eventually be compiled down to Javascript code. This additional step serves as another point whereby problematic code can be caught.

		Typescript Definitions:
			If the original Javascript Library does not already have Typescript definitions, it may be possible to install the definitions via:
				npm: 			npm install --save '@types/<library>'
				yarn: 			yarn add '@types/<library>'

				The Typescript definitions are at: https://github.com/DefinitelyTyped/DefinitelyTyped
	
	Commands:
		tsc *.ts[x]				Compiles Typescript code in relevant .ts or .tsx files to Javascript code in .js or .jsx files.
			--watch 			Auto-Compile when Typescript code changes are detected.
	
