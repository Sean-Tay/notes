Jest
	Abbreviations:

	
	Description: Unit Testing Framework that has native support for React.
	
	Resources:
		https://www.toptal.com/react/tdd-react-unit-testing-enzyme-jest
	
	Concepts:
		Target: 				The thing being tested.
		
		Assertion: 				An expression which contains some testing logic for the Target Code.
		Unit Test:				An atomic Procedure to check if the Target Code behaves in a specific, pre-determined way, via Assertions.

		Test Group:				A collection of Unit Tests that are related in some meaningful way.
		Test Suite:				A File that contains all Unit Tests for Target Code, written in a separate File.
		
		Matcher: 				A Class of Jest Functions that each provide different Assertion logic.
	
	Details:
		Packages:
			jest				
			babel-jest			Allows usage of Babel with Jest.

		Configuration:
			// package.json Configuration - specify a 'jest' Key to store the Configuration Object.
			// Alternatively, specify a jest.config.js to store Configuration Object. Just export the Configuration Object (i.e. no need to key it to 'jest').
			"jest": {
				"verbose": true,

				"bail": <number>, // Specifies to Jest the number of Failed Tests to tolerate, exceeding which to terminate the Test Run.

				// ...
			}

			// Specifying a Test Command in package.json
			scripts: {
				test: "jest",
				// ...
			}

		Setup:
			Webpack:
				// TODO

		Flow:
			Test Suite Locations:
				1. In the same Location as the Target Code's File.
					// For Jest to pick up the Test Suite, the File Name needs to follow the <name>.test.jsx? convention.
					// Usually <name> is the same as the name of the Target Code's File, for clarity.

				2. Inside a __tests__ Folder.

			Test Suite Anatomy:
				// Jest automatically injects some commonly-used globals, so there is no need to manually import.

				// Groups related Unit Tests together within a Test Suite, or within a parent 'describe' Group.
				// Note: Jest evaluates all 'describe' Handlers before any 'test' Handlers in a Test Suite.
				describe(
					'<test-group-description>',
					() => {
						// ...

						// Unit Test Definition:
						// Note: 'it' is an alias of 'test'.
						test(
							'<test-description>',
							() => {
								// ...

								// Execute Synchronous Test:
								expect(<function>()).<matcher>(<value>);
							}
						);

						// Asynchronous Unit Test Definition:
						test(
							'<async-test-description>',
							async () => {
								// Indicate to Jest to only pass this Unit Test once the correct number of Assertions have been executed.
								expect.assertions(<number>); 

								const data = await <async-function>();

								// expect ...
							}

							// OR

							() => {
								// Indicate to Jest to only pass this Unit Test once the correct number of Assertions have executed.
								// In this case this can also help detect when the Assertions in .then() or .catch() does not execute, depending on if the Unit Test checks for a success or failing state.
								expect.assertions(<number>); 

								return <async-function>()
									.then(
										data => {
											// expect ...
										}
									);

									// OR

									.catch(
										err => {
											// expect ...
										}
									)
							}
						);

						// ...
					}
				);

				// Reruns all Unit Tests in a Test Group with different specified Data each time.
				// Note: There's also a test.each variant which works in the same way.
				describe.each(
					[
						[<value-1a>, ...], // Each sub-Array corresponds to one single run of this Test Group.
						// ...
					]
				)(	
					// Jest can inject special values into the name of the Test Group to help differentiate between different Runs.
					'<test-group-description>-%o',
					(<value-1a>, ...) => {
						// expect ...
					}
				);

			Lifecycle Methods:	For executing some Logic during different phases of Test Suite / Group execution.
				// Note: <init-fn> and <cleanup-fn> can return a Promise for Asynchronous Setup / Teardown operations.
				beforeAll(<init-fn>);
				beforeEach(<init-fn>);
				afterEach(<cleanup-fn>);
				afterAll(<cleanup-fn>);

			Matchers:
				not				Inverts the Unit Test Logic.

				toBe(<value>) 	For basic comparison of primitives or Object References (Shallow Check).

				toBeNull()
				toBeDefined()
				toBeUndefined()
				toBeFalsy()
				toBeTruthy()

				// Numbers
				toBeCloseTo(<number>, <precision>) For optimal comparison of floats that accounts for floating-point Errors.
				toBeLessThan(<number>)
				toBeLessThanOrEqual(<number>)
				toBeGreaterThanOrEqual(<number>)
				toBeGreaterThan(<number>)
				toBeNaN()

				// Strings
				toMatch({<string> | <reg-exp>})	Check if a given string value matches for a given <string> or <reg-exp>.

				// Arrays
				toContain(<item>) Check if an Item exists within an Array.
				toContainEqual(<item>) Deep Check if an Item with specific Structure and Values exists within an Array.
				
				// Objects
				toMatchObject(<object>) Partial Deep Check if the Object to be tested has at least the Structure and Values in <object>.
				toEqual(<object>) Deep Check if two Objects have the same specific Structure and Values.
				toStrictEqual(<object>) Deep Check if two Objects have the same specific Structure, Property Types, and Values.
					// Note: Keys with undefined Values will not match with an Object without those Keys.

				// Errors
				toThrow(<error>)

	Commands:
		jest	// Triggers Jest Tests.
		jest --watchAll // Triggers Jest Tests whenever there is a change in Code.
	
