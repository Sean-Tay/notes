React.js
	Abbreviations:
		MVC: 						Model-View-Controller.
		SPA:						Single-Page Application.
		PWA:						Progressive Web Application.
		
		HTML: 						HyperText Markup Language.
		CSS:						Cascading Style Sheets.
		DOM:						Document Object Model.
		
		JS: 						Javascript.
		JSX: 						Javascript Syntax Extension.
	
	Description: A Lightweight Frontend Library for building User Interfaces for Applications. It is part of the View Layer in the MVC Architecture.
	
	Tutorials:
		Quick Start: https://youtu.be/sBws8MSXN7A
	
	Concepts:
		React Element:				Lightweight, Immutable, Stateless, Functionless, Nestable, plain JS Object that describes what should be shown on screen - a Virtual DOM Node or Sub-Tree. It is implicitly produced when inline JSX is compiled down to React.createElement() calls during Rendering.
		Virtual DOM: 				A Lightweight Abstraction of the Actual DOM (i.e. no CSS considerations, etc), represented by a Tree of React Elements.

		React Component:			Refers to the syntactical definition that would create a React Component Instance.
		React Component Instance:	An instance of a React Component. Returns a React Element adjusted for State and Functions when the appropriate render() method is called.

		State:						Information maintained by a React Component Instance which it itself can change.
		Props: 						Information received by a React Component Instance from other React Components Instance which it should NOT change directly - use Event Handlers.

		[Re-]Render: 				A term to describe the process of [re-]creating the React Element.

		Uncontrolled Component:		A React Component Instance that maintains its own internal State. Usually only used w.r.t React Form Elements.
		Controlled Component:		A React Component Instance that does not maintain internal State. Usually only used w.r.t React Form Elements.
	
	Details:
		React.js Library handles Element creation and manipulation.
		ReactDOM.js Library handles DOM interaction.

		React faciliates the construction of SPAs:
			The default entry point, public/index.html, contains a top-level <div> 'root', which will contain the entirety of the React Application as part of the SPA functionality.
			The default Javascript entry point, src/index.js, should reference a top-level React Component 'App' and render it in the top-level <div> 'root'.
				import React from 'react';
				import {render} from 'react-dom';
				
				import './index.css';
				import 'App' from './App.js';
				
				render(<App />, document.getElementById('root'));
		
		React makes use of self-contained Components with their own Component-Level State.
			These States will determine how the Component will appear and behave.
			Only upon a State change would the Component be re-rendered (not Props change).

			After batching multiple Component re-renders:
				1. React takes a snapshot of the Virtual DOM before the update.
				2. React then attempts to re-render the entire Virtual DOM (though each Component may choose not to do so and return the old Element). This makes it easier to comprehend - we need only to return the Virtual DOM that we want to see in each Component, and not keep track of all changes happening to the Virtual DOM.
				3. Diff-ing the captured snapshot of the Virtual DOM with the updated Virtual DOM allows React to detect which Actual DOM Objects should be updated.
				4. React proceeds to only update the Actual DOM Objects identified in the earlier step. This is a form of optimization, and is much faster than updating the entire Actual DOM Tree.
		
		React Patterns:
			Parent Stateful -> Child Stateless : Pass Parent State / State Changer as Child Props. Child Component can declare custom function wrapper for received State Change Function to make it suitable as a Event Handler.
			Child Stateless -> Child Stateless = Child Stateless -> Parent Stateful -> Child Stateless : Separation of Concerns.
				Business Logic (Container Components) and Display Logic (Presentational Components).

			Use Props to set State only when it is clear the data involved is just initialization data. Components will automatically re-render if the Props change.

		React Components:
			Class-Component:
				import React from 'react';
				import PropTypes from 'prop-types';
				
				import './ExampleClass.css';
				import 'OtherComponent' from './OtherComponent.js';

				import ReactDOM from 'react-dom';

				// Note: Class Names to begin with a Capital Letter to help React distinguish between HTML Elements and React / JSX Element.
				class ExampleComponent extends React.Component {
					// Mounting: Phase in Component Lifecycle which depicts creation of a corresponding React Element and its initial Render.
						constructor(props) {
							super(props);

							// Initialize Local State Object directly.
							this.state = { //... };

							// Binding Event Handler Methods to a Component Instance. Can be omitted if using (ev) => {this.handleStateChange(ev)} 
							this.handleStateChange = this.handleStateChange.bind(this);
						}

						// Set State without need for declaring Constructor.
						state = {
							// ...
						};

						componentWillMount() {
							// Called before the render Function is invoked - a chance to update state in preparation for the first render.
							// ...

							this.setState((state, props) => { // ... });
						}

						// Compulsory
						render() {
							// Examines this.props and this.state, and returns a React Element.
							// Child Render methods are also executed.
							// This should be a Pure Function - do not call this.setState() or mutate any global states here.
							/*
								React Elements are produced via JSX.
									Evaluation of any JS is only done via JS Injection within curly braces.
										You cannot inject JS if-statements directly within JSX. Utilize either:
											1. Ternary Operator - it always evaluates to a JS Expression (returns a value) unlike an if-else statement.
											2. Immediately-Invoked JS Function - (() => {})()
									Utilize the && operator for code that either will or will not appear. 
									JSX can still be used within the braces.
									Multi-line JSX should be enclosed with parentheses.
								
								React Elements can have attributes, similar to DOM / HTML.
									Note: Replace the 'class' DOM attribute to 'className' for compiling from JSX -> JS, since 'class' is a reserved keyword in JS.
									Note: style DOM attribute to be specified as a JS Object, and with the names of usual CSS style properties in camelCase as opposed to dash-delimited words.
									Note: Child Elements produced from mapping an Iterable need to have the top-level Child Element specify a distinguishing 'key' element.

								React Elements can have Event Listeners, similar to DOM / HTML, but with the names in camelCase as opposed to lowercase.
									let exampleElement = <img onHover={ exampleJSFunction } />; // The Event Listeners act on JS functions.

								React Elements can also utilize CSS Style Declarations, similar to HTML, but with the names in camelCase as opposed to lowercase hyphenation.
									let exampleElement = <h1 style={{background: 'lightblue', color: 'darkred', fontSize: '20px'}}> Test </h1>;

								React Elements can be nested, just like in DOM / HTML.
									All React Elements must have only exactly one outermost element. The first opening tag and the final closing tag must belong to the same React element.

									Can use a <div> </div> or React Fragment (<> </>) to enclose the group.
							*/

							let subReactElement = (
								<div> 
									// ...
								</div>
							);

							return <boolean> && ( 
								<div className={<html-class-reference>} style={ { <cssAttribute>: '', ... } }>
									<p> { this.props.<prop-name> } </p>
									
									<p>
										{
											(
												() => {
													switch (this.state.<state-object-key>) {
														case "red":   return "#FF0000";
														case "green": return "#00FF00";
														case "blue":  return "#0000FF";
														default:      return "#FFFFFF";
													}
												}
											)()
										}
									</p>
									
									<OtherComponent <child-prop-name>={ // ... } <child-onStateChange>={ this.handleStateChange } />

									// OR

									<OtherComponent <child-prop-name>={ // ... } <child-onStateChange>=(ev) => {this.handleStateChange(ev)} />

									// OR

									<OtherComponent { ...this.state } /> // Object Spread Notation
								</div>
							)
						}

						componentDidMount() {
							// Additional Function that is called only after a Component has been mounted, and only once.
							// Child Components also execute their componentDidMount Functions as well.

							// setInterval ...
							// AJAX Call for Data ...
						}

						// Pass Custom Function to Child Component to alert Component when Child Component receives an Event to change State.
						handleStateChange(callback) {
							// Don't modify this.state directly, otherwise React won't know to re-render the Component.
							// Use setState() instead to merge in changes to the State, which will also implicitly re-render the Component.
							// Don't reference this.state directly as the update triggered by this.setState is asynchronous - use the update function argument form, as shown below.
							this.setState(
								(state, props) => {
									return {
										// New Object that represents the intended changes to the State Object.
										// DO NOT mutate the State Object directly.
									};
								},
								callback
							);
							
							// Return (or execute) Parent stateChange method.
							return this.props.<parent-stateChange>;
						}
						
						// Specifying a Function in this manner removes the need to bind 'this'.
						handleStateChange = (callback) => {
							// ...
						}

					// Updating: Phase in which a Component updates due to changes in Props or State. Only occurs after the initial Render / Mounting Phase.
						componentWillReceiveProps(nextProps) {
							// Called only when Component will receive Props, regardless if old or new.
						}
						
						shouldComponentUpdate(nextProps, nextState) {
							// Default Behaviour is to re-render on any State change.
							// return true if Component should update
							// return false otherwise
						}
						
						componentWillUpdate(nextProps, nextState) {
							// Cannot call this.setState() here.
							// Meant for interactions outside of the React architecture.
						}

						// Called if this.props or this.state is changed.
						render() 

						getSnapshotBeforeUpdate(prevProps, prevState) {
							// Called before the new React Element is commited to the Virtual DOM.
							// Enables the Component to capture information from the Actual DOM before it is potentially changed.
						}

						componentDidUpdate(prevProps, prevState, snapshot) {
							// Called immediately after any updating occurs.
							// Meant for interactions outside of the React architecture.
						}

					// Unmounting: Phase in which a Component Instance is no longer actively inside the generated React Element that it is usually under, or if ReactDOM.unmountComponentAtNode( ... ) is used.
						componentWillUnmount() {
							// Called immediately before a Component is unmounted and destroyed.

							// clearInterval ...
						}
				}
				
				// Explicit Declaration of expected types for Props helps to avoid errors.
				ExampleComponent.propTypes = {
					<prop-name>: PropTypes.<prop-type>[.isRequired],
					<onStateChange>: PropTypes.func[.isRequired], // parent.handleStateChange
					...
				};

				// Default Props Declaration - If no Props are passed into the Function.
				ExampleComponent.defaultProps = {
					<prop-name>: <default-value>,
					<onStateChange>: () => {},
					...
				}
				
				export default ExampleComponent;
				
				// ...

			Functional Component:
				// Useful as Presentational Components
				const ExampleComponent = (props) => { // Recall that all Properties defined via JSX gets put into a singular 'props' Object by React.
					// Extract / Consume the Props that are used.
					// other will contain all other unused Props via destructuring, which can then be separately passed down to Child Components.
					let {<used-prop>, // ... , ...other} = props;

					// other can also be referenced normally as a regular Object variable.
					// console.log(other);

					// ...
					
					return (
						{ // Ensure unknown, unconsumed Props are specified first - later Props will override if applicable }
						<ChildComponent {...other} usedProp={<used-prop>} ... /> 
					);
				}

				// React Hooks can be used to 'hook' onto Class Component Functionality:
				const ExampleComponent = (props) => {
					// Each Hook has the prefix 'use' in its name.
					// React counts on the Hook Definition Order - only define Hook Definitions at the Top-Level of the Function, outside of any Conditionals, Loops or other Functions.

					// Local Component State
						// Each State Variable defined in the manner below is independent from one another.
						// Note: Old State Values for each Variable will always be completely replaced when using the accompanying Setter Function. Keep in mind when updating Data Structures.
						// Note: The State Value does NOT get updated if it was directly derived from a Prop. Set it again via useEffect.
						const [ <state-var>, <state-var-setter-function> ] = React.useState(<initial-value>);

						// Modify the State.
						<state-var-setter-function>(<new-value>);
						// Modify the State based on the previous State.
						<state-var-setter-function>(
							(<prev-value>) => {
								// ...
								return <new-value>;
							}
						);

					// Local Component State - No Re-Render
						// Changes made to these Variables here will not cause a Re-Render.
						const <ref-var> = React.useRef(<initial-value>);
						// Access / Modify the Ref.
						<ref-var>.current = <new-value>;

					// Advanced Local Component State Management
						// The key difference between useState and useReducer is that for useReducer the State can be altered in a controlled manner as opposed to simply using the <state-var-setter-function>.
						// It is also more suited for managing State Objects that have multiple sub-values.
						const [ <state-var>, <dispatch-function> ] = React.useReducer( 
							(state, action) => {
								// Reducer Function - A Function that combines two or more Arguments and returns the combination.
								// Practically, it should be a Pure Function that:
									// Does not mutate Arguments.
									// Does not generate Side-Effects (API Calls, etc).
									// Execute Impure Functions within.

								// Based on action's Properties, a new State based on the passed in state should be returned.
									// Switch on action.type
									// action.payload
								return {
									...state,
									// ...
								};
							}, 
							<initial-state>
						);

					// Side-Effects
						// Similar Behaviour to componentDidMount, componentDidUpdate and componentWillUnmount combined - the submitted Function executes after each Render (when Props or State is updated).
						React.useEffect(
							() => {
								// ... 

								// Return an optional cleanup Function that is executed just before each subsequent Render.
								return () => {
									// ...
								};
							}, 
							// An optional 'Dependency List' of Variables can be specified as well to limit when the submitted Function executes.
							// By submitting this List of Variables, React will then additionally only execute the submitted Function if any of the Variables in the List are changed (=== type and value check) after the first Render.
							// If the submitted Function may directly or indirectly reference any Component's State (it's own or from Ancestor Components' passed in as Props), the references should be placed in the Dependency List.
							// Hint: Passing an Empty List here would make the submitted Function behave like componentDidMount.
							// Hint: For Arrays and Objects, use JSON.stringify.
							// Hint: For Functions, specify as it is (do NOT use JSON.stringify).
							[ <variable>, ... ]
						);

					// Optimizations
						// Used to prevent unneccessary recalculation of some value per re-Render.
						// Hint: That 'some value' can be a React Element too.
						React.useMemo(
							() => {
								// ...

								return expensive(<variable>, ...);

								// OR 

								return <ExampleComponent arg={<variable>} />;
							},
							// Optional 'Dependency List' of Variables, same as with useEffect().
							[ <variable>,  ... ]

							// OR

							// Optional Comparator Function
							(prev, next) => {
								// return true if the value should not be recalculated
								// return false otherwise
							}
						);
						
						// Used to define Functions within Functional Components that won't be unneccessarily recreated per re-Render.
						React.useCallback(
							(<arg-1>, ...) => {
								// ...

								return;
							}, 
							// Optional 'Dependency List' of Variables, same as with useEffect().
							[ <variable>, ... ]
						);

					// DOM Node Reference
					const nodeRef = React.useRef();
					// ... <div ref={{nodeRef}}> </div> ...
					// ... nodeRef.current ...

					// Tips
					/*
						The flow should be:
						1. Define initial States via the useState Hook if necessary, either from Props or use placeholder default Values.
						2. Query backend API with useEffect / custom Hook, and with a Dependency List containing Props that pertain to the HTTP Request and REST Query Parameters.
						3. Render the actual Component only when a certain flag passed from the backend API changes. Use a placeholder 'Loading' Component if the flag is not of a certain state.
					*/

					return (
						<>
							{ /* ... */ }
						</>
					);
				}

				// Default Props Declaration - Static Property Declaration.
				ExampleComponent.defaultProps = {
					<prop-name>: <default-value>,
					<onStateChange>: () => {},
				}

				export ExampleComponent;
				
				// To simulate shouldComponentNotUpdate w.r.t Props when using React Hooks
				export const MemoExampleComponent = React.memo(
					ExampleComponent, 
					// If the Function below is not provided, ExampleComponent will only re-Render once its Props changes.
					(prevProps, nextProps) => {
						// return true if Component should not update
						// return false otherwise
					}
				);

				// Testing
				const mockData = {
					<prop>: <value>,
					// ...
				};

				const MockExampleComponent = () => (
					<>
						<ExampleComponent {...mockData} />
					</>
				);

				export default MockExampleComponent;

			Higher-Order Component: 
				// A Pattern involving a Function which takes in a Component and returns a new Component.
				// Useful for adding on commonly used functionality to many Components.
				// WrappedComponent needs to be configured to take in more Props.

				function withSubscription(WrappedComponent, ...) {
					// Return a new Class Component to keep the Function pure.
					return class extends React.Component {
						constructor(props) {
							super(props);
							this.handleChange = this.handleChange.bind(this);
							this.state = {
								// Functionality-Specific Local State
								data: //... ,
							};
						}

						// ... Additional Functionality Here ...

						render() {
							// Renders WrappedComponent with the appropriate minimal props.
							return <WrappedComponent {...this.props} data={this.state.data} />;
						}
					};
				}

			Render:
				let ExampleComponentElement = React.createElement(ExampleComponent, propsObject, ... children);
				ReactDOM.render(ExampleComponentElement, document.getElementById('...')); // Actually mount to DOM.

				// OR

				ReactDOM.render(<ExampleComponent />, document.getElementById('...'));

				// OR 

				ReactDOM.render(<ExampleComponent> // ... </ExampleComponent>, document.getElementById('...'));
				// Within ExampleComponent, the special props.children can be used to reference all nested React Elements that is a child of this ExampleComponent.
				// React.Children API Methods.
		
		React Form: Modified HTML Form that uses React State as a single-source of truth.
			Typical HTML Form Elements maintain their own State (Uncontrolled). However, the React version of these Elements use the Component State instead (Controlled).
				This enforces that every State mutation will have an associated handler function, making it straightforward to modify or validate User Input.
				Allows for finer-grained synchronization between User Input and Component State.

			When these HTML Input Elements have a 'value' attribute specified in the React Element specification, they switch from using their internal State to the React Component State instead:
				<input value={this.state.value} onChange={this.onChangeHandlerFunction} />

		React Context API / Redux: Application-Level State Managers to maintain and share State across multiple Components.
			Central Store for all Components. Avoids complex “prop” graphs in Component Trees.
	
	Commands:
		Create-React-App: CLI Tool for Creating Boilerplate React Apps.
			Features:
				Dev Server with Hot Reload
			
			npx create-react-app <app-name> - Create a Boilerplate React ES6 Nodejs Project without installing the create-react-app package locally.
			npm run build 			- Invoke Code Compilation and Minification of Assets within the 'src' folder, and transfers the generated Artifacts into a separate 'build' folder.
			npm run eject			- Import the (Webpack) configuration files from create-react-app for more customization of the local React Project.
			
	
