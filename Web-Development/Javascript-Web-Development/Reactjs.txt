React.js
	Abbreviations:
		MVC: 						Model-View-Controller.
		SPA:						Single-Page Application.
		PWA:						Progressive Web Application.
		
		HTML: 						HyperText Markup Language.
		CSS:						Cascading Style Sheets.
		DOM:						Document Object Model.
		
		JS: 						Javascript.
		JSX: 						Javascript Syntax Extension.
	
	Description: A Lightweight Frontend Library for building User Interfaces for Applications. It is part of the View Layer in the MVC Architecture.
	
	Tutorials:
		Quick Start: https://youtu.be/sBws8MSXN7A
	
	Concepts:
		Virtual DOM: 				A Lightweight Abstraction of the Actual DOM (i.e. no CSS considerations, etc), represented by a tree of JS Objects.
		React Element:				Lightweight, Immutable, Stateless, Functionless unit describing a Component Instance - a Virtual DOM node or sub-tree. It is implicitly produced from the compilation of JSX during rendering.

		React Component:			Small, reusable pieces of code that return a React Element to be rendered to the Web Page.
		React Component Instance:	A React Element, but with Functions and State.

		State:						Information maintained by a React Component which it itself can change.
		Props: 						Information received by a React Component from other React Components which it should NOT change directly - use Event Handlers.

		Render: 					A term to describe the process of adding a React Element to the Virtual DOM tree, and modifying the actual DOM tree appropriately.

		Uncontrolled Component:		A React Component that maintains its own internal State. Usually only used w.r.t React Form Elements.
		Controlled Component:		A React Component that does not maintain internal State. Usually only used w.r.t React Form Elements.
	
	Details:
		React.js Library handles Element creation and manipulation.
		ReactDOM.js Library handles DOM interaction.

		React faciliates the construction of SPAs:
			The default entry point, public/index.html, contains a top-level <div> 'root', which will contain the entirety of the React Application as part of the SPA functionality.
			The default Javascript entry point, src/index.js, should reference a top-level React Component 'App' and render it in the top-level <div> 'root'.
				import React from 'react';
				import {render} from 'react-dom';
				
				import './index.css';
				import 'App' from './App.js';
				
				render(<App />, document.getElementById('root'));
		
		React makes use of self-contained Components with their own Component-Level State.
			These States will determine how the Component will appear and behave.

			When these States change and the Component gets re-rendered, React uses the Virtual DOM to update and detect which parts of the Page has changed, so it only selectively updates the Actual DOM, as a form of optimization.
				1. React takes a snapshot of the Virtual DOM before the update.
				2. React then updates the entire Virtual DOM. This makes it easier to comprehend - we need only to return the Virtual DOM that we want to see, and not keep track of all changes happening to the Virtual DOM.
				3. Diffing the captured snapshot of the Virtual DOM with the updated Virtual DOM allows React to detect which Actual DOM Objects should be updated.
				4. React proceeds to only update the Actual DOM Objects identified in the earlier step.
		
		React Patterns:
			Parent Stateful -> Child Stateless : Pass Parent State / State Changer as Child Props. Child Component can declare custom function wrapper for received State Change Function to make it suitable as a Event Handler.
			Child Stateless -> Child Stateless = Child Stateless -> Parent Stateful -> Child Stateless : Separation of Concerns.
				Business Logic (Container Components) and Display Logic (Presentational Components).

			Use Props to set State only when it is clear the data involved is just initialization data. Components will automatically re-render if the Props change.

		React Components:
			Class-Component:
				import React from 'react';
				import PropTypes from 'prop-types';
				
				import './ExampleClass.css';
				import 'OtherComponent' from './OtherComponent.js';

				import ReactDOM from 'react-dom';

				// Note: Class Names to begin with a Capital Letter to help React distinguish between HTML Elements and React / JSX Element.
				Class ExampleComponent extends React.Component {
					// Mounting: Phase in Component Lifecycle which depicts creation of a corresponding React Element and its initial Render.
						constructor(props) {
							super(props);

							// Initialize Local State Object directly.
							this.state = { //... };

							// Binding Event Handler Methods to a Component Instance. Can be omitted if using (ev) => {this.handleStateChange(ev)} 
							this.handleStateChange = this.handleStateChange.bind(this);
						}

						// Set State without need for declaring Constructor.
						state = {
							// ...
						};

						componentWillMount() {
							// Called before the render Function is invoked - a chance to update state in preparation for the first render.
							// ...

							this.setState((state, props) => { // ... });
						}

						// Compulsory
						render() {
							// Examines this.props and this.state, and returns a React Element.
							// Child Render methods are also executed.
							// This should be a Pure Function - do not call this.setState() or mutate any global states here.
							/*
								React Elements are produced via JSX.
									Evaluation of any JS is only done via JS Injection within curly braces.
										You cannot inject JS if-statements directly within JSX. Utilize either:
											1. Ternary Operator - it always evaluates to a JS Expression (returns a value) unlike an if-else statement.
											2. Immediately-Invoked JS Function - (() => {})()
									Utilize the && operator for code that either will or will not appear. 
									JSX can still be used within the braces.
									Multi-line JSX should be enclosed with parentheses.
								
								React Elements can have attributes, similar to DOM / HTML.
									Note: Replace the 'class' DOM attribute to 'className' for compiling from JSX -> JS, since 'class' is a reserved keyword in JS.
									Note: style DOM attribute to be specified as a JS Object, and with the names of usual CSS style properties in camelCase as opposed to dash-delimited words.
									Note: Child Elements produced from mapping an Iterable need to have the top-level Child Element specify a distinguishing 'key' element.

								React Elements can have Event Listeners, similar to DOM / HTML, but with the names in camelCase as opposed to lowercase.
									let exampleElement = <img onHover={ exampleJSFunction } />; // The Event Listeners act on JS functions.

								React Elements can also utilize CSS Style Declarations, similar to HTML, but with the names in camelCase as opposed to lowercase hyphenation.
									let exampleElement = <h1 style={{background: 'lightblue', color: 'darkred', fontSize: '20px'}}> Test </h1>;

								React Elements can be nested, just like in DOM / HTML.
									All React Elements must have only exactly one outermost element. The first opening tag and the final closing tag must belong to the same React element.

									Can use a <div> </div> or React Fragment (<> </>) to enclose the group.
							*/

							let subReactElement = (
								<div> 
									// ...
								</div>
							);

							return <boolean> && ( 
								<div className={<html-class-reference>} style={ { <cssAttribute>: '', ... } }>
									<p> { this.props.<prop-name> } </p>
									
									<p>
										{
											(
												() => {
													switch (this.state.<state-object-key>) {
														case "red":   return "#FF0000";
														case "green": return "#00FF00";
														case "blue":  return "#0000FF";
														default:      return "#FFFFFF";
													}
												}
											)()
										}
									</p>
									
									<OtherComponent <child-prop-name>={ // ... } <child-onStateChange>={ this.handleStateChange } />

									// OR

									<OtherComponent <child-prop-name>={ // ... } <child-onStateChange>=(ev) => {this.handleStateChange(ev)} />

									// OR

									<OtherComponent { ...this.state } /> // Object Spread Notation
								</div>
							)
						}

						componentDidMount() {
							// Additional Function that is called only after a Component has been mounted, and only once.
							// Child Components also execute their componentDidMount Functions as well.

							// setInterval ...
							// AJAX Call for Data ...
						}

						// Pass Custom Function to Child Component to alert Component when Child Component receives an Event to change State.
						handleStateChange(callback) {
							// Don't modify this.state directly, otherwise React won't know to re-render the Component.
							// Use setState() instead to merge in changes to the State, and implicitly call the Component's render() function to re-render the Component.
							this.setState(
								(state, props) => {
									return {
										// New Object that represents the intended changes to the State Object.
										// DO NOT mutate the State Object directly.
									};
								},
								callback
							);
							
							// Return (or execute) Parent stateChange method.
							return this.props.<parent-stateChange>;
						}
						
						// Specifying a Function in this manner removes the need to bind 'this'.
						handleStateChange = (callback) => {
							// ...
						}

					// Updating: Phase in which a Component updates due to changes in Props or State. Only occurs after the initial Render / Mounting Phase.
						componentWillReceiveProps(nextProps) {
							// Called only when Component will receive Props, regardless if old or new.
						}
						
						shouldComponentUpdate(nextProps, nextState) {
							// Default Behaviour is to re-render on any State change.
							// return either True or False
						}
						
						componentWillUpdate(nextProps, nextState) {
							// Cannot call this.setState() here.
							// Meant for interactions outside of the React architecture.
						}

						// Called if this.props or this.state is changed.
						render() 

						getSnapshotBeforeUpdate(prevProps, prevState) {
							// Called before the new React Element is commited to the Virtual DOM.
							// Enables the Component to capture information from the Actual DOM before it is potentially changed.
						}

						componentDidUpdate(prevProps, prevState, snapshot) {
							// Called immediately after any updating occurs.
							// Meant for interactions outside of the React architecture.
						}

					// Unmounting: Phase in which a Component Instance is no longer actively inside the generated React Element that it is usually under, or if ReactDOM.unmountComponentAtNode( ... ) is used.
						componentWillUnmount() {
							// Called immediately before a Component is unmounted and destroyed.

							// clearInterval ...
						}
				}
				
				// Explicit Declaration of expected types for Props helps to avoid errors.
				ExampleComponent.propTypes = {
					<prop-name>: PropTypes.<prop-type>[.isRequired],
					<onStateChange>: PropTypes.func[.isRequired], // parent.handleStateChange
					...
				};

				// Default Props Declaration - If no Props are passed into the Function.
				ExampleComponent.defaultProps = {
					<prop-name>: <default-value>,
					<onStateChange>: () => {},
					...
				}
				
				export default ExampleComponent;
				
				// ...

			Functional Component:
				// Useful as Presentational Components
				const ExampleComponent = (props) => { // Recall that all Properties defined via JSX gets put into a singular 'props' Object by React.
					// Extract / Consume the Props that are used.
					// other will contain all other unused Props via destructuring, which can then be separately passed down to Child Components.
					let {<used-prop>, // ... , ...other} = props;

					// other can also be referenced normally as a regular Object variable.
					// console.log(other);

					// ...
					
					return (
						{ // Ensure unknown, unconsumed Props are specified first - later Props will override if applicable }
						<ChildComponent {...other} usedProp={<used-prop>} ... /> 
					);
				}

				// React Hooks can be used to 'hook' onto Class Component Functionality:
				const ExampleComponent = (props) => {
					// Each Hook has the prefix 'use' in its name.
					// React counts on the Hook Definition Order - only define Hook Definitions at the Top-Level of the Function, outside of any Conditionals, Loops or other Functions.

					// Local Component State
					// Each State Variable defined in the manner below is independent from one another.
					// Note: Old State Values for each Variable will always be completely replaced when using the accompanying Setter Function. Keep in mind when updating Data Structures.
					const [ <state-var>, <state-var-setter-function> ] = React.useState(<initial-value>);

					// Local Component State - No Re-Render
					// Changes made to these Variables here will not cause a Re-Render.
					const <ref-var> = React.useRef(<initial-value>);
					// Access / Modify the Ref
					<ref-var>.current = <new-value>;

					// Advanced Local Component State Management
					// The key difference between useState and useReducer is that for useReducer the State can be altered in a controlled manner as opposed to simply using the <state-var-setter-function>.
					const [ <state-var>, <dispatch-function> ] = React.useReducer( 
						(state, action) => {
							// Reducer Function - A Function that combines two or more Arguments and returns the combination.
							// Practically, it should be a Pure Function that:
								// Does not mutate Arguments.
								// Does not generate Side-Effects (API Calls, etc).
								// Execute Impure Functions within.

							// Based on action's Properties, a new State based on the passed in state should be returned.
								// Switch on action.type
								// action.payload
							return {
								...state,
								// ...
							};
						}, 
						<initial-state>
					);

					// Side-Effects
					// Similar Behaviour to componentDidMount, componentDidUpdate and componentWillUnmount combined - the submitted Function executes after each Render (when Props or State is updated).
					React.useEffect(() => {
						// ... 

						// Return an optional cleanup Function that is executed just before each subsequent Render.
						return () => {
							// ...
						};
					}, 
						// An optional 'Dependency List' of Variables can be specified as well to limit when the submitted Function executes.
						// By submitting this List of Variables, React will then additionally only execute the submitted Function if any of the Variables in the List are changed (=== type and value check) after the first Render.
						// This List might include State Variables that are referenced in the submitted Function.
						// Hint: Passing an Empty List here would make the submitted Function behave like componentDidMount.
						[ <variable>, ... ]
					);

					// DOM Node Reference
					const nodeRef = useRef();

					// Tips
					/*
						The flow should be:
						1. Define Initial States via the useState Hook if necessary, either from Props or use placeholder default Values.
						2. Query backend API with useEffect / custom Hook, and with a Dependency List containing Props that pertain to the HTTP Request and REST Query Parameters.
						3. Render the actual Component only when a certain flag passed from the backend API changes. Use a placeholder 'Loading' Component if the flag is not of a certain state.
					*/

					return (
						<>
							{ /* ... */ }
						</>
					);
				}

				// Default Props Declaration - Static Property Declaration.
				ExampleComponent.defaultProps = {
					<prop-name>: <default-value>,
					<onStateChange>: () => {},
				}
				
				export default ExampleComponent;

				// To simulate shouldComponentNotUpdate w.r.t Props when using React Hooks
				export default React.memo(
					ExampleComponent, 
					(prevProps, nextProps) => {
						// return true if Component should not update
						// return false otherwise
					}
				);
				
				// Testing
				const mockData = {
					<prop>: <value>,
					// ...
				};

				const MockExampleComponent = () => (
					<>
						<ExampleComponent {...mockData} />
					</>
				);

				export default MockExampleComponent;

			Higher-Order Component: 
				// A Pattern involving a Function which takes in a Component and returns a new Component.
				// Useful for adding on commonly used functionality to many Components.
				// WrappedComponent needs to be configured to take in more Props.

				function withSubscription(WrappedComponent, ...) {
					// Return a new Class Component to keep the Function pure.
					return class extends React.Component {
						constructor(props) {
							super(props);
							this.handleChange = this.handleChange.bind(this);
							this.state = {
								// Functionality-Specific Local State
								data: //... ,
							};
						}

						// ... Additional Functionality Here ...

						render() {
							// Renders WrappedComponent with the appropriate minimal props.
							return <WrappedComponent {...this.props} data={this.state.data} />;
						}
					};
				}

			Render:
				let ExampleComponentElement = React.createElement(ExampleComponent, propsObject, ... children);
				ReactDOM.render(ExampleComponentElement, document.getElementById('...')); // Actually mount to DOM.

				// OR

				ReactDOM.render(<ExampleComponent />, document.getElementById('...'));

				// OR 

				ReactDOM.render(<ExampleComponent> // ... </ExampleComponent>, document.getElementById('...'));
				// Within ExampleComponent, the special this.props.children can be used to reference all nested React Elements that is a child of this ExampleComponent.
				// React.Children API Methods.
		
		React Form (Elements): Special HTML Elements that use React State as a single-source of truth.
			Typical HTML Form Elements maintain their own State (Uncontrolled). However, the React version of these Elements use the Component State instead (Controlled).
				This enforces that every State mutation will have an associated handler function, making it straightforward to modify or validate User Input.
				Allows for finer-grained synchronization between User Input and Server State.

			When these (usually HTML) Form Elements have a 'value' attribute specified in the React Element specification, they switch from using their internal State to the React Component State instead:
				<element onChange={this.onChangeHandlerFunction} value={this.state.value} />

		React Context API / Redux: Application-Level State Managers to maintain and share State across multiple Components.
			Central Store for all Components. Avoids complex “prop” graphs in Component Trees.
	
	Commands:
		Create-React-App: CLI Tool for Creating Boilerplate React Apps.
			Features:
				Dev Server with Hot Reload
			
			npx create-react-app <app-name> - Create a Boilerplate React ES6 Nodejs Project without installing the create-react-app package locally.
			npm run build 			- Invoke Code Compilation and Minification of Assets within the 'src' folder, and transfers the generated Artifacts into a separate 'build' folder.
			npm run eject			- Import the (Webpack) configuration files from create-react-app for more customization of the local React Project.
			
	
