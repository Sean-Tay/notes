React.js
	Abbreviations:
		MVC: 						Model-View-Controller.
		SPA:						Single-Page Application.
		PWA:						Progressive Web Application.
		
		HTML: 						HyperText Markup Language.
		CSS:						Cascading Style Sheets.
		DOM:						Document Object Model.
		
		JS: 						Javascript.
		JSX: 						Javascript Syntax Extension.
	
	Description: A Lightweight Frontend Library for building User Interfaces for Applications. It is part of the View Layer in the MVC Architecture.
	
	Tutorials:
		Quick Start: https://youtu.be/sBws8MSXN7A
	
	Concepts:
		React Element:				Lightweight, Immutable, Stateless, Functionless, Nestable, plain JS Object that describes what should be shown on screen - a Virtual DOM Node or Sub-Tree. It is implicitly produced when inline JSX is compiled down to React.createElement() calls during Rendering.
		Virtual DOM: 				A Lightweight Reflection of the Actual DOM (i.e. CSS Layout recalculation, etc.), which can be seen as being represented by a Tree of React Elements.
		Actual DOM:					The state in the Browser that keeps track of exactly how the Webpage should display and behave.

		React Component:			Refers to the syntactical definition that would create a React Component Instance.
		React Component Instance:	An Instance of a React Component. Returns a React Element adjusted for State and Functions when Rendered.

		State:						Information maintained by a React Component Instance which it itself can change.
		Props: 						Information received by a React Component Instance from other React Component Instances which it should NOT change directly.

		[Re-]Render: 				The process of [re-]creating any associated React Element from a React Component Instance. This often results in Reconciliation and Painting.
		Reconciliation:				The asynchronous process of diff-ing the current Virtual DOM Tree, and the next Virtual DOM Tree with changes from any Re-Renders applied to ascertain the actual changes needed for the UI. The changes are accumulated before the actual diff-ing occurs as a form of optimization.
		Painting:					The process of applying only the actual changes derived from the Reconciliation process onto the Actual DOM Tree, and causing the Browser to re-paint the affected part of the display.

		Mounting:					Phase in the Component Lifecycle in which a Component Instance is being Painted for the first time.
		Updating: 					Phase in the Component Lifecycle in which a Mounted Component Instance is updating due to changes in Props or State.
		Unmounting: 				Phase in the Component Lifecycle in which a Mounted Component Instance is being removed from the Actual DOM Tree. 

		Uncontrolled Component:		A React Component Instance that maintains its own internal State.
		Controlled Component:		A React Component Instance that does not maintain internal State.
	
	Details:
		React.js Library manages the Virtual DOM.
		ReactDOM.js Library handles the Reconciliation and Painting processes.

		React faciliates the construction of SPAs:
			The default entry point, public/index.html, contains a top-level <div> 'root', which will contain the entirety of the React Application as part of the SPA functionality.
			The default Javascript entry point, src/index.js, should reference a top-level React Component 'App' and render it in the top-level <div> 'root'.
				import React from 'react';
				import {render} from 'react-dom';
				
				import './index.css';
				import 'App' from './App.js';
				
				render(<App />, document.getElementById('root'));
		
		React makes use of self-contained Component Instances with their own State.
		By default, changing States or Props should cause the Component Instance to be Re-Rendered.
			Presumably, the Props come from an Ancestor's State, and if the Ancestor's State changes, the Ancestor's Component Instance would be Re-Rendered, which by default should propagate the Re-Render call down to the current Component Instance.

			Note: Be careful of derived State from Props - it is not obvious that the State won't update further as a result of a change in Props.
		
		Best Practices:
			Rely only on a Single-Source of Truth for each variable. Go with either: 
				Controlled Child Component:
					Pass Parent Component State / State Changer Function into the Controlled Child Component as Props.

					Business Logic (Container Parent Component) and Display Logic (Presentational Child Component) are separated.

				Uncontrolled Child Component:
					Props for the Uncontrolled Child Component should only be used to derive its *initial* State.

					Using the special 'key' Prop would offer the Parent Component some way to reset the Uncontrolled Child Component.
					Expose a method in the Uncontrolled Child Component for the Parent Component to invoke (use a Ref to get a reference to the Child Component Instance).

			Keep the Render Functionality of a Component free from any resource-intensive operations, or long running side-effects.

		React Components:
			import * as React from 'react';

			Class-Component:
				import PropTypes from 'prop-types';
				
				import './ExampleClass.css';
				import 'OtherComponent' from './OtherComponent.js';

				import ReactDOM from 'react-dom';

				// Note: Class Names to begin with a Capital Letter to help React distinguish between HTML Elements and React / JSX Element.
				class ExampleComponent extends React.Component {
					// Initialization:
						constructor(props) {
							super(props);

							// Initialize Local State Object directly.
							this.state = { //... };

							// Binding Event Handler Methods to a Component Instance. Can be omitted if using (ev) => {this.handleStateChange(ev)} 
							this.handleStateChange = this.handleStateChange.bind(this);
						}

						// Set State without need for declaring Constructor.
						state = {
							// ...
						};

						// Pass Custom Function to Child Component to alert Component when Child Component receives an Event to change State.
						handleStateChange(callback) {
							// Don't modify this.state directly, otherwise React won't know to re-render the Component.
							// Use setState() instead to merge in changes to the State, which will also implicitly re-render the Component.
							// Don't reference this.state directly as the update triggered by this.setState is asynchronous - use the update function argument form, as shown below.
							this.setState(
								(state, props) => {
									return {
										// New Object that represents the intended changes to the State Object.
										// DO NOT mutate the State Object directly.
									};
								},
								callback
							);
							
							// Return (or execute) Parent stateChange method.
							return this.props.<parent-stateChange>;
						}
						
						// Specifying a Function in this manner removes the need to bind 'this'.
						handleStateChange = (callback) => {
							// ...
						}

						// Compulsory
						render() {
							// Examines this.props and this.state, and returns a React Element.
							// Child Component Instances are also Rendered.
							// This should be a Pure Function - do not call this.setState() or mutate any State here.
							/*
								React Elements are produced when inline JSX is compiled down to React.createElement() calls during Rendering.
									Evaluation of any JS is only done via JS Injection within curly braces.
										You cannot inject JS if-statements directly within JSX. Utilize either:
											1. Ternary Operator - it always evaluates to a JS Expression (returns a value) unlike an if-else statement.
											2. Immediately-Invoked JS Function - (() => {})()
									Utilize the && operator for code that either will or will not appear. 
									JSX can still be used within the braces.
									Multi-line JSX should be enclosed with parentheses.
								
								React Elements can have attributes, akin to HTML DOM Elements.
									Note: Replace the 'class' DOM attribute to 'className' for compiling from JSX -> JS, since 'class' is a reserved keyword in JS.
									Note: CSS style DOM attribute to be specified as a JS Object, and with the names of usual CSS style properties in camelCase as opposed to kebab-case.
									Note: HTML DOM Event Listener attributes have their names specified in camelCase instead of lowercase.
									Note: Child Elements produced from mapping an Iterable need to have the top-level Child Element specify a distinguishing 'key' element.

								React Elements can be nested, akin to HTML DOM Elements.
									All React Elements must have only exactly one outermost React Element. The first opening tag and the final closing tag must belong to the same React element.

									Can use a <div> </div> or React Fragment (<> </>) to enclose the group.
							*/

							let subReactElement = (
								<div> 
									// ...
								</div>
							);

							return <boolean> && ( 
								<div className={<html-class-reference>} style={ { <cssAttribute>: '', ... } }>
									<p> { this.props.<prop-name> } </p>
									
									<p>
										{
											(
												() => {
													switch (this.state.<state-object-key>) {
														case "red":   return "#FF0000";
														case "green": return "#00FF00";
														case "blue":  return "#0000FF";
														default:      return "#FFFFFF";
													}
												}
											)()
										}
									</p>
									
									<OtherComponent <child-prop-name>={ // ... } <child-onStateChange>={ this.handleStateChange } />

									// OR

									<OtherComponent <child-prop-name>={ // ... } <child-onStateChange>=(ev) => {this.handleStateChange(ev)} />

									// OR

									<OtherComponent { ...this.state } /> // Object Spread Notation
								</div>
							)
						}

					// Mounting: 
						UNSAFE_componentWillMount() {
							// Called before the render Function is invoked - a chance to change the State before the Component Instance is Rendered.
							// A preferred alternative would be to set the desired State in the constructor as part of Initialization.
							// ...

							this.setState((state, props) => { // ... });
						}

						render()

						componentDidMount() {
							// Additional Function that is called only after a Component has been Mounted, and only once.
							// Child Components also execute their componentDidMount Functions as well.

							// setInterval ...
							// AJAX Call for Data ...
						}

					// Updating:
						UNSAFE_componentWillReceiveProps(nextProps) {
							// Called only when Component will receive Props, regardless if old or new.
						}
						
						shouldComponentUpdate(nextProps, nextState) {
							// Default Behaviour is to re-render on any State change.
							// return true if Component should update
							// return false otherwise
						}
						
						UNSAFE_componentWillUpdate(nextProps, nextState) {
							// Cannot call this.setState() here.
							// Meant for interactions outside of the React architecture.
						}

						render() 

						getSnapshotBeforeUpdate(prevProps, prevState) {
							// Called before the Reconciliation process.
							// Enables the Component to capture information from the Actual DOM before it is potentially changed.
						}

						componentDidUpdate(prevProps, prevState, snapshot) {
							// Called immediately after any updating occurs.
							// Meant for interactions outside of the React architecture.
						}

					// Unmounting:
						componentWillUnmount() {
							// Called immediately before a Component Instance is removed from the Actual DOM Tree and is destroyed.

							// clearInterval ...
						}
				}
				
				// Explicit Declaration of expected types for Props helps to avoid errors.
				ExampleComponent.propTypes = {
					<prop-name>: PropTypes.<prop-type>[.isRequired],
					<onStateChange>: PropTypes.func[.isRequired], // parent.handleStateChange
					...
				};

				// Default Props Declaration - If no Props are passed into the Component.
				ExampleComponent.defaultProps = {
					<prop-name>: <default-value>,
					<onStateChange>: () => {},
					...
				}
				
				export default ExampleComponent;
				
				// ...

			Functional Component:
				// Useful as Presentational Components
				const ExampleComponent = (props) => { // Recall that all Properties defined via JSX gets put into a singular 'props' Object by React.
					// Extract / Consume the Props that are used.
					// other will contain all other unused Props via destructuring, which can then be separately passed down to Child Components.
					const {<used-prop>, // ... , ...other} = props;

					// other can also be referenced normally as a regular Object variable.
					// console.log(other);

					// ...
					
					return (
						{ // Ensure unknown, unconsumed Props are specified first - later Props will override if applicable }
						<ChildComponent {...other} usedProp={<used-prop>} ... /> 
					);
				}

				// React Hooks can be used to 'hook' onto Class Component Functionality:
				const ExampleComponent = (props) => {
					// Each Hook has the prefix 'use' in its name.
					// React counts on the Hook Definition Order - only define Hook Definitions at the Top-Level of the Function, outside of any Conditionals, Loops or other Functions.

					// Local Component State
						// Each State Variable defined in the manner below is independent from one another.
						// Note: Old State Values for each Variable will always be completely replaced when using the accompanying Setter Function. Keep in mind when updating Data Structures.
						// Note: The State Value does NOT get updated if it was initialized from a Prop and that Prop changes. Update it via useEffect.
						const [ <state-var>, <state-var-setter-function> ] = React.useState(<initial-value>);

						// Modify the State.
						<state-var-setter-function>(<new-value>);
						// Modify the State based on the previous State.
						<state-var-setter-function>(
							(<prev-value>) => {
								// ...
								return <new-value>;
							}
						);

					// Local Component State - No Re-Render
						// Changes made to these Variables here will not cause a Re-Render.
						const <ref-var> = React.useRef(<initial-value>);
						// Access / Modify the Ref.
						<ref-var>.current = <new-value>;

					// Advanced Local Component State Management
						// The key difference between useState and useReducer is that for useReducer the State can be altered in a controlled manner as opposed to simply using the <state-var-setter-function>.
						// It is also more suited for managing State Objects that have multiple sub-values.
						const [ <state-var>, <dispatch-function> ] = React.useReducer( 
							(state, action) => {
								// Reducer Function - A Function that combines two or more Arguments and returns the combination.
								// Practically, it should be a Pure Function that:
									// Does not mutate Arguments.
									// Does not generate Side-Effects (API Calls, etc).
									// Execute Impure Functions within.

								// Based on action's Properties, a new State based on the passed in state should be returned.
									// Switch on action.type
									// action.payload
								return {
									...state,
									// ...
								};
							}, 
							<initial-state>
						);

					// Side-Effects
						// Similar Behaviour to componentDidMount, componentDidUpdate and componentWillUnmount combined - the submitted Function executes after each Render (when Props or State is updated), without blocking the Browser from painting the display.
						React.useEffect(
							() => {
								// ... 

								// Return an optional cleanup Function that is executed just before each subsequent Render.
								return () => {
									// ...
								};
							}, 
							// An optional 'Dependency List' of Variables can be specified as well to limit when the submitted Function executes.
							// By submitting this List of Variables, React will then additionally only execute the submitted Function if any of the Variables in the List are changed ( === type check ) after the first Render.
							// If the submitted Function may directly or indirectly reference any Component's State (it's own or from Ancestor Components' passed in as Props), the references should be placed in the Dependency List.
							// Hint: Passing an Empty List here would make the submitted Function behave like componentDidMount.
							// Hint: For Arrays and Objects, use JSON.stringify to reduce false positives.
							// Hint: For Functions, specify as it is (do NOT use JSON.stringify) to avoid false negatives.
							[ <variable>, ... ]
						);

						// Same functionality as with useEffect, except that it DOES block the Browser from Painting until the execution is over.
						React.useLayoutEffect(
							() => {
								// ...
							},
							[ <variable>, ... ]
						);

					// Optimizations - Avoid using as a guarantee to prevent Re-Renders.
						// Used to prevent unneccessary recalculation of some value per Re-Render.
						// Hint: That 'some value' can be a React Element too.
						React.useMemo(
							() => {
								// ...

								return expensive(<variable>, ...);

								// OR 

								return <ExampleComponent arg={<variable>} />;
							},
							// Optional 'Dependency List' of Variables, same as with useEffect().
							[ <variable>,  ... ]

							// OR

							// Optional Comparator Function
							(prev, next) => {
								// return true if the value should not be recalculated
								// return false otherwise
							}
						);
						
						// Used to define Functions within Functional Components that won't be unneccessarily recreated per Re-Render.
						React.useCallback(
							(<arg-1>, ...) => {
								// ...

								return;
							}, 
							// Optional 'Dependency List' of Variables, same as with useEffect().
							[ <variable>, ... ]
						);

					// DOM Node Reference
					const nodeRef = React.useRef();
					// ... <div ref={{nodeRef}}> </div> ...
					// ... nodeRef.current ...

					// Tips
					/*
						The flow should be:
						1. Define initial States via useState Hooks if necessary, either from Props or use placeholder default Values.
						2. Query backend API and update State with useEffect / custom Hooks, and with a Dependency List containing Props that pertain to the HTTP Request and REST Query Parameters.
						3. Render the actual Component only when a certain flag passed from the backend API changes. Use a placeholder 'Loading' Component if the flag is not of a certain state.
					*/

					return (
						<>
							{ /* ... */ }
						</>
					);
				}

				// Default Props Declaration - Static Property Declaration.
				ExampleComponent.defaultProps = {
					<prop-name>: <default-value>,
					<onStateChange>: () => {},
				}

				export ExampleComponent;
				
				// To simulate shouldComponentNotUpdate w.r.t Props when using React Hooks
				export const MemoExampleComponent = React.memo(
					ExampleComponent, 
					// If the Function below is not provided, ExampleComponent will only re-Render once its Props changes.
					(prevProps, nextProps) => {
						// return true if Component should not update
						// return false otherwise
					}
				);

				// Testing
				const mockData = {
					<prop>: <value>,
					// ...
				};

				const MockExampleComponent = () => (
					<>
						<ExampleComponent {...mockData} />
					</>
				);

				export default MockExampleComponent;

			Higher-Order Component: 
				// A Pattern involving a Function which takes in a Component and returns a new Component.
				// Useful for adding on commonly used functionality to many Components.
				// WrappedComponent needs to be configured to take in more Props.

				function withSubscription(WrappedComponent, ...) {
					// Return a new Class Component to keep the Function pure.
					return class extends React.Component {
						constructor(props) {
							super(props);
							this.handleChange = this.handleChange.bind(this);
							this.state = {
								// Functionality-Specific Local State
								data: //... ,
							};
						}

						// ... Additional Functionality Here ...

						render() {
							// Renders WrappedComponent with the appropriate minimal props.
							return <WrappedComponent {...this.props} data={this.state.data} />;
						}
					};
				}

			Rendering:
				let ExampleComponentElement = React.createElement(ExampleComponent, propsObject, ... children);
				ReactDOM.render(ExampleComponentElement, document.getElementById('...')); // Actually mount to DOM.

				// OR

				ReactDOM.render(<ExampleComponent />, document.getElementById('...'));

				// OR 

				ReactDOM.render(<ExampleComponent> // ... </ExampleComponent>, document.getElementById('...'));
				// Within ExampleComponent, the special props.children can be used to reference all nested React Elements that is a child of this ExampleComponent.
				// React.Children API Methods.
		
		React Form: Modified HTML Form that uses React State as a single-source of truth.
			Typical HTML Form Elements maintain their own State (Uncontrolled). However, the React version of these Elements use the Component State instead (Controlled).
				This enforces that every State mutation will have an associated handler function, making it straightforward to modify or validate User Input.
				Allows for finer-grained synchronization between User Input and Component State.

			When these HTML Input Elements have a 'value' attribute specified in the React Element specification, they switch from using their internal State to the React Component State instead:
				<input value={this.state.value} onChange={this.onChangeHandlerFunction} />

		React Context API / Redux: Application-Level State Managers to maintain and share State across multiple Components.
			Central Store for all Components. Avoids complex “prop” graphs in Component Trees.
	
	Commands:
		Create-React-App: CLI Tool for Creating Boilerplate React Apps.
			Features:
				Dev Server with Hot Reload
			
			npx create-react-app <app-name> - Create a Boilerplate React ES6 Nodejs Project without installing the create-react-app package locally.
			npm run build 			- Invoke Code Compilation and Minification of Assets within the 'src' folder, and transfers the generated Artifacts into a separate 'build' folder.
			npm run eject			- Import the (Webpack) configuration files from create-react-app for more customization of the local React Project.
			
	
