Javascript
	Hoisting:												Javascript Interpretation would store Variable and Function Declarations (NOT Initializations) in Memory first, before any Execution begins.
		This is how Variables and Functions can be used within Code before they have been Defined.
	
	Scopes:
		const 												block {} scope, unchangeable once declared, not redeclarable
		let 												block {} scope, changeable once declared, not redeclarable
		var 												global scope, changeable once declared, redeclarable

	Primitives:
		boolean:											Literal true / false.
		string
		number:												Literal Integers, Floats / Doubles, Infinity, NaN.
		null
		undefined
		Symbols

	Common Syntax:
		Basic Javascript Expression Manipulation: 
			Raw Data Types: 
				var myString = "Test";
					var myTemplateString = `Testing: ${dynamicValue}`; // Can also be Multi-line
				var myNumber = 23;
				var myBoolean = true;
				var myFunction = () => {};

			console.log("Something to Print"); 					// Prints Output.
			console.table(<collection>);						// Prints Tabular Output for Arrays or Objects.
			console.trace();									// Prints out current Stack Trace for where this was Executed at.

			Comments // /* */

			if (condition1) {
				// ...
			} else if (condition2) {
				// ...
			} else {
				// ...
			}

			switch (variable) {
				case 'value1': 
					// ...
					break;
				// ...
				case 'valueN-1':
				case 'valueN': 
					// ...
					break;
				default: 
					// ...
					break;
			}
			
			for (var index = 0; index < 5; index++) {
				// ...
			}

			To check if two things are equal to each other (same values check only): ==
			To check if two things are unequal to each other (different values check only): !=
			To check if two things are equal to each other (same values and types check): ===
			To check if two things are unequal to each other (different values and types check): !==

			// Note: Objects, Arrays and Functions are never equal to each other, unless the equality check is done through the same reference:
			const ref = {};
			console.log( ref === ref ); // true
			console.log( ref === {} ); // false

		Iterables:
			var arr = [ element1, ... ];
			
			var newArr = arr.map(
				function ( element, index, arrRef ) {
					// Return something based on each Element.
				}
			);

			var filteredArr = arr.filter(
				function( element, index, arrRef ) {
					// Return true to keep the Element in the returned Array, false to exclude the Element from the returned Array.
				}
			);

			var result = arr.reduce(
				function( prev, element, index, arrRef ) {
					// Return some combinate value of prev and element, traversing through the Array from Left to Right.
				}, 
				<optional-accumulator-initial-value>
			);

			var sortedArr = arr.sort( // Sort the contents in the Array according to the Sorting Function passed in.
				function( elementA, elementB ) { 
					// Return relative value of elementA to elementB:
					// 	-1 	=> elementA will be placed before elementB.
					// 	0 	=> elementA and elementB's relative ordering will be maintained.
					// 	1	=> elementB will be placed before elementA.
				}
			);

			var slicedArr = arr.slice(<start-index>, [<end-index>]); // Returns a Shallow Copy of the Array from the <start-index> inclusive to the <end-index> exclusive.

			var deletedArr = arr.splice(<start-index>, <count>, <item-1>, ... ); // Can be used to Insert or Remove a Portion from an Array, starting at <start-index>.

			var isSomeCondition = arr.some(
				// Returns a boolean representing if any Elements in the Array satisfy the condition in the given Function.
				// Note: If the Array is Empty, this always returns false.
				function(element) {
					// return true if the Element fulfills a condition, false otherwise.
				}
			);

			var isEveryCondition = arr.every(
				// Returns a boolean representing if all Elements in the Array satisfy the condition in the given Function.
				// Note: If the Array is Empty, this always returns true.
				function(element) {
					// return true if the Element fulfills a condition, false otherwise.
				}
			);

			// Iteration
			for (const item of arr) {
				// ...
			}

			// Note: Javascript features Associative Arrays, which silently allows out-of-bounds index access (returns undefined).

		Objects: Key-Value Mappings.
			var objectName = { 
				key:value, 
				key:value, 
				key:this.key 
			};

			// Setting Keys and Values.
			objectName.key = value; // Set the literal string 'key' as the property that will hold the value.
			objectName[key] = value; // Set the value of the variable key as the property that will hold the value.
			
			Object.assign(<targetObject>, object1, object2, ...);
				// Mutates targetObject with the content stored in object1, object2, etc...
				// If more than one object has different values for the same key, only the latest object (i.e. object2) will have its changes pushed.
			
			Object.keys(<targetObject>); // Obtain Array of keys defined in <targetObject>.
			Object.values(<targetObject>); // Obtain Array of values within <targetObject>.

			JSON.stringify(objectName); // Encode object as a JSON

			// Iteration
			for (const key in objectName) {
				// Note: Will also iterate over Keys that the Object inherits from its Constructor's Prototype.
				// ...
			}

			for (const key of Object.keys(objectName)) {
				// ...
			}

		Functions:
			function functionName(
				arg,
				// ...
			) {
				// Call-by-Sharing
				// if arg is set to a new value, it will only take effect within the scope of the function
				// if arg's properties are set to a new value, it will affect the original supplied argument to the function

				// ...
			}

			// Anonymous Function
			function(
				arg, 
				// ...
			) {
				// ...
			}

			// Default Arguments
			const functionName = function(
				arg = <default-value>, 
				// ...
			) {
				// ...
			};

			// 'Class' Constructor.
			function classConstructor( ... ) {
				this.property = ...;
			}

			functionName();

			// Patterns:
				// An Object should be used instead of a Parameter List to avoid breaking changes when a new Paramenter is added.
				function functionName(params = {}) {
					if (params.arg !== undefined) {
						// ...
					}

					// ...
				}

				// A Callback Function can be provided in the Function's Parameters to allow other execution to take place in the event something significant happens during the execution of this Function.
				function functionCallback(params = {}) {
					// ...
					params.callback !== undefined && params.callback();
				}
			
			// Note: Functions are actually Objects!

		Static Properties
			// Allows the addition of Properties and Methods to the Object Type specifically.
			// These cannot be accessed by instances of the Object Type.

			myObj.staticProperty = <value>;

			OR

			class myClass {
				
				// ...

				// Via the static keyword (ES6)
				static staticProperty = <value>;

				// ...

			}
		
		Prototype Properties
			// Allows the addition of Properties and Methods to all instances of a Type.
				// This is useful for adding Properties and Methods to a Type in which the Type Definition is not available.

			// Also allows the extension of Parent Types to add aforementioned Properties and Methods to Child Types.
				// Avoid doing so if the use-case makes more sense as an Interface Implementation (has-a vs is-a).
			
		// this refers to the current scope's owner - can be a Class or a Function
			// The value of this in a Function is determined by how the Function was called.

			<function>.bind(this); // To make any usage of 'this' refer to the containing scope's definition of 'this' where the statement was invoked.

		Error Handling:
			try {
				// Execute something here which may throw an Error.

				var result = someFunction();

				if (!result) {
					throw new Error('Invalid Result');
				}

				return result;
			} catch (err) {
				// Catch any Errors thrown within the try block, and execute Error-Handling functionality.

				if (err === 'Invalid Result') {
					// ...
				}

				return;
			} finally {
				// Always executes, even if there is a prior return statement.
				// Tip: Use to combine common tail-functionality in the try and catch blocks.

				// ...
			}
	
	> ES6:
		Switch Case:
			switch (variable) {
				case 'value1': {
					// ...
					break;
				}
				// ...
				case 'valueN-1':
				case 'valueN': {
					// ...
					break;
				}
				default: {
					// ...
					break;
				}
			}

		Computed Object Property Name: Evaluate an expression to determine the Property Name of a Value assigned to an Object.
			const example = {
				[<js-expression>]: <value>, // Note the Square Braces as the Syntax to apply.
			};

		Spread / Rest Operator: Convenient Syntax.
			Spread Operator: Used as a shorthand for expanding an Iterable / Object into its constituent Items inline.
				Usage: ...<Item>
				
				Shallow Duplication Pattern: 
					[ ...<Array> ]

					// OR

					{ ...<Object> }

				Concatenate Pattern: 
					[ ...<Array>, item ]

					// OR

					{
						...<Object>,
						<property>: <value>
					}
				
				// Avoid this, as this re-creates the Iterable per loop.
				// For the best performance, use for ... of, and mutate the Accumulator Iterable instead.
				Reduce Anti-Patterns:
					<array>.reduce((prev, item) => ([ ...prev, item ]), <initial-arr>);
					<array>.reduce((prev, item) => ({ ...prev, item }), <initial-obj>));

				Conditional Object Property Pattern:
					{
						...<conditional> && { <property> : <value> }
					}
			
			Rest Parameter: Used as a shorthand to gather up variables into an Iterable / Object.
				Usage: 
					...<Item>

					// OR 

					<var>, ..., ...<Item> // To remove Variables from the Iterable in their order.

				Function Arguments:
					( ...<arguments-iterable> ) => {
						// ...
					}
				
				Object Destructuring: See below.
			
		Destructuring Syntax: Convenient Syntax for copying a subset of Properties / Elements from an Iterable / Object.
			Iterable Destructuring:
				const [ <property>, ... ] = [ <value>, ... ];  

			Object Destructuring: Declare Variables that contain only specific Properties from the Object.
				const { <property> : <property-alias>, ..., ...<rest-object> } = <Object>;

			// Assigning a Default Value if unpacked property is not defined in <struct>
			const { <undefined-property> : <property-alias> = <default-value> } = <struct>;

		Optional Chaining Syntax: Convenient Syntax to safely access Properties of an Object.
			const example = {
				<key>: {
					<deep-key>: <value>
				},
				<key>: <value>,
				// ...
			};

			// const value = example && example.<key> && example.<key>.<deep-key>; // false
			const value = example?.<key>?.<deep-key>;

			// If at any point the chain access fails, the statement will short-circuit into one with an 'undefined' fallback value.
			const undefinedValue = example?.<non-existant-key>?.<deep-key>;

		Nullish Coalescing Syntax: A Logical Operator that returns the value on its right-han side, when the value on the left-hand side is null or undefined.
			// const fallback = null || <fallback>; // Will assign <fallback> if left value is falsy (i.e. false, 0 , '').
			const fallback = null ?? <fallback>;

		Arrow Function: A Function that has a shorter syntactic definition than a regular (Anonymous) Function.
			function () {} becomes () => {};
			function (x) { return x; } becomes x => x;
			
			(x) => { return x; }
				// LHS - Argument List
				// RHS - To Return
					// Using parenthesis in place of the RHS braces represents an implicit return statement. Should be used if there's a sole return statement in the body of the anonymous function.
					// (x) => (x) // Equivalent to the above
					// Useful for simplified syntax for React 
						const Counter = () => (
							<h1> Value </h1>
						);

			// Moreover, Arrow Functions do NOT change the 'this' context, unlike regular Javascript Functions. They inherit the meaning of 'this' as it was where the Arrow Function was created / defined.

		Function Currying: The process of breaking down a function that takes multiple arguments into a series of functions that each take only one argument.
			function add(a, b) { return a + b; }
			(x, y) => { return x + y; }
			
			vs.
			
			function add(a) { return function(b) {return a + b}; }
			(x) => (y) => { return x + y; }

			// This allows multiple different subtypes of the function to be built up before executing.
			const add3 = add(3);
			add3(4) // Returns 7.

			// Extreme Example
			(a) => (b) => ... (z) => { // ... }

		Sets: Data Structure that can quickly check whether or not an Element (of any Type) has been stored within.
			// Operations are sub-linear O(log(n)) or O(1) Time Complexity.
			// Uses Value Equality Checking.
			// The JS Data Structure implementation retains Insertion Order as an added feature, unlike the Sets in Math or other Languages.

			const mySet = new Set([ <element-1>, ... , <element-n> ]);

			mySet.size // Property, not Method.

			mySet.add(<new-element>);
			mySet.has(<new-element>); // true
			mySet.delete(<new-element>);

			// Space-Efficient Insertion Ordered Iteration:
			for (let element of mySet) {
				// ...
			}

			const myArray = Array.from(mySet); // Conversion back from Set to Array.

			// WeakSet - Alternative to Set that:
				// 1. Only stores Object References.
				// 2. Object References inserted here are not considered during Garbage Collection (no need to remove the Weak Object References stored here manually).
				// 3. Cannot be iterated over (Insertion Order is not kept for performance considerations).
		
		Maps: Data Structure that can quickly store and retrieve Key-Element pairs.
			// Retains Insertion Order, unlike regular JS Objects.
			// Performs better in scenarios involving frequent Addition / Removal of Key-Element pairs, as compared to regular JS Objects.

			const myMap = new Map([
				[ <element-key-1>, <element-1> ],
				...
				[ <element-key-n>, <element-n> ]
			]);

			myMap.size // Property, not Method.

			myMap.set(<new-element-key>, <new-element>);
			myMap.has(<new-element-key>); // true
			myMap.get(<new-element-key>); // undefined | <new-element>
			myMap.delete(<new-element-key>);

			// Space-Efficient Insertion Ordered Iteration:
			for (let [ elementKey, element ] of myMap) {
				// ...
			}

			const myArray = Array.from(myMap); // Conversion back from Map to Array.
		
		Promise: Object representing a Value which will eventually be available.
			const asyncOperation = () => (
				return new Promise(
					(resolveCb, rejectCb) => {
						// Executor Function with Asynchronous Behaviour.
						// 3 Possible States: Pending, Fulfilled, Rejected.

						// Insert Asynchronous Execution here.
						
						// Error Handling:
						if (err) return rejectCb(err);
						// OR
						throw err;
						
						resolveCb(val);
					}
				);
			)

			const promiseObj = asyncOperation();

			promiseObj.then(
				(val) => {
					// Value Handler.

					// ...

					return val; // The next 'then' in the chain is passed in val.
					// OR 
					return new Promise( // ... ); // The next 'then' waits for this returned Promise to finish executing.
				}, 
				(err) => {
					// Optional Error Handler.

					// ...

					// To prevent execution of any further 'then's.
					throw new Error( // ... );

					// To allow execution of any further 'then's.
					return '';
				}
			).then( // ... ) ... // Chainable.
			.catch(
				() => {
					// Terminal Error Handler.

					// ...
				}
			).finally(
				() => {
					// Invoked on both success (then) and failure (catch)

					// ...
				}
			);

			// Notes:
				// The Asynchronous Executor Function is triggered by the Promise Constructor before it returns the Promise Object.
				// Declaration of the Error Handler or Catch Block can be deferred (within Synchronous Code).

			// Promise Utility Functions:
				// Wait until all supplied Promises have resolved successfully. If even one of them rejects, Promise.all will defer execution to the Error Handler.
				Promise.all([
					<promise>,
					// ...
				]).then(
					resultsArr => {
						// ...
					}
				);

				// Wait until all supplied Promises have either resolved or rejected.
				Promise.allSettled([
					<promise>,
					// ...
				]).then(
					resultsArr => resultsArr.map(
						result => {
							// Each item is either a ResolvedPromise, or a Rejected Promise.
							// Resolved Promise: { status: 'fulfilled', value: <value> }
							// Rejeced Promise: { status: 'rejected', reason: <error> }

							// ...

							return result.value;
						}
					)
				);

			// Nested Promises:
				Promise.all([
					// ...
					Promise.all([
						// ...
					])
					// ...
				]).then(
					() => {
						// ...
					}
				);

		Async / Await Syntax:
			const asyncFunction = async () => {
				// Traditional try-catch-finally syntax works with async / await
				try {
					// Note: (Conncurrent) Execution only defers to another Task upon encountering an await Statement.

					// await can work on a Promise, or a synchronous Result
					var promiseResult = await promiseObj;

					// but usually on a function that returns a Promise
					var asyncResult = await asyncOperation();

					// await can also work on another async Function
					asyncResult = await asyncFunction();

					// ...

					return asyncResult;
				} catch (err) {
					// ...
				} finally {
					// ...
				}
			}

			asyncFunction();

			// when used in a synchronous context, the result of the Function is a Promise
			asyncFunction().then(
				// ...
			)

		Generator: A Function that conforms to the Iterator Specification, being able to 'return' multiple times.
			function* generator() {
				// ... 

				yield [<intermediate-value>];

				// ...

				yield [<intermediate-value>];

				// ...

				// Allow Values to be passed in via the .next() call.
				var passedIn = yield [<intermediate-value>];

				// ...
				
				// Substitute another Generator. The calling Generator is out of play until the substituted Generator runs out of yields.
				yield* <generator-instance>;

				// 'Return' Elements in an Iterable
				yield* <iterable>;

				// ...
				
				return [<final-value>];
			}

			// Create a Generator Instance
			const myGen = generator();

			// Using a Generator Instance
			var { value: myGenValue, done: isGenDone } = myGen.next(); // repeatable ; once there are no more upcoming yields, the return object will not contain the value property.
			var { value: myGenValue, done: isGenDone } = myGen.next([<optional-value>]); // Pass in a Value to the Generator for the current yield.

			// Using for-of:
				// Note: Does not execute return statements beyond the last yield.
				for (let forGen of generator) {
					const yieldedValue = forGen;
				}

		Classes:
			class className [extends parentClass] {
				<public-property>;
				#<private-property>;
				static <static-property>;
				
				// Note: If a Constructor is not defined, a default Constructor with the super() Function is used during creation.
				// Else:
				constructor(params) {
					super(params)

					//...

					this.#<private-property> = <value>;
				}

				// A Class Definition defines Prototype Methods.
				<method>(params) {
					// ...
				}

				// ...
			}

		Symbol: Reflection Metaprogramming within Implementation - used to change the behaviour of existing Classes and Objects.
			// Primitive Data Type.

			// Creation: Do not use the 'new' keyword with the 'constructor'.
				var mySym = Symbol('<description>');

				// Creation of the Symbol in a 'global' namespace.
				var myGlobalSym = Symbol.for('<description>');

			// A Symbol's Description is primarily used for debugging purposes.
			// Two Symbols will normally not be equivalent, even if they have the same Description.
				assert.notEqual(Symbol('foo'), Symbol('foo'));

			// If the Symbols were created via Symbol.for(), then equivalence via same Description becomes possible.
				assert.equal(Symbol.for('foo'), Symbol.for('foo'));

			// To check if a Symbol was created in the 'global' namespace:
				Symbol.keyFor( myGlobalSym ) !== undefined; 

			// Object:
				// Primarily used as Object Keys, similar to String Keys:
					var myObj = {};
					myobj[mySym] = <value>;

				// Symbols are only ever visible within an Object via: 
					Object.getOwnPropertySymbols(myobj); // Returns a List of Symbols assigned to the Object.
					
				// They do not show up when the Object's Keys are iterated over, or via existing Reflection Tools.

				// Can be regarded as a special separate namespace for Object Keys.

			// Classes:
				// Useful in declaring Private Properties:
					class ExampleClass {
						// Declare the Private Variable
							[<private-variable>] = <private-value>;

						// ...

						// Reference the Private Variable
							this[<private-variable>]
					}

			// Symbols can be used to activate / change some specific behaviour for an API that takes into account Symbol-Value Mapping.

			// Well-Known Symbols:
				Symbol.hasInstance - used by instanceof
				Symbol.iterator - used by of in for ... of
				Symbol.isConcatSpreadable
				Symbol.unscopables
				
				Symbol.match - used by String.match()
				Symbol.replace - used by String.replace()
				Symbol.search - used by String.search()
				Symbol.split - used by String.split()

				Symbol.species - Points to the constructor value of Classes

		Reflect: Reflection Metaprogramming through Introspection - used to discover low level information about Code.

		Proxy: Reflection Metaprogramming through Intercession - used to wrap Objects and intercept their behaviour through traps.

		Import / Export Syntax:
			// Named Imports and Exports:
				const className = <class>;

				export {className}; // Compiles down to: module.exports.className = <class>;
				
				export const <variable> = <value>; // Alternative Specification for the above.

				// ...

				import {className as '<alias>'} from '<module>'; // Compiles down to: const <alias> = require('<module>').className;

				// Namespace Import
				import * as '<alias>' from '<module>'; // Compiles down to: const <alias> = require('<module>');
				// <alias>.className 

			// Default Exports:
				export default className; // Make 'className' the only export of the <module>. Compiles down to: module.exports.default = className;

				// ...

				import className as <alias> from '<module>'; // Compiles down to: const <alias> = require('<module>');

			// Tips:
				// To force a plain JS File to be interpreted as a Module rather than a Script, specify an empty import or export Statement:
				export {};

				// One-liner Import / Export for Aggregating Modules:
				export * [as '<export-name>'] from '<module>';

				export { ... } from '<module>';
					export { <module-item> [as <export-name>], ... } from '<module>';
					export { default [as <export-name>] } from '<module>';

				// Do not mix import and NodeJS module.export.

	Utilities:
		Mathematical Functions: 
			Math.floor();
			Math.random();
			// ... etc.
		
		Date Functions:
			Date.now(); 									// Returns the number of milliseconds since Jan 1, 1970
			setTimeout(function, <milliseconds>); 			// Executes the specified function once the specified amount of milliseconds has passed.
			var intervalHandle = setInterval(function, <milliseconds>); // Executes the specified function repeatedly after every period of the specified amount of milliseconds has passed.
			clearInterval(<intervalHandle>); 				// Stop the repeated execution of a function.
			
		Regex: /<regex>/ or /<regex>/g to match for multiple instances of <regex>
			Quantifiers:
				<char | char-class>* : 0 or more of <char> or <char-class>
				<char | char-class>+ : 1 or more of <char> or <char-class>
				<char | char-class>? : 0 or 1 of <char> or <char-class>
				
				<char | char-class>{n} : Exactly n of <char> or <char-class>
				<char | char-class>{n, } : At least n of <char> or <char-class>
				<char | char-class>{n, m} : At least n and at most m or <char> or <char-class>
				
				<char | char-class><quantifier>? : Converts the matching to non-greedy Quantifiers.
			
			Specials:
				^ : Matches the beginning of the String.
				$ : Matches the end of the String.
			
			[<char>...]<quantifier> : Denotes Character Class to match for.
			[^<char>...]<quantifier> : Denotes Character Class to not match for.
			
			(?:<regex>) : Denotes a Non-Capturing Group for <regex>.
				<expr>(?=<regex>) : Denotes a Non-Capturing Group for a Positive Lookahead - that is, match only for occurrances where <expr> is followed by the <regex>.
				<expr>(?!<regex>) : Denotes a Non-Capturing Group for a Negative Lookahead - that is, match only for occurrances where <expr> is NOT followed by the <regex>.
				(?<=<regex>)<expr> : Denotes a Non-Capturing Group for a Positive Lookbehind - that is, match only for occurrances where <expr> is preceded by the <regex>.
				(?<!<regex>)<expr> : Denotes a Non-Capturing Group for a Negative Lookbehind - that is, match only for occurrances where <expr> is NOT preceded by the <regex>.
			
			(<regex>) : Denotes an anonymous Capturing Group for <regex>
				\1 ... \99 : References Capturing Groups previously defined.
			
			(?<name><regex>) : Denotes a Capturing Group called 'name' for <regex>. Note: The '<' and '>' in '<name>' ARE required.
				\<name> : References named Capturing Groups previously defined.
				
			Usage:
				<regex>.test(<variable>) : Test for the occurrence of a given pattern in the submitted <variable>.

				<string>.match(<regex>) : 
					- If <regex> is not globally scoped, it will return the first occurrance, alongside any capturing groups within <regex>.
					- If <regex> is globally scoped, it will return all occurrances, but without any capturing groups within <regex>.
				<regex>.exec(<string>) : 
					- If <regex> is not globally scoped, it will return the first occurrance, alongside any capturing groups within <regex>.
					- If <regex> is globally scoped and saved, it will return the ith occurrance, alongside any capturing groups, on the ith iteration of the .exec call on the <regex> object.
	
		AJAX Requests: Mechanism to query an Endpoint and retrieve Data.
			XHR:
				// Create a new AJAX XHR Request:
				const httpRequest = new XMLHttpRequest();
				
				// Specify HTTP Request Type and Target:
				httpRequest.open("{GET | POST | PUT | DELETE}", "<relative-url>"); 
				
				// Add Event Listeners for dealing with Operation Lifecycle:
				httpRequest.onload = function() { 
					/*
						Operation Lifecycle Phase Identifier
						this.readyState:
							0 - Unsent
							3 - Loading
							4 - Done
							...
					/*

					// HTTP Status Code:
					// this.status

					// ... 
				};
				
				// Fire off the AJAX XHR Request:
				httpRequest.send(null); 

			Fetch API:
				// Promise Interface:
				fetch(
					'<url>',
					// HTTP Request Object
					{
						method: <HTTP-method>,
						mode: <CORS-mode>,
						cache: <cache-control>, // for HTTP Request Content
						headers: {
							<HTTP-Request-Header-Field>: <value>,

							// Content-Type: 'application/json', // Indicates Format of Payload to be sent.
							// Accept: 'application/json',	// Indicates Preferred Format for Payload to be received.

							// ...
						},
						body: JSON.stringify(<data>)
					}
				)
					.then(
						res => {
							if (!res.ok) {
								// To handle HTTP Statuses that represent Unsuccessful Operation.
								// res.status
							}

							// Converting the Response Data to another format is also an Asynchronous Operation; a Promise is returned from the <data-conversion-method> invocation:
							return res.<data-conversion-method>(); // res.json();
						}
					)
					.then(
						convertedData => {
							if (convertedData && convertedData.success) {
								// ...
							}

							// ...
						}
					)
					.catch(
						error => {
							// ...
						}
					)

		Web Workers: For offloading CPU Intensive Tasks into a separate Background Thread.
			Motivation: Javascript was designed for single-threaded execution, but most Computers nowadays have CPUs that have more than one Execution Core.

			Characteristics:
				Multiple in one Browser Tab.
				Utilizes Message Passing for synchronization.

				Subset of Functionality available to Main Thread:
					Cannot access DOM.

			Requirements:
				Worker Code is placed entirely into a separate .js File, as Web Workers were designed to run in an isolated context for security and stability reasons.

			// Code:
				// main.js
					const worker = new Worker('<file>.js');

					// Note: By default, assume Data passed between the Main Thread and the Worker Thread is serialized / deserialized.
						// Consider restructuring the Data into one that supports the Transferrable Interface, so that only the ownership of the Data Structure is changed.

					worker.postMessage(<args>);
					worker.onmessage(
						e => {
							// e.data === <results>
							// ...
						}
					);

					worker.terminate();

				// worker.js
					this.onmessage(
						e => {
							// e.data === <args>
							// ...

							this.postMessage(<results>);
						}
					);

					this.close();

		Service Workers: For a Proxy Server between the Browser and Server, enabling capability for offline-processing.
			Characteristics:
				Only one per Browser Tab.
				Persists beyond the Browser Tab's Lifespan.

			Requirements:
				HTTPS to avoid MitM Attacks.

		Document Object Model: An in-memory (mutable) tree representation of the HTML Page after it is read by the Browser.
			DOM Elements:
				var element = document.getElementsByClassName('classname'); // No need the . prefix
				var element = document.getElementById('idName'); // No need the # prefix
		
			DOM Properties: Initialized from the values assigned to HTML Attributes. These can mutate during runtime, unlike HTML Attributes which only dictate the starting values of these Properties.
				element.innerText; 	// references the text content between opening and closing HTML tags 
				element.innerHTML; 	// references the HTML content between opening and closing HTML tags
				element.style; 		// references the js object representing the css of the HTML element
			
			DOM Events:	
				Add Event Listener:
					element.addEventListener("<eventType>", function(event) { //... }, useCapture); // Anonymous function is Event Handling Function
						// <eventType>: http://www.w3schools.com/jsref/dom_obj_event.asp
						// event: the Object containing details about the Event that triggered the listener
							// event.stopPropagation(): use to stop parent DOM elements from also receiving the event
						// useCapture: false to specify function should fire during bubbling, true to specify the function should fire during capturing
						// element.eventType = functionID; // Legacy shortcut
				
				Remove Event Listener:
					element.removeEventListener("eventType", functionID); // Doesn't seem to be able to remove anonymous functions
					element.eventType = null; // Legacy shortcut
				
				// Note: Event Listeners return Event Objects
					eventObject.target.value
					// eventObject Properties: https://developer.mozilla.org/en-US/docs/Web/API/Event

			Shadow DOM: An encapsulated DOM Tree which can be attached to any part of the regular DOM Tree, whilst still maintaining the encapsulation.
				Code within the Shadow DOM cannot affect the regular DOM Tree.

				Shadow Host: The regular DOM Tree Node to which a Shadow DOM Tree will be attached to.
				Shadow Boundary: The boundary by which a Shadow DOM Tree and the regular DOM Tree are separated by. It does not contain the Shadow Host.
				Shadow Root: The root node of a Shadow DOM Tree.

				// Creating a Shadow DOM Tree, and attaching it onto a Shadow Host.
				let shadowDOMTree = element.attachShadow({
					mode: {'open' | 'close'} // Allow if outside JS can access the Shadow DOM Tree.
				});

			API:
				document.cookie		// Returns a semicolon separated list of Cookies, or sets a custom Cookie. Cannot be done if the Cookie has been set to HttpOnly in the HTTP Response Header from the Server.

		Resize Observer: To do something when there are Size Changes detected in one or more Observed DOM Elements.
			const observer = new ResizeObserver(
				// Callback that executes whenever a Resize of the Observed Targets are detected.
				entries => {
					// entries represent the Dimensions of each Observed Target during a Detection.
						// entry.target

						// These are similar to the result of getBoundingClientRect().
							// entry.contentRect
							// entry.borderBoxSize
							// entry.contentBoxSize
				}
			);

			observer.observe(<html-element>, ...);

			observer.unobserve(<html-element>, ...);
			observer.disconnect();

