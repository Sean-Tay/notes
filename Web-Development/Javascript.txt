Javascript
	Scopes:
		const 												- block {} scope, unchangeable once declared, not redeclarable
		let 												- block {} scope, changeable once declared, not redeclarable
		var 												- global scope, changeable once declared, redeclarable

	Common Syntax:
		Basic Javascript Expression Manipulation: 
			Raw Data Types: 
				var myString = "Test";
					var myTemplateString = `Testing: ${dynamicValue}`; // Can also be Multi-line
				var myNumber = 23;
				var myBoolean = true;
				var myFunction = () => {};

			console.log("Something to Print"); 					// Prints to Console

			Comments // /* */

			if (condition1) {
				// ...
			} else if (condition2) {
				// ...
			} else {
				// ...
			}

			switch (variable) {
				case 'value1': {
					// ...
					break;
				}
				case 'value2': {
					// ...
					break;
				}
				default: {
					// ...
					break;
				}
			}
			
			for (var index = 0; index < 5; index++) {
				// ...
			}

			for (const index in <array>) {
				// ...
			}

			for (const item of <array>) {
				// ...
			}

			To check if two things are equal to each other (same values check only): ==
			To check if two things are unequal to each other (different values check only): !=
			To check if two things are equal to each other (same values and types check): ===
			To check if two things are unequal to each other (different values and types check): !==

			// Note: Objects, Arrays and Functions are never equal to each other, unless the equality check is done through the same reference:
			const ref = {};
			console.log( ref === ref ); // true
			console.log( ref === {} ); // false

		Iterables:
			var listName = [listElement, ... ]; 				// Arrays
			
			listName.map(function(listElement, listElementIndexOptional, listElementArrayRefOptional) { // Do something to each listElementType  });
			listName.filter(function(listElement) { // Return true to keep listElement in returned Array, false to exclude listElement from returned Array });
			listName.reduce(function(listElementA, listElementB) { // Return combinate value of listItemA, listItemB });

			listName.sort(function(itemA, itemB) { // Return relative value of itemA to itemB }); // Sort the contents in listName according to the sort function passed in.

		Objects: Key-Value Mappings.
			var objectName = { 
				key:value, 
				key:value, 
				key:this.key 
			};

			// Setting Keys and Values.
			objectName.key = value; // Set the literal string 'key' as the property that will hold the value.
			objectName[key] = value; // Set the value of the variable key as the property that will hold the value.
			
			Object.assign(<targetObject>, object1, object2, ...);
				// Mutates targetObject with the content stored in object1, object2, etc...
				// If more than one object has different values for the same key, only the latest object (i.e. object2) will have its changes pushed.
			
			JSON.stringify(objectName); 						// Encode object as a JSON

		Static Properties
			// Allows the addition of Properties and Methods to the Object Type specifically.
			// These cannot be accessed by instances of the Object Type.

			myObj.staticProperty = <value>;

			OR

			class myClass {
				
				// ...

				// Via the static keyword (ES6)
				static staticProperty = <value>;

				// ...

			}
		
		Prototype Properties
			// Allows the addition of Properties and Methods to all instances of a Type.
				// This is useful for adding Properties and Methods to a Type in which the Type Definition is not available.

			// Also allows the extension of Parent Types to add aforementioned Properties and Methods to Child Types.
				// Avoid doing so if the use-case makes more sense as an Interface Implementation (has-a vs is-a).
			
		// this refers to the current scope's owner - can be a Class or a Function
			<function>.bind(this); // To make any usage of 'this' refer to the containing scope's definition of 'this' where the statement was invoked.

		Functions:
			function functionName(inputArgument1) { 			// Parameters should not have the var keyword
				// ...
			}

			function() { 										// Anonymous Function
				// ...
			}

			function functionCallback( ... , callback) { 		// A callback parameter is to allow the execution (or multiple executions) of a specified function anytime during the parent function's execution
				// ...
				callback();
			}
			
			function classConstructor( ... ) {
				this.property = ...;
			}

			functionName(); 									// Invoke the functionName function
			
			// Note: Functions are actually Objects!

		Error Handling:
			try {
				// Execute something here which may throw an Error.

				var result = someFunction();

				if (!result) {
					throw new Error('Invalid Result');
				}

				return result;
			} catch (err) {
				// Catch any Errors thrown within the try block, and execute Error-Handling functionality.

				if (err === 'Invalid Result') {
					// ...
				}

				return;
			} finally {
				// Always executes, even if there is a prior return statement.
				// Hint: Use to combine common tail-functionality in the try and catch blocks.

				// ...
			}
	
	> ES6:
		Computed Object Property Name: Evaluate an expression to determine the Property Name of a Value assigned to an Object.
			const example = {
				[<js-expression>]: <value>, // Note the Square Braces as the Syntax to apply.
			};

		Spread / Rest Operator: Convenient Syntax.
			Spread Operator: Used as a shorthand for expanding an Iterable into its constituent Items inline.
				Usage: ...<Iterable>
				
				Shallow Duplication Pattern: 
					[ ...<Array> ]

					// OR

					{ ...<Object> }

				Concatenate Pattern: 
					[ ...<Array>, item ]

					// OR

					{
						...<Object>,
						<property>: <value>
					}

				Reduce Pattern: <array>.reduce((prev, item) => ([ ...prev, item ]), <initial>);

				Conditional Object Property Pattern:
					{
						...<conditional> && { <property> : <value> }
					}
			
			Rest Parameter: Used as a shorthand to gather up variables into an Iterable.
				Usage: 
					...<Iterable>

					// OR 

					<var>, ..., ...<Iterable> // To remove Variables from the Iterable in their order.

				Function Arguments:
					( ...<arguments-iterable> ) => {
						// ...
					}
				
				Object Destructuring: See below.
			
		Destructuring Syntax: Convenient Syntax for copying a subset of Properties / Elements from an Iterable / Object.
			Iterable Destructuring:
				const [ <property>, ... ] = [ <value>, ... ];  

			Object Destructuring: Declare Variables that contain only specific Properties from the Object.
				const { <property> : <property-alias>, ..., ...<rest-object> } = <Object>;

			// Assigning a Default Value if unpacked property is not defined in <struct>
			const { <undefined-property> : <property-alias> = <default-value> } = <struct>;

		Arrow Function: A Function that has a shorter syntactic definition than a regular (Anonymous) Function.
			function () {} becomes () => {};
			function (x) { return x; } becomes x => x;
			
			(x) => { return x; }
				// LHS - Argument List
				// RHS - To Return
					// Using parenthesis in place of the RHS braces represents an implicit return statement. Should be used if there's a sole return statement in the body of the anonymous function.
					// (x) => (x) // Equivalent to the above
					// Useful for simplified syntax for React 
						const Counter = () => (
							<h1> Value </h1>
						);

			// Moreover, Arrow Functions do NOT change the 'this' context, unlike regular Javascript Functions. They inherit the meaning of 'this' as it was where the Arrow Function was created / defined.

		Function Currying: The process of breaking down a function that takes multiple arguments into a series of functions that each take only one argument.
			function add(a, b) { return a + b; }
			(x, y) => { return x + y; }
			
			vs.
			
			function add(a) { return function(b) {return a + b}; }
			(x) => (y) => { return x + y; }

			// This allows multiple different subtypes of the function to be built up before executing.
			const add3 = add(3);
			add3(4) // Returns 7.

			// Extreme Example
			(a) => (b) => ... (z) => { // ... }

		Promise: Object representing a Value which will eventually be available.
			const asyncOperation = () => (
				return new Promise(
					(resolveCb, rejectCb) => {
						// Executor Function with Asynchronous Behaviour.
						// 3 Possible States: Pending, Fulfilled, Rejected.

						// Insert Asynchronous Execution here.
						
						// Error Handling:
						if (err) return rejectCb(err);
						// OR
						throw err;
						
						resolveCb(val);
					}
				);
			)

			const promiseObj = asyncOperation();

			promiseObj.then(
				(val) => {
					// Value Handler.

					// ...

					return val; // The next 'then' in the chain is passed in val.
					// OR 
					return new Promise( // ... ); // The next 'then' waits for this returned Promise to finish executing.
				}, 
				(err) => {
					// Optional Error Handler.

					// ...

					// To prevent execution of any further 'then's.
					throw new Error( // ... );

					// To allow execution of any further 'then's.
					return '';
				}
			).then( // ... ) ... // Chainable.
			.catch(
				() => {
					// Terminal Error Handler.

					// ...
				}
			).finally(
				() => {
					// Invoked on both success (then) and failure (catch)

					// ...
				}
			);

		Async / Await Syntax:
			const asyncFunction = async () => {
				// Traditional try-catch-finally syntax works with async / await
				try { 
					// await can work on a Promise, or a synchronous Result
					var promiseResult = await promiseObj;

					// but usually on a function that returns a Promise
					var asyncResult = await asyncOperation();

					// await can also work on another async Function
					asyncResult = await asyncFunction();

					// ...

					return asyncResult;
				} catch (err) {
					// ...
				} finally {
					// ...
				}
			}

			asyncFunction();

			// when used in a synchronous context, the result of the Function is a Promise
			asyncFunction().then(
				// ...
			)

		Generator: A Function that conforms to the Iterator Specification, being able to 'return' multiple times.
			function* generator() {
				// ... 

				yield [<intermediate-value>];

				// ...

				yield [<intermediate-value>];

				// ...

				// Allow Values to be passed in via the .next() call.
				var passedIn = yield [<intermediate-value>];

				// ...
				
				// Substitute another Generator. The calling Generator is out of play until the substituted Generator runs out of yields.
				yield* <generator-instance>;

				// 'Return' Elements in an Iterable
				yield* <iterable>;

				// ...
				
				return [<final-value>];
			}

			// Create a Generator Instance
			const myGen = generator();

			// Using a Generator Instance
			var { value: myGenValue, done: isGenDone } = myGen.next(); // repeatable ; once there are no more upcoming yields, the return object will not contain the value property.
			var { value: myGenValue, done: isGenDone } = myGen.next([<optional-value>]); // Pass in a Value to the Generator for the current yield.

			// Using for-of:
				// Note: Does not execute return statements beyond the last yield.
				for (let forGen of generator) {
					const yieldedValue = forGen;
				}

		Classes:
			class className [extends parentClass] {
				// Note: If a Constructor is not defined, a default Constructor with the super() Function is used during creation.
				// Else:
				constructor(arg, ...) {
					super(arg, ...)

					//...

				}

				// ...
			}

		Symbol: Reflection Metaprogramming within Implementation - used to change the behaviour of existing Classes and Objects.
			// Primitive Data Type.

			// Creation: Do not use the 'new' keyword with the 'constructor'.
				var mySym = Symbol('<description>');

				// Creation of the Symbol in a 'global' namespace.
				var myGlobalSym = Symbol.for('<description>');

			// A Symbol's Description is primarily used for debugging purposes.
			// Two Symbols will normally not be equivalent, even if they have the same Description.
				assert.notEqual(Symbol('foo'), Symbol('foo'));

			// If the Symbols were created via Symbol.for(), then equivalence via same Description becomes possible.
				assert.equal(Symbol.for('foo'), Symbol.for('foo'));

			// To check if a Symbol was created in the 'global' namespace:
				Symbol.keyFor( myGlobalSym ) !== undefined; 

			// Object:
				// Primarily used as Object Keys, similar to String Keys:
					var myObj = {};
					myobj[mySym] = <value>;

				// Symbols are only ever visible within an Object via: 
					Object.getOwnPropertySymbols(myobj); // Returns a List of Symbols assigned to the Object.
					
				// They do not show up when the Object's Keys are iterated over, or via existing Reflection Tools.

				// Can be regarded as a special separate namespace for Object Keys.

			// Classes:
				// Useful in declaring Private Properties:
					class ExampleClass {
						// Declare the Private Variable
							[<private-variable>] = <private-value>;

						// ...

						// Reference the Private Variable
							this[<private-variable>]
					}

			// Symbols can be used to activate / change some specific behaviour for an API that takes into account Symbol-Value Mapping.

			// Well-Known Symbols:
				Symbol.hasInstance - used by instanceof
				Symbol.iterator - used by of in for ... of
				Symbol.isConcatSpreadable
				Symbol.unscopables
				
				Symbol.match - used by String.match()
				Symbol.replace - used by String.replace()
				Symbol.search - used by String.search()
				Symbol.split - used by String.split()

				Symbol.species - Points to the constructor value of Classes

		Reflect: Reflection Metaprogramming through Introspection - used to discover low level information about Code.

		Proxy: Reflection Metaprogramming through Intercession - used to wrap Objects and intercept their behaviour through traps.

		Import / Export Syntax:
			// Named Imports and Exports:
				const className = <class>;

				export {className}; // Compiles down to: module.exports.className = <class>;

				// ...

				import {className as '<alias>'} from '<module>'; // Compiles down to: const <alias> = require('<module>').className;

				// Namespace Import
				import * as '<alias>' from '<module>'; // Compiles down to: const <alias> = require('<module>');
				// <alias>.className 

			// Default Exports:
				export default className; // Make 'className' the only export of the <module>. Compiles down to: module.export = className;

				// ...

				import className as <alias> from '<module>'; // Compiles down to: const <alias> = require('<module>');

			// Tips:
				// Note: To force a plain JS File to be interpreted as a Module rather than a Script, specify an empty import or export Statement:
				export {};

				// Note: One-liner Import / Export:
				export { ... } from '<module>';

				// Note: Do not mix import and NodeJS module.export.

	Utilities:
		Mathematical Functions: 
			Math.floor();
			Math.random();
			// ... etc.
		
		Date Functions:
			Date.now(); 									// Returns the number of milliseconds since Jan 1, 1970
			setTimeout(function, <milliseconds>); 			// Executes the specified function once the specified amount of milliseconds has passed.
			var intervalHandle = setInterval(function, <milliseconds>); // Executes the specified function repeatedly after every period of the specified amount of milliseconds has passed.
			clearInterval(<intervalHandle>); 				// Stop the repeated execution of a function.
			
		Regex: 
			Local Match: /<RegEx>/
			Global Match: /<RegEx>/g
			
			/<RegEx>/.test("<string>"); 					// Test if a String contains the supplied RegExp.
	
	Document Object Model: An in-memory (mutable) tree representation of the HTML Page after it is read by the Browser.
		DOM Elements:
			var element = document.getElementsByClassName('classname'); // No need the . prefix
			var element = document.getElementById('idName'); 	// No need the # prefix
	
		DOM Properties: Initialized from the values assigned to HTML Attributes. These can mutate during runtime, unlike HTML Attributes which only dictate the starting values of these Properties.
			element.innerText; 									// references the text content between opening and closing HTML tags 
			element.innerHTML; 									// references the HTML content between opening and closing HTML tags
			element.style; 										// references the js object representing the css of the HTML element
		
		DOM Events:	
			Add Event Listener:
				element.addEventListener("<eventType>", function(event) { //... }, useCapture); // Anonymous function is Event Handling Function
					// <eventType>: http://www.w3schools.com/jsref/dom_obj_event.asp
					// event: the Object containing details about the Event that triggered the listener
						// event.stopPropagation(): use to stop parent DOM elements from also receiving the event
					// useCapture: false to specify function should fire during bubbling, true to specify the function should fire during capturing
					// element.eventType = functionID; // Legacy shortcut
			
			Remove Event Listener:
				element.removeEventListener("eventType", functionID); // Doesn't seem to be able to remove anonymous functions
				element.eventType = null; // Legacy shortcut
			
			// Note: Event Listeners return Event Objects
				eventObject.target.value
				// eventObject Properties: https://developer.mozilla.org/en-US/docs/Web/API/Event
				
	AJAX Requests: Mechanism to query a (RESTful?) endpoint to dynamically update webpages.
		const httpRequest = new XMLHttpRequest(); // Create a new AJAX Request
		
		httpRequest.open("{GET | POST | PUT | DELETE}", "<relative-url>"); // Specify HTTP Request Type and Target
		
		httpRequest.onload = function() { // Add Event Listeners 
			// ... 
		};
		
		httpRequest.send(null); // Actually fire off the AJAX Request

