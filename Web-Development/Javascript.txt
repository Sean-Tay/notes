Javascript
	Scopes:
		const 												- block {} scope, unchangeable once declared, not redeclarable
		let 												- block {} scope, changeable once declared, not redeclarable
		var 												- global scope, changeable once declared, redeclarable

	Basic Javascript Expression Manipulation: 
		Raw Data Types: 
			var myString = "Test";
				var myTemplateString = `Testing: ${dynamicValue}` // Can also be Multi-line
			var myNumber = 23;
			var myBoolean = true;
			var myFunction = () => {};

		console.log("Something to Print"); 					// Prints to Console

		Comments // /* */

		if (condition1) {

		} else if (condition2) {

		} else {

		}

		switch (variable) {
		  case 'value1':
			 // ...
			 break;
		  case 'value2':
			 // ...
			 break;
		  default:
			 // ...
			 break;
		}
		
		for (var index = 0; index < 5; index++) {
			// ...
		}

		To check if two things are equal to each other (with automatic type conversion): ==
		To check if two things are unequal to each other (even with automatic type conversion): !=
		To check if two things are equal to each other (with the same type): ===
		To check if two things are unequal to each other (with different types): !==
		
	Functions:
		function functionName(inputArgument1) { 			// Parameters should not have the var keyword
			// ...
		}

		function() { 										// Anonymous Function
		}

		function functionCallback( ... , callback) { 		// A callback parameter is to allow the execution (or multiple executions) of a specified function anytime during the parent function's execution
			// ...
			callback();
		}
		
		function classConstructor( ... ) {
			this.property = ...;
		}

		functionName(); 									// Invoke the functionName function
		
		// Note: Functions are actually Objects!
	
	Iterables:
		var listName = [listElement, ... ]; 				// Arrays
		
		listName.map(function(listElement, listElementIndexOptional, listElementArrayRefOptional) { // Do something to each listElementType  }); // Map Function
		listName.filter((listElement) => { // Return true to keep listElement in returned Array, false to exclude listElement from returned Array })
		listName.sort(); 									// Sort the contents in listName	

	Objects:
		var objectName = { key:value, key:value, key:this.key }; // Objects with Properties or Dictionaries
		objectName.key == value;
		objectName['key'] == value;
		
		Object.assign(<targetObject>, object1, object2, ...);
			// Mutates targetObject with the content stored in object1, object2, etc...
			// If more than one object has different values for the same key, only the latest object (i.e. object2) will have its changes pushed.
		
		JSON.stringify(objectName); 						// Encode object as a JSON

	// Static Properties
		// Allows the addition of Properties and Methods to the Object Type specifically.
		// These cannot be accessed by instances of the Object Type.

		myObj.staticProperty = <value>;

		OR

		class myClass {
			
			// ...

			// Via the static keyword (ES6)
			static staticProperty = <value>;

			// ...

		}
	
	// Prototype Properties
		// Allows the addition of Properties and Methods to all instances of an Object Type.
		// Also allows the extension of Parent Types to add aforementioned Properties and Methods to Child Types.
			// Avoid doing so if the use-case makes more sense as an Interface Implementation (has-a vs is-a).
		
	// this refers to the current scope's owner - can be a Class or a Function
		.bind(this) // Search up on this
	
	> ES6:
		Spread Operator: Convenient Syntax 
			Iterator Spreading: 
				// ...<Iterable> - Literally spreads out the Iterable's Item, as if declaring them sequentially
				
				// [...<Iterable>, item] - Shorthand for concatenating an Item to an Array
				
			Object Duplication:
				// { ...<Object> }
			
		Destructuring Syntax: Convenient Syntax for copying a subset of Properties / Elements from an Iterable / Object.
			Iterable Destructuring:
				const [ <property>, ... ] = [ <value>, ... ];  

			Object Destructuring:
				const { <property> : <property-alias>, ... , ...<rest-object> } = <object>;

			// Assigning a Default Value if unpacked property is not defined in <struct>
			const { <undefined-property> : <property-alias> = <default-value> } = <struct>;

		Arrow Functions: A function that has a syntactic definition that is shorter than a regular anonymous function.
			function () {} becomes () => {};
			function (x) { return x; } becomes x => x;
			
			(x) => { return x; }
				// LHS - Argument List
				// RHS - To Return
					// Using parenthesis in place of the RHS braces represents an implicit return statement. Should be used if there's a sole return statement in the body of the anonymous function.
					// (x) => (x) // Equivalent to the above
					// Useful for simplified syntax for React 
						const Counter = () => (
							<h1> Value </h1>
						);

		Function Currying: The process of breaking down a function that takes multiple arguments into a series of functions that each take only one argument.
			function add(a, b) { return a + b; }
			(x, y) => { return x + y; }
			
			vs.
			
			function add(a) { return function(b) {return a + b}; }
			(x) => (y) => { return x + y; }

			// This allows multiple different subtypes of the function to be built up before executing.
			const add3 = add(3);
			add3(4) // Returns 7.

		Promise: Object representing a Value which will eventually be available.
			const asyncOperation = () => (
				return new Promise(
					(resolveCb, rejectCb) => {
						// Executor Function with Asynchronous Behaviour.
						// 3 Possible States: Pending, Fulfilled, Rejected.

						// Insert Asynchronous Execution here.
						
						if (err) rejectCb(err);
						else resolveCb(val);
					}
				);
			)

			const promiseObj = asyncOperation();

			promiseObj.then(
				() => {
					// Value Handler

					// ...

					return val; // The next 'then' in the chain is passed in val.
					// OR 
					return new Promise( // ... ); // The next 'then' waits for this returned Promise to finish executing.
				}, 
				() => {
					// Optional Error Handler.

					// ...
				}
			).then( // ... ) ... // Chainable Resolution.

		Async / Await Syntax:
			const asyncFunction = async () => {
				// Traditional try-catch syntax works with async / await
				try { 
					// await can work on both a Promise, or a synchronous Result
					var promiseResult = await promiseObj;

					// but usually on a function that returns a Promise
					var asyncResult = await asyncOperation();

					// ...
				} catch (err) {
					// ...
				}
			}

			asyncFunction();

		Classes:
			class className [extends parentClass] {
				// Note: If a Constructor is not defined, a default Constructor with the super() Function is used during creation.
				// Else:
				constructor(arg, ...) {
					super(arg, ...)

					//...

				}

				// ...
			}

		Symbol: Reflection Metaprogramming within Implementation - used to change the behaviour of existing Classes and Objects.
			// Primitive Data Type.

			// Creation: Do not use the 'new' keyword with the 'constructor'.
				var mySym = Symbol('<description>');

				// Creation of the Symbol in a 'global' namespace.
				var myGlobalSym = Symbol.for('<description>');

			// A Symbol's Description is primarily used for debugging purposes.
			// Two Symbols will normally not be equivalent, even if they have the same Description.
				assert.notEqual(Symbol('foo'), Symbol('foo'));

			// If the Symbols were created via Symbol.for(), then equivalence via same Description becomes possible.
				assert.equal(Symbol.for('foo'), Symbol.for('foo'));

			// To check if a Symbol was created in the 'global' namespace:
				Symbol.keyFor( myGlobalSym ) !== undefined; 

			// Primarily used as Object Keys, similar to String Keys:
				var myObj = {};
				myobj[mySym] = <value>;

			// Symbols are only ever visible within an Object via: 
				Object.getOwnPropertySymbols(myobj); // Returns a List of Symbols assigned to the Object.
				
			// They do not show up when the Object's Keys are iterated over, or via existing Reflection Tools.

			// Can be regarded as a special separate namespace for Object Keys.

		Reflect: Reflection Metaprogramming through Introspection - used to discover low level information about Code.

		Proxy: Reflection Metaprogramming through Intercession - used to wrap Objects and intercept their behaviour through traps.

		Import / Export Syntax:
			import Module from 'npm-module';

			export default className; // Make 'className' the only export of the JS File.
			import className from './JS-File';

			export const className = className; // Set 'className' to be an export of the JS File.
			import {className as 'alias'} from './JS-File'; // Named Imports

			// Note: To force a plain File to be interpreted as a Module rather than a Script, specify an empty import or export Statement:
			export {};

	Utilities:
		Mathematical Functions: 
			Math.floor();
			Math.random();
			// ... etc.
		
		Date Functions:
			Date.now(); 									// Returns the number of milliseconds since Jan 1, 1970
			setTimeout(function, <milliseconds>); 			// Executes the specified function once the specified amount of milliseconds has passed.
			var intervalHandle = setInterval(function, <milliseconds>); // Executes the specified function repeatedly after every period of the specified amount of milliseconds has passed.
			clearInterval(<intervalHandle>); 				// Stop the repeated execution of a function.
			
		Regex: 
			Local Match: /<RegEx>/
			Global Match: /<RegEx>/g
			
			/<RegEx>/.test("<string>"); 					// Test if a String contains the supplied RegExp.
	
	Document Object Model: An in-memory (mutable) tree representation of the HTML Page after it is read by the Browser.
		DOM Elements:
			var element = document.getElementsByClassName('classname'); // No need the . prefix
			var element = document.getElementById('idName'); 	// No need the # prefix
	
		DOM Properties: Initialized from the values assigned to HTML Attributes. These can mutate during runtime, unlike HTML Attributes which only dictate the starting values of these Properties.
			element.innerText; 									// references the text content between opening and closing HTML tags 
			element.innerHTML; 									// references the HTML content between opening and closing HTML tags
			element.style; 										// references the js object representing the css of the HTML element
		
		DOM Events:	
			Add Event Listener:
				element.addEventListener("<eventType>", function(event) { //... }, useCapture); // Anonymous function is Event Handling Function
					// <eventType>: http://www.w3schools.com/jsref/dom_obj_event.asp
					// event: the Object containing details about the Event that triggered the listener
						// event.stopPropagation(): use to stop parent DOM elements from also receiving the event
					// useCapture: false to specify function should fire during bubbling, true to specify the function should fire during capturing
					// element.eventType = functionID; // Legacy shortcut
			
			Remove Event Listener:
				element.removeEventListener("eventType", functionID); // Doesn't seem to be able to remove anonymous functions
				element.eventType = null; // Legacy shortcut
			
			// Note: Event Listeners return Event Objects
				eventObject.target.value
				// eventObject Properties: https://developer.mozilla.org/en-US/docs/Web/API/Event
				
	AJAX Requests: Mechanism to query a (RESTful?) endpoint to dynamically update webpages.
		const httpRequest = new XMLHttpRequest(); // Create a new AJAX Request
		
		httpRequest.open("{GET | POST | PUT | DELETE}", "<relative-url>"); // Specify HTTP Request Type and Target
		
		httpRequest.onload = function() { // Add Event Listeners 
			// ... 
		};
		
		httpRequest.send(null); // Actually fire off the AJAX Request

