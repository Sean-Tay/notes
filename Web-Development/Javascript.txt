Javascript
	Hoisting:												Javascript Interpretation would store Variable and Function Declarations (NOT Initializations) in Memory first, before any Execution begins.
		This is how Variables and Functions can be used within Code before they have been Defined.
	
	Scopes:
		const 												block {} scope, unchangeable once declared, not redeclarable
		let 												block {} scope, changeable once declared, not redeclarable
		var 												global scope, changeable once declared, redeclarable

	Primitives:
		boolean:											Literal true / false.
		number:												Literal Integers, Floats / Doubles, Infinity, NaN.
			// Base Initialization:
				let bNumber = 0b1000; // Binary
				let oNumber = 0o7200; // Octal
				let hNumber = 0xA000; // Hexadecimal

			// Numeric Separators: For easier comprehension within Code:
				let cNumber = 1_000;
				let cdNumber = 1_000.50;
				let dNumber = 1.000_005;

				let bNumber = 0b1010_0110;

			// To represent Integers of arbitrary magnitude:
				let bigint = <number>n;								
		
		string

		Symbols
		null
		undefined

	Common Syntax:
		Basic Javascript Expression Manipulation: 
			Raw Data Types: 
				var myString = "Test";
					var myTemplateString = `Testing: ${dynamicValue}`; // Can also be Multi-line
				var myNumber = 23;
				var myBoolean = true;
				var myFunction = () => {};

			console.log("Something to Print"); 					// Prints Output.
			console.table(<collection>);						// Prints Tabular Output for Arrays or Objects.
			console.trace();									// Prints out current Stack Trace for where this was Executed at.

			Comments // /* */

			if (condition1) {
				// ...
			} else if (condition2) {
				// ...
			} else {
				// ...
			}

			switch (variable) {
				case 'value1': 
					// ...
					break;
				// ...
				case 'valueN-1':
				case 'valueN': 
					// ...
					break;
				default: 
					// ...
					break;
			}
			
			for (var index = 0; index < 5; index++) {
				// ...
			}

			Abstract Equality Operator:
				To check if two things are equal to each other (same values check only): ==
				To check if two things are unequal to each other (different values check only): !=

				// Tip: arg == null returns true for both null and undefined

			Strict Equality Operator:
				To check if two things are equal to each other (same values and types check): ===
				To check if two things are unequal to each other (different values and types check): !==

			// Note: Objects, Arrays and Functions are never equal to each other, unless the equality check is done through the same reference:
			const ref = {};
			console.log( ref === ref ); // true
			console.log( ref === {} ); // false

		Iterables:
			var arr = [ element1, ... ];
			
			var newArr = arr.map(
				function ( element, index, arrRef ) {
					// Return something based on each Element.
				}
			);

			var filteredArr = arr.filter(
				function( element, index, arrRef ) {
					// Return true to keep the Element in the returned Array, false to exclude the Element from the returned Array.
				}
			);

			var result = arr.reduce(
				function( prev, element, index, arrRef ) {
					// Return some combinate value of prev and element, traversing through the Array from Left to Right.
				}, 
				<optional-accumulator-initial-value>
			);

			var sortedArr = arr.sort( // Sort the contents in the Array according to the Sorting Function passed in.
				function( elementA, elementB ) { 
					// Return relative value of elementA to elementB:
					// 	-1 	=> elementA will be placed before elementB.
					// 	0 	=> elementA and elementB's relative ordering will be maintained.
					// 	1	=> elementB will be placed before elementA.
				}

				// Tip: Use Intl.Collator to easily perform a Language-Sensitive String Sort.
				// new Intl.Collator('<locale>').compare
			);

			var slicedArr = arr.slice(<start-index>, [<end-index>]); // Returns a Shallow Copy of the Array from the <start-index> inclusive to the <end-index> exclusive.

			var deletedArr = arr.splice(<start-index>, <count>, <item-1>, ... ); // Can be used to Insert or Remove a Portion from an Array, starting at <start-index>.

			var isSomeCondition = arr.some(
				// Returns a boolean representing if any Elements in the Array satisfy the condition in the given Function.
				// Note: If the Array is Empty, this always returns false.
				function(element) {
					// return true if the Element fulfills a condition, false otherwise.
				}
			);

			var isEveryCondition = arr.every(
				// Returns a boolean representing if all Elements in the Array satisfy the condition in the given Function.
				// Note: If the Array is Empty, this always returns true.
				function(element) {
					// return true if the Element fulfills a condition, false otherwise.
				}
			);

			// Iteration
			for (const item of arr) {
				// ...
			}

			// Note: Javascript features Associative Arrays, which silently allows out-of-bounds index access (returns undefined).

		Objects: Key-Value Mappings.
			var objectName = { 
				key:value, 
				key:value, 
				key:this.key 
			};

			// Setting Keys and Values.
			objectName.key = value; // Set the literal string 'key' as the property that will hold the value.
			objectName[key] = value; // Set the value of the variable key as the property that will hold the value.
			
			Object.assign(<targetObject>, object1, object2, ...);
				// Mutates targetObject with the content stored in object1, object2, etc...
				// If more than one object has different values for the same key, only the latest object (i.e. object2) will have its changes pushed.
			
			Object.keys(<targetObject>); // Obtain Array of keys defined in <targetObject>.
			Object.values(<targetObject>); // Obtain Array of values within <targetObject>.

			JSON.stringify(objectName); // Encode object as a JSON

			// Iteration
			for (const key in objectName) {
				// Note: Will also iterate over Keys that the Object inherits from its Constructor's Prototype.
				// ...
			}

			for (const key of Object.keys(objectName)) {
				// ...
			}

		Functions:
			function functionName(
				arg,
				// ...
			) {
				// Call-by-Sharing
				// if arg is set to a new value, it will only take effect within the scope of the function
				// if arg's properties are set to a new value, it will affect the original supplied argument to the function

				// ...
			}

			// Anonymous Function
			function(
				arg, 
				// ...
			) {
				// ...
			}

			// Default Arguments
			const functionName = function(
				arg = <default-value>, 
				// ...
			) {
				// ...
			};

			// 'Class' Constructor.
			function classConstructor( ... ) {
				this.property = ...;
			}

			functionName();

			// Patterns:
				// An Object should be used instead of a Parameter List to avoid breaking changes when a new Paramenter is added.
				function functionName(params = {}) {
					if (params.arg !== undefined) {
						// ...
					}

					// ...
				}

				// A Callback Function can be provided in the Function's Parameters to allow other execution to take place in the event something significant happens during the execution of this Function.
				function functionCallback(params = {}) {
					// ...
					params.callback !== undefined && params.callback();
				}
			
			// Note: Functions are actually Objects!

		Static Properties
			// Allows the addition of Properties and Methods to the Object Type specifically.
			// These cannot be accessed by instances of the Object Type.

			myObj.staticProperty = <value>;

			OR

			class myClass {
				
				// ...

				// Via the static keyword (ES6)
				static staticProperty = <value>;

				// ...

			}
		
		// this refers to different things, depending on how the Context was established:
			// In Ascending Priority:
				// this refers to the global Object, or undefined if 'use strict' was enabled.
				// this refers to the Object if it is used within an Object's Method.
				// <function>.bind(this); // To make any usage of 'this' refer to the containing scope's definition of 'this' where the statement was invoked.
				// this (within a Function) by default refers to the Object being created if the new keyword was used.
			
			// If this is used within an Arrow Function, it will refer to the meaning of this in the containing scope where the Arrow Function was created.

		Prototype Properties
			// Prototype: The mechanism by which Javascript Objects inherit Features off each other.
				// Each Object has a __proto__ Property that references a "template" Object which contains Properties and Methods the Object will inherit from.
					// Instanced Objects have their __proto__ Property set when instantiated by a Constructor, via the Constructor's prototype Property.
						// Tip: The __proto__ Property is for the Prototype Chain, whereas the prototype Property is for defining which Properties are inheritable.
							// The Constructor has its own __proto__ Property, but this is different:
								// The Constructor's __proto__ Property points to the Function prototype Property. The Function __proto__ Property references it's own Function prototype Property. 
									// This makes sense because the Constructor is created with the Root Function.

							// The Constructor's prototype.__proto__ Property continues the Prototype Chain for the Instanced Object.

						// Constructor Function:
							function <class-name>(<arg>, ...) {
								this.<instance-property> =  <value>;

								// ...
							}

						// Constructor Invocation:
							let <new-object-instance> = new <class-name>();

							// Access the Constructor Function used to create the Object Instance
							<new-object-instance>.constructor

						// Tip: One can inject additional Properties via a Constructor's prototype during Runtime, which allows for ALL Instanced Objects to immediately be able to access the Properties.
							// If an Instanced Object tries to change the value of the Property, it will only affect itself (and other downstream Objects?). Further changes to the Property Value via the Constructor prototype will also no longer affect it.

							// <class-name>.prototype.<new-property> = // ... ;

			// Prototype Chain: Chain of Inheritance for Javascript Objects.
				// Properties for Objects are discovered / accessed by walking up the Prototype Chain.
					// Note: Chain is through the __proto__ Property of Javascript Objects / Constructors.
						// <new-object-instance>.__proto__ === <class-name>.prototype
						// <new-object-instance>.__proto__.__proto__ === <class-name>.prototype.__proto

				// Note: Modifying an Object's Properties does NOT involve the Prototype Chain.

				// Root Object: Prototype is null.

		Error Handling:
			try {
				// Execute something here which may throw an Error.

				var result = someFunction();

				if (!result) {
					throw new Error('Invalid Result');
				}

				return result;
			} catch (err) {
				// Catch any Errors thrown within the try block, and execute Error-Handling functionality.

				if (err === 'Invalid Result') {
					// ...
				}

				return;
			} finally {
				// Always executes, even if there is a prior return statement.
				// Tip: Use to combine common tail-functionality in the try and catch blocks.

				// ...
			}
	
	> ES6:
		String:
			let repeatedString = <str>.repeat(<numTimes>); // repeatedString === <str><str> ... <str>

		Switch Case:
			switch (variable) {
				case 'value1': {
					// ...
					break;
				}
				// ...
				case 'valueN-1':
				case 'valueN': {
					// ...
					break;
				}
				default: {
					// ...
					break;
				}
			}

		Computed Object Property Name: Evaluate an expression to determine the Property Name of a Value assigned to an Object.
			const example = {
				[<js-expression>]: <value>, // Note the Square Braces as the Syntax to apply.
			};

		Spread / Rest Operator: Convenient Syntax.
			Spread Operator: Used as a shorthand for expanding an Iterable / Object into its constituent Items inline.
				Usage: ...<Item>
				
				Shallow Duplication Pattern: 
					[ ...<Array> ]

					// OR

					{ ...<Object> }

				Concatenate Pattern: 
					[ ...<Array>, item ]

					// OR

					{
						...<Object>,
						<property>: <value>
					}
				
				// Avoid this, as this re-creates the Iterable per loop.
				// For the best performance, use for ... of, and mutate the Accumulator Iterable instead.
				Reduce Anti-Patterns:
					<array>.reduce((prev, item) => ([ ...prev, item ]), <initial-arr>);
					<array>.reduce((prev, item) => ({ ...prev, item }), <initial-obj>));

				Conditional Object Property Pattern:
					{
						...<conditional> && { <property> : <value> }
					}
			
			Rest Parameter: Used as a shorthand to gather up variables into an Iterable / Object.
				Usage: 
					...<Item>

					// OR 

					<var>, ..., ...<Item> // To remove Variables from the Iterable in their order.

				Function Arguments:
					( ...<arguments-iterable> ) => {
						// ...
					}
				
				Object Destructuring: See below.
			
		Destructuring Syntax: Convenient Syntax for copying a subset of Properties / Elements from an Iterable / Object.
			Iterable Destructuring:
				const [ <property>, ... ] = [ <value>, ... ];  

			Object Destructuring: Declare Variables that contain only specific Properties from the Object.
				const { <property> : <property-alias>, ..., ...<rest-object> } = <Object>;

			// Assigning a Default Value if unpacked property is not defined in <struct>
			const { <undefined-property> : <property-alias> = <default-value> } = <struct>;

		Optional Chaining Syntax: Convenient Syntax to safely access Properties of an Object.
			const example = {
				<key>: {
					<deep-key>: <value>
				},
				<key>: <value>,
				// ...
			};

			// const value = example && example.<key> && example.<key>.<deep-key>; // false
			const value = example?.<key>?.<deep-key>;

			// If at any point the chain access fails, the statement will short-circuit into one with an 'undefined' fallback value.
			const undefinedValue = example?.<non-existant-key>?.<deep-key>;

			// Optional Function Invocation
			<function>?.( <args> );

		Nullish Coalescing Syntax: A Logical Operator that returns the value on its right-han side, when the value on the left-hand side is null or undefined.
			// const fallback = null || <fallback>; // Will assign <fallback> if left value is falsy (i.e. false, 0 , '').
			const fallback = null ?? <fallback>; // Will assign <fallback> if left value is null or undefined.

		Arrow Function: A Function that has a shorter syntactic definition than a regular (Anonymous) Function.
			function () {} becomes () => {};
			function (x) { return x; } becomes x => x;
			
			(x) => { return x; }
				// LHS - Argument List
				// RHS - To Return
					// Using parenthesis in place of the RHS braces represents an implicit return statement. Should be used if there's a sole return statement in the body of the anonymous function.
					// (x) => (x) // Equivalent to the above
					// Useful for simplified syntax for React 
						const Counter = () => (
							<h1> Value </h1>
						);

			// Moreover, Arrow Functions do NOT change the 'this' context, unlike regular Javascript Functions. They inherit the meaning of 'this' as it was where the Arrow Function was created / defined.

		Function Currying: The process of breaking down a function that takes multiple arguments into a series of functions that each take only one argument.
			function add(a, b) { return a + b; }
			(x, y) => { return x + y; }
			
			vs.
			
			function add(a) { return function(b) {return a + b}; }
			(x) => (y) => { return x + y; }

			// This allows multiple different subtypes of the function to be built up before executing.
			const add3 = add(3);
			add3(4) // Returns 7.

			// Extreme Example
			(a) => (b) => ... (z) => { // ... }

		Sets: Data Structure that can quickly check whether or not an Element (of any Type) has been stored within.
			// Operations are sub-linear O(log(n)) or O(1) Time Complexity.
			// Uses Value Equality Checking.
			// The JS Data Structure implementation retains Insertion Order as an added feature, unlike the Sets in Math or other Languages.

			const mySet = new Set([ <element-1>, ... , <element-n> ]);

			mySet.size // Property, not Method.

			mySet.add(<new-element>);
			mySet.has(<new-element>); // true
			mySet.delete(<new-element>);

			// Space-Efficient Insertion Ordered Iteration:
			for (let element of mySet) {
				// ...
			}

			const myArray = Array.from(mySet); // Conversion back from Set to Array.

			// WeakSet - Alternative to Set that:
				// 1. Only stores Object References.
				// 2. Object References inserted here are not considered during Garbage Collection (no need to remove the Weak Object References stored here manually).
				// 3. Cannot be iterated over (Insertion Order is not kept for performance considerations).
		
		Maps: Data Structure that can quickly store and retrieve Key-Element pairs.
			// Operations are sub-linear O(log(n)) or O(1) Time Complexity.
			// Retains Insertion Order, unlike regular JS Objects.
			// Performs better in scenarios involving frequent Addition / Removal of Key-Element pairs, as compared to regular JS Objects.
				// Note: Objects are better if the keys are of the string type, and it is mainly a Write-Once Read-Heavy Workload.

			const myMap = new Map([
				[ <element-key-1>, <element-1> ],
				...
				[ <element-key-n>, <element-n> ]
			]);

			myMap.size // Property, not Method.

			myMap.set(<new-element-key>, <new-element>);
			myMap.has(<new-element-key>); // true
			myMap.get(<new-element-key>); // undefined | <new-element>
			myMap.delete(<new-element-key>);

			// Space-Efficient Insertion Ordered Iteration:
			for (let [ elementKey, element ] of myMap) {
				// ...
			}

			const myArray = Array.from(myMap); // Conversion back from Map to Array.

			// WeakMap - Alternative to Map that:
				// 1. Only stores Object References as its Keys.
				// 2. Keys here are not considered during Garbage Collection (no need to remove the Weak Object References stored here manually).
				// 3. Cannot be iterated over.
		
		Promise: Object representing a Value which will eventually be available.
			const asyncOperation = () => (
				return new Promise(
					(resolveCb, rejectCb) => {
						// Executor Function with Asynchronous Behaviour.
						// 3 Possible States: Pending, Fulfilled, Rejected.

						// Insert Asynchronous Execution here.
						
						// Error Handling:
						if (err) return rejectCb(err);
						// OR
						throw err;
						
						resolveCb(val);
					}
				);
			)

			const promiseObj = asyncOperation();

			promiseObj.then(
				(val) => {
					// Value Handler.

					// ...

					return val; // The next 'then' in the chain is passed in val.
					// OR 
					return new Promise( // ... ); // The next 'then' waits for this returned Promise to finish executing.
				}, 
				(err) => {
					// Optional Error Handler.

					// ...

					// To prevent execution of any further 'then's.
					throw new Error( // ... );

					// To allow execution of any further 'then's.
					return '';
				}
			).then( // ... ) ... // Chainable.
			.catch(
				() => {
					// Terminal Error Handler.

					// ...
				}
			).finally(
				() => {
					// Invoked on both success (then) and failure (catch)

					// ...
				}
			);

			// Notes:
				// The Asynchronous Executor Function is triggered by the Promise Constructor before it returns the Promise Object.
				// Declaration of the Error Handler or Catch Block can be deferred (within Synchronous Code).

			// Promise Utility Functions:
				// Wait until all supplied Promises have resolved successfully. If even one of them rejects, Promise.all will defer execution to the Error Handler.
					Promise.all([
						<promise>,
						// ...
					]).then(
						resultsArr => {
							// ...
						}
					);

				// Wait until all supplied Promises have either resolved or rejected.
					Promise.allSettled([
						<promise>,
						// ...
					]).then(
						resultsArr => resultsArr.map(
							result => {
								// Each item is either a ResolvedPromise, or a Rejected Promise.
								// Resolved Promise: { status: 'fulfilled', value: <value> }
								// Rejeced Promise: { status: 'rejected', reason: <error> }

								// ...

								return result.value;
							}
						)
					);

				// Generate Dummy Promises:
					Promise.resolve();
					Promise.reject();

			// Nested Promises:
				Promise.all([
					// ...
					Promise.all([
						// ...
					])
					// ...
				]).then(
					() => {
						// ...
					}
				);

		Async / Await Syntax:
			const asyncFunction = async () => {
				// Traditional try-catch-finally syntax works with async / await
				try {
					// Note: (Conncurrent) Execution only defers to another Task upon encountering an await Statement.

					// await can work on a Promise, or a synchronous Result
					var promiseResult = await promiseObj;

					// but usually on a function that returns a Promise
					var asyncResult = await asyncOperation();

					// await can also work on another async Function
					asyncResult = await asyncFunction();

					// ...

					return asyncResult;
				} catch (err) {
					// ...
				} finally {
					// ...
				}
			}

			asyncFunction();

			// when used in a synchronous context, the result of the Function is a Promise
			asyncFunction().then(
				// ...
			)

		Generator: A Function that conforms to the Iterator Specification, being able to 'return' multiple times.
			function* generator() {
				// ... 

				yield [<intermediate-value>];

				// ...

				yield [<intermediate-value>];

				// ...

				// Allow Values to be passed in via the .next() call.
				var passedIn = yield [<intermediate-value>];

				// ...
				
				// Substitute another Generator. The calling Generator is out of play until the substituted Generator runs out of yields.
				yield* <generator-instance>;

				// 'Return' Elements in an Iterable
				yield* <iterable>;

				// ...
				
				return [<final-value>];
			}

			// Create a Generator Instance
			const myGen = generator();

			// Using a Generator Instance
			var { value: myGenValue, done: isGenDone } = myGen.next(); // repeatable ; once there are no more upcoming yields, the return object will not contain the value property.
			var { value: myGenValue, done: isGenDone } = myGen.next([<optional-value>]); // Pass in a Value to the Generator for the current yield.

			// Using for-of:
				// Note: Does not execute return statements beyond the last yield.
				for (let forGen of generator) {
					const yieldedValue = forGen;
				}

		Classes:
			// Class Statement:
			class <class-name> [extends <parent-class>] {
				static <static-property>;

				#<hard-private-property>; // Not detectable at all outside the Class during Compile Time or Run Time. Usable in native JS.
				<public-property>;
				
				// Note: If a Constructor is not defined, a default Constructor with the super() Function is used during creation.
				// Else:
				constructor(params) {
					super(params)

					//...

					<class-name>.<static-property> = <value>;

					this.<public-property> = <value>;
					this.#<hard-private-property> = <value>;
				}

				// A Class Definition defines Prototype Methods.
				<method>(params) {
					// Note: super cannot be used to access Static Parent Variables. Use a Parent get Method to access those.
					// Tip: Use a specific Function for getting those Static Parent Variables, so as to not mislead others into thinking ALL Static Parent Variables are accessible via the 'super' keyword.
					super.<parent-method>(params);

					// ...
				}

				// Spy Methods for Properties:
				get <property>() {
					// ...

					return this.<property>;
				}

				set <property>(<val>) {
					// ...

					this.<property> = <val>;
				}

				// ...
			}

			// Class Expressions
			// Tip: Can be used to provide 'instanced' Static Variables:
			const <class-generator> = (<arg>) => 
				// Note: The <class-name> only applies to the scope of the Class Definition.
				class <class-name> {
					static <property> = <arg>;
					
					// ...
				}

			// Mixin Pattern
			const <mixin-name> = (<class-name>) => 
				class <extended-class-name> extends <class-name> {
					// ...
				}

		Decorators: Functions called on JavaScript Syntax Forms (i.e. Public, Private or Static Class Mechanisms such as Class Fields, Accessors and Methods).
			/*
				Acts on:
					1. Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each Class Instance Member.
					2. Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each Static Member.
					3. Parameter Decorators are applied for the Class Constructor.
					4. Class Decorators are applied for the Class.

				Capabilities:
					1. Ability to replace the Value being decorated with another Value with the same Semantics / Type.
					2. Ability to associate Metadata with the Value being decorated.
			*/
			
			// Class Level Decorators:
				@<class-decorator>(<arg>, ... )
				class <class-name> {
					// ...
				}

				function <class-decorator>(<arg>, ... ) {
					return function decorator(target) {
						target.<metadata-property> = <arg>;

						// ...
					}
				}

			// Class Method Level Decorators:
				class <class-name> {
					@<method-decorator>(<arg>, ...)
					method() {
						// ...
					}

					method(@<method-argument-decorator> <arg>, ... ) {
						// ...
					}
				}

				function <method-decorator>(<arg>, ...) {
					return function decorator(target, key, descriptor) {
						// ...
					}
				}

		Symbols:
			// Primitive Data Type.

			// Creation: 
				// Tip: Do not use the 'new' keyword with the 'constructor'.
				// Tip: '<description>' is primarily used for debugging.
				var mySym = Symbol('<description>');

				console.log(mySym.toString()); // '<description>'

				// Creation of the Symbol in a 'global' namespace.
				var myGlobalSym = Symbol.for('<description>');
					// To check if a Symbol was created in the 'global' namespace:
					Symbol.keyFor( myGlobalSym ) !== undefined; 

			// Equivalence:
				// Two Symbols will normally not be equivalent, even if they have the same Description.
					assert.notEqual(Symbol('foo'), Symbol('foo'));

				// If the Symbols were created via Symbol.for(), then equivalence via same Description becomes possible.
					assert.equal(Symbol.for('foo'), Symbol.for('foo'));

			// Usage:
				// Enforce Uniqueness / Strict String Enums:
					const <strict-enum> = Symbol('<value>');

					// ...

					// Example:
					const <function> = (input) => {
						if (input !== <strict-enum>) {
							throw new Error();
						}
					}

					// Will throw Error:
					<function>('<value>');
					<function>(Symbol('<value>'));

				// Object:
					// Ensures unique Object Keys, similar to String Keys:
						var myObj = {};
						myobj[<key-symbol>] = <value>;

					// Symbols are only ever visible within an Object via: 
						Object.getOwnPropertySymbols(myobj); // Returns a List of Symbols assigned to the Object.
						
					// They do not show up when the Object's Keys are iterated over, or via existing Reflection Tools.

					// Can be regarded as a special separate namespace for Object Keys.

				// Classes:
					// Useful in declaring Private Properties:
						class ExampleClass {
							// Declare the Private Variable
								[<private-symbol>] = <private-value>;

							// ...

							// Reference the Private Variable
								this[<private-symbol>]
						}

				// Symbols can be used to activate / change some specific behaviour for an API that takes into account Symbol-Value Mapping.
					// Examples:
						Symbol.hasInstance - used by instanceof
						Symbol.iterator - used by of in for ... of
						Symbol.isConcatSpreadable
						Symbol.unscopables
						
						Symbol.match - used by String.match()
						Symbol.replace - used by String.replace()
						Symbol.search - used by String.search()
						Symbol.split - used by String.split()

						Symbol.species - Points to the constructor value of Classes

		Reflect: Reflection Metaprogramming through Introspection - used to discover low level information about Code.

		Proxy: Reflection Metaprogramming through Intercession - used to wrap Objects and intercept their behaviour through traps.

		Import / Export Syntax:
			// Import
				// Synchronous
					import <item> from '<module>';
					import <item> from '<{ absolute | relative}-module-path>';
					import <item> from '<module-url>'; // CORS check enabled.

					import <item> as <renamed-item> from '<module-source>';

					import * as <all-module-item-object> from '<module-source>';

				// Asynchronous / Dynamic Module Loading:
					// Promises
						import('<module-source>').then(
							(<item>) => {
								// ...
							}
						);

					// Fetch API:
						// Tip: Only suitable in Browsers?
						const <item> = fetch('<module-source>');

			// Export
				// Synchronous
					export const <item> = <value>;

					// OR

					export <item>;

				// Asynchronous (Imported <item>s via Fetch API)
					// Specify that all Modules importing this Module will have to wait until <item> has loaded.
					export default await <item>;

			// Default Export
				export default <item>;

			// Tips:
				// To force a plain JS File to be interpreted as a Module rather than a Script, specify an empty import or export Statement:
				export {};

				// One-liner Import / Export for Aggregating Modules:
				export * [as '<export-name>'] from '<module>';

				export { ... } from '<module>';
					export { <module-item> [as <export-name>], ... } from '<module>';
					export { default [as <export-name>] } from '<module>';

	Utilities:
		JSDoc Annotations: /** ... */
			@internal			- Denotes that the following piece of Code is meant for internal use only.

			@alpha				- Denotes that the following piece of Code is intended to eventually be released, but is not ready for public consumption yet.
			@beta				- Denotes that the following piece of Code is unstable.
			@public				- Denotes that the following piece of Code is stable enough for external consumption.
			@deprecated			- Denotes that the following piece of Code is to be removed in the future. Generates warnings in external consumers that use these.

			@param {<type>} <param-name> <description> - Provides explanation for the params received by a Function.
			@param {Object} <object-param-name> <description> - Specify an Object-type Paramenter.
			@param {<type>} <object-param-name>.<field-name> <description> - Specify a Field within an Object-type Parameter.

			@typedef {<type>} <type-name> <description> - Define a Custom Type that can be used in other JSDoc Annotations.
			@property {<type>} <field-name> <description> - Specify a Field within an Object Type.

			// For <name>s
			... [<name>] ... - Specify that this Property is Optional.
			... [<name>=<value>] ... - Specify that this Optional Property has a Default Value.

			// Within <description>
			... { @link <type-namepath> } ... - Show a Clickable Link to the Custom Type in the Editor Hints.

		Performance Profiling:
			Chrome has the ability to analyze the per-line Execution Time per Performance Profiling Session.
				Open Developer Tools.
				Go to the Performance Tab.
				Record a Performance Profile.
				Click on the Sources Tab, and select the relevant File.

		Mathematical Functions: 
			Math.floor();
			Math.random();
			// ... etc.
		
		Date Functions:
			Date.now(); 									// Returns the number of milliseconds since Jan 1, 1970
			setTimeout(function, <milliseconds>); 			// Executes the specified function once the specified amount of milliseconds has passed.
			var intervalHandle = setInterval(function, <milliseconds>); // Executes the specified function repeatedly after every period of the specified amount of milliseconds has passed.
			clearInterval(<intervalHandle>); 				// Stop the repeated execution of a function.
			
		Regex: /<regex>/ or /<regex>/g to match for multiple instances of <regex>
			Quantifiers:
				<char | char-class>* : 0 or more of <char> or <char-class>
				<char | char-class>+ : 1 or more of <char> or <char-class>
				<char | char-class>? : 0 or 1 of <char> or <char-class>
				
				<char | char-class>{n} : Exactly n of <char> or <char-class>
				<char | char-class>{n, } : At least n of <char> or <char-class>
				<char | char-class>{n, m} : At least n and at most m or <char> or <char-class>
				
				<char | char-class><quantifier>? : Converts the matching to non-greedy Quantifiers.
			
			Specials:
				^ : Matches the beginning of the String.
				$ : Matches the end of the String.
			
			[<char>...]<quantifier> : Denotes Character Class to match for.
			[^<char>...]<quantifier> : Denotes Character Class to not match for.
			
			(?:<regex>) : Denotes a Non-Capturing Group for <regex>.
				<expr>(?=<regex>) : Denotes a Non-Capturing Group for a Positive Lookahead - that is, match only for occurrances where <expr> is followed by the <regex>.
				<expr>(?!<regex>) : Denotes a Non-Capturing Group for a Negative Lookahead - that is, match only for occurrances where <expr> is NOT followed by the <regex>.
				(?<=<regex>)<expr> : Denotes a Non-Capturing Group for a Positive Lookbehind - that is, match only for occurrances where <expr> is preceded by the <regex>.
				(?<!<regex>)<expr> : Denotes a Non-Capturing Group for a Negative Lookbehind - that is, match only for occurrances where <expr> is NOT preceded by the <regex>.
			
			(<regex>) : Denotes an anonymous Capturing Group for <regex>
				\1 ... \99 : References Capturing Groups previously defined.
			
			(?<name><regex>) : Denotes a Capturing Group called 'name' for <regex>. Note: The '<' and '>' in '<name>' ARE required.
				\<name> : References named Capturing Groups previously defined.
				
			Usage:
				<regex>.test(<variable>) : Test for the occurrence of a given pattern in the submitted <variable>.

				<string>.match(<regex>) : 
					- If <regex> is not globally scoped, it will return the first occurrance, alongside any capturing groups within <regex>.
					- If <regex> is globally scoped, it will return all occurrances, but without any capturing groups within <regex>.
				<regex>.exec(<string>) : 
					- If <regex> is not globally scoped, it will return the first occurrance, alongside any capturing groups within <regex>.
					- If <regex> is globally scoped and saved, it will return the ith occurrance, alongside any capturing groups, on the ith iteration of the .exec call on the <regex> object.
	
		AJAX Requests: Mechanism to query an Endpoint and retrieve Data.
			XHR:
				// Create a new AJAX XHR Request:
				const httpRequest = new XMLHttpRequest();
				
				// Specify HTTP Request Type and Target:
				httpRequest.open("{GET | POST | PUT | DELETE}", "<relative-url>"); 
				
				// Add Event Listeners for dealing with Operation Lifecycle:
				httpRequest.onload = function() { 
					/*
						Operation Lifecycle Phase Identifier
						this.readyState:
							0 - Unsent
							3 - Loading
							4 - Done
							...
					/*

					// HTTP Status Code:
					// this.status

					// ... 
				};
				
				// Fire off the AJAX XHR Request:
				httpRequest.send(null); 

			Fetch API:
				// Promise Interface:
				fetch(
					'<url>',
					// HTTP Request Object
					{
						method: <HTTP-method>,
						mode: <CORS-mode>,
						cache: <cache-control>, // for HTTP Request Content
						headers: {
							<HTTP-Request-Header-Field>: <value>,

							// Content-Type: 'application/json', // Indicates Format of Payload to be sent.
							// Accept: 'application/json',	// Indicates Preferred Format for Payload to be received.

							// ...
						},
						body: JSON.stringify(<data>)
					}
				)
					.then(
						res => {
							if (!res.ok) {
								// To handle HTTP Statuses that represent Unsuccessful Operation.
								// res.status
							}

							// Converting the Response Data to another format is also an Asynchronous Operation; a Promise is returned from the <data-conversion-method> invocation:
							return res.<data-conversion-method>(); // res.json();
						}
					)
					.then(
						convertedData => {
							if (convertedData && convertedData.success) {
								// ...
							}

							// ...
						}
					)
					.catch(
						error => {
							// ...
						}
					)

		Storage: To persist Data from a given Origin locally.
			// Note: Same-Origin Policy.

			// Synchronous: Key-Value Databases:
				// Note: 5MB Maximum Storage Capacity.
				// Note: Only Strings can be stored. Use JSON.stringify to store more Complex Data.

				// Note: Not recommended by Google Chrome:
					// Blocks the Main Thread (Synchronous API).
					// Cannot be used by Workers.

				Local Storage: Read-Only Storage with no Expiration Time.
					// localStorage.setItem('<key>', '<item>');
					// localStorage.getItem('<key>');
					// localStorage.removeItem('<key>');
					// localStorage.clear();

				Session Storage: Read-Only Storage which only persists for as long as the current Tab / Browsing Session does. Survives Page Reloads and Page Refreshes.
					// Note: Duplicated upon Tab Duplication.

					// sessionStorage.setItem('<key>', '<item>');
					// sessionStorage.getItem('<key>');
					// sessionStorage.removeItem('<key>');
					// sessionStorage.clear();
			
			// Asynchronous:
				IndexedDB: Storage meant for keeping large amounts of Data.
					// Note: > 100+ MB of Data.

					// Transactional Key-Value Pair Database System.
						// Note: Transactions auto-commit.

			// Shared Storage:
				Cookie: 'Storage' that can be shared with the Server, or between multiple Applications in different sub-Domains.
					// Note: Data must be small to avoid overly large Request Payloads (Cookies are sent with every Request).
					// Note: Only String Data can be stored. Use JSON.stringify to transform JS Objects into String Data.

					document.cookie		// Returns a semicolon separated list of Cookies, or sets a custom Cookie. Cannot be done if the Cookie has been set to HttpOnly in the HTTP Response Header from the Server.

		Web Workers: For offloading CPU Intensive Tasks into a separate Background Thread.
			Motivation: Javascript was designed for single-threaded execution, but most Computers nowadays have CPUs that have more than one Execution Core.

			Characteristics:
				Multiple in one Browser Tab.
				Utilizes Message Passing for synchronization.

				Subset of Functionality available to Main Thread:
					Cannot access DOM.

			Requirements:
				Worker Code is placed entirely into a separate .js File, as Web Workers were designed to run in an isolated context for security and stability reasons.

			// Code:
				// main.js
					const worker = new Worker('<file>.js');

					// Note: By default, assume Data passed between the Main Thread and the Worker Thread is serialized / deserialized.
						// Consider restructuring the Data into one that supports the Transferrable Interface, so that only the ownership of the Data Structure is changed.

					worker.postMessage(<args>);
					worker.onmessage(
						e => {
							// e.data === <results>
							// ...
						}
					);

					worker.terminate();

				// worker.js
					this.onmessage(
						e => {
							// e.data === <args>
							// ...

							this.postMessage(<results>);
						}
					);

					this.close();

		Service Workers: For a Proxy Server between the Browser and Server, enabling capability for offline-processing.
			Characteristics:
				Only one per Browser Tab.
				Persists beyond the Browser Tab's Lifespan.

			Requirements:
				HTTPS to avoid MitM Attacks.

		Document Object Model: An in-memory (mutable) tree representation of the HTML Page after it is read by the Browser.
			DOM Nodes:
				var node = document.getElementsByClassName('<class-name>'); // No need the . prefix
				var node = document.getElementById('idName'); // No need the # prefix
		
			DOM Properties: Initialized from the values assigned to HTML Attributes. These can mutate during runtime, unlike HTML Attributes which only dictate the starting values of these Properties.
				node.classList.add('<class-name>', ...); // Add Class to DOM Node. No need the . prefix.
				node.classList.remove("<class-name>", ...); // Remove Class from DOM Node. No need the . prefix.

				node.style; 		// references the Inline Style set specifically on the DOM Node.
					node.style = `<value>`; // Must be string.

				window.getComputedStyle(node); // references the Style from the DOM Node.

				node.innerText; 	// references the text content between opening and closing HTML tags 
				node.innerHTML; 	// references the HTML content between opening and closing HTML tags
			
			DOM Events:	
				// Event Bubbling: 	Event propagtes from Child to Parent.
				// Event Capturing: Event travels back from Parent to Child.

				// Note: Event Listeners send in Event Objects when invoked:
					eventObject.target.value // target is the DOM Node that triggered the Event
					eventObject.currentTarget.value // currentTarget is the DOM Node that the Event Listener is attached to

				// Tip: For optimization, implement Event Delegation by creating the Event Listener on the Parent rather than attaching specific Event Listeners on all Child Objects. If the Event can Bubble, this should work.

				Add Event Listener:
					node.addEventListener("<eventType>", function(event) { //... }, useCapture); // Anonymous function is Event Handling Function
						// <eventType>: http://www.w3schools.com/jsref/dom_obj_event.asp
						// event: the Object containing details about the Event that triggered the listener
							// event.preventDefault(): prevent the default handling of this event (implemented by the User Agent)  from being executed
							// event.stopPropagation(): stop parent DOM Node from also receiving the event
						// useCapture: false to specify function should fire during bubbling, true to specify the function should fire during capturing

						// node.eventType = functionID; // Legacy shortcut
				
				Remove Event Listener:
					node.removeEventListener("eventType", functionID); // Doesn't seem to be able to remove anonymous functions
					node.eventType = null; // Legacy shortcut
				
			Shadow DOM: An encapsulated DOM Tree which can be attached to any part of the regular DOM Tree, whilst still maintaining the encapsulation.
				Code within the Shadow DOM cannot affect the regular DOM Tree.

				Shadow Host: The regular DOM Tree Node to which a Shadow DOM Tree will be attached to.
				Shadow Boundary: The boundary by which a Shadow DOM Tree and the regular DOM Tree are separated by. It does not contain the Shadow Host.
				Shadow Root: The root node of a Shadow DOM Tree.

				// Creating a Shadow DOM Tree, and attaching it onto a Shadow Host.
				let shadowDOMTree = element.attachShadow({
					mode: {'open' | 'close'} // Allow if outside JS can access the Shadow DOM Tree.
				});

		Resize Observer: To do something when there are Size Changes detected in one or more Observed DOM Nodes.
			const observer = new ResizeObserver(
				// Callback that executes whenever a Resize of the Observed Targets are detected.
				entries => {
					// entries represent the Dimensions of each Observed Target during a Detection.
						// entry.target

						// These are similar to the result of getBoundingClientRect().
							// entry.contentRect
							// entry.borderBoxSize
							// entry.contentBoxSize
				}
			);

			observer.observe(<html-element>, ...);

			observer.unobserve(<html-element>, ...);
			observer.disconnect();

