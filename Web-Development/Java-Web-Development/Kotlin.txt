Kotlin
	Abbreviations:
		
	
	Description: Programming Language that is compatable with Java, and can target JVM and JavaScript Environments. Designed by JetBrains to be a "better" Java.
	
	Resources: 
		Generic Types: https://typealias.com/guides/illustrated-guide-covariance-contravariance/
	
	Concepts:
		Coroutines: Unit of Suspendable Concurrent Execution.

		JAR Files: Java Archive. Contains Libraries, Resources and Assets.
		WAR Files: Web Application Archive. Contains the Web Application in a specific structure that can be deployed on any Web Container / Java Application Server.

	Details:
		Features:
			Functional Programming.
			Immutability Support.

		Syntax:
			Types:
				// Primitive Types:
					Any?

					Character
					String

					Double
					Float
					Int

					Boolean

					Unit // Void Type for Functions that don't return anything.
					Void // Void Type from Java.
					Nothing // Analogous to never Type in TypeScript

				// Nullable Type:
					<type>?

				// Function Type:
					typealias <function-type> = (<arg>: <arg-type>,  ...) -> <return-type>

				// Suspendable Function Type:
					suspend (<arg>: <arg-type>, ...) -> <return-type>

			// Runtime Type Checking:
				// Note: Boolean Expression.
				<value> is <type>
				<value> !is <type>

			// Tip: Use Reflection to find out the Type of a Variable during Runtime:
				println(<variable>!!::class.simpleName)
				println(<variable>!!::class.qualifiedName)

			// Tip: Get the underlying Java Class for a given Kotlin Class.
				<kotlin-class>::class.java
			
			// Package Declaration: Defines which Package the File belongs to.
				// Note: Common Prefixes among the Files can be omitted from the Folder Structure (i.e. no need create such a deep nesting).
				package <path>. ...

			Constants:
				val <runtime-constant-name>: <type> = <value>;

				// For Properties known at Compile Time:
				// Tip: Faster Performance.
				const val <compile-constant-name>: <type> = <value>;

			Ranges:
				// val range: ClosedRange<Int>
				val range: IntRange = <inclusive-min> .. <inclusive-max> [step <step>]
				val range: IntRange = <inclusive-min> until <exclusive-max> [step <step>]

				range
					.first 		// Get First Value within the Range
					.last 		// Get Last Value within the Range
					.step		// Get Step Amount for the Range

					.reversed()	// Reverse the Order of the Range
					.filter <lambda>
					.map <lambda>
					.reduce <lambda>

			Variables:
				var <variable-name>: <type> = <value>;

			Strings:
				// Note: Use Double Quotes to define String Values; Single Quotes define Character Values.

				// Multiline Strings:
				val multiline = """
				<text>
				...
				""";

				val multiline = """
					<indented-content>
					...
				""".trimIndent();

				// Templates:
					// Simple: For just referencing Values / Variables
					val i = <value>;
					val string = "$i ...";

					// Expression: For referencing the result of an Inline Expression
					val string = "${ i + 5 } ...";

			Collections:
				// Lists
					val mutableList: MutableList<<type>> = mutableListOf( <item>, ... )
					val list: List<<type>> = listOf( <item>, ... )

					mutableList.size

					mutableList.add( <new-item> )

				// Maps
					val mutableMap: MutableMap<<key-type>, <value-type>> = mutableMapOf(
						<key> to <value>,
						// ...
					)
					val map: Map<<key-type>, <value-type>> = mapOf(
						<key> to <value>,
						// ...
					)

					mutableMap.keys
					mutableMap.values

					mutableMap.getOrDefault( <key>, <value> )
					mutableMap.putIfAbsent( <key>, <value> )

					map.contains( <potential-key> )
					map.get( <key> )

				// Streams: Used for Function-Oriented Processing of Immutable Element Sequences obtained from a Collection.
					val stream = <collection>.stream()

					stream
						.forEach
						.map
						.filter

						// ...

			Objects:
				// Note: Lazily Initalized only during the first access.
					// Tip: Effectively Singleton Classes:
					object <object-name>: <interface-type> {
						// ... Class-Compatable Member Declarations here ...
					}

			Interfaces: Used to declare Public API for Implementing Constructs.
				interface <interface-name>: <parent-interface>, ... {
					fun <function-name>(<arg>: <type>, ... ): <return-type>
					suspend <function-name>(<arg>: <type>, ... ): <return-type>

					// ...
				}

			Classes:
				// Note: Classes can omit the Curly Braces if the Class has no Body.

				// Data Class: Classes meant to describe Objects that just hold Data. Analogous to POJOs.
					// Note: Cannot allow Overridance.
					// Tip: Kotlin will automatically define a default 'equals', 'hashCode', 'copy' and 'toString' Utility Methods for the created Data Class if there are no explicit definitions for those Methods in the Class Body.
					// Tip: Properties on a Data Class Instance can be Deconstructed via Spreading.
					data class <data-class-name>( { val | var } <property>:<type> = <default-value>, ... ) {
						// Note: Properties declared in the Body of the Data Class will not be considered during the invocation of the automatically generated Utility Methods mentioned above.

						// ...
					}
						// Tip: For Instances of Immutable Data Classes, use the 'copy' Method to avoid having to copy every unchanged Property if the Instance is to be 'updated'.

				class <class-name>[ { public | private } @<annotation> constructor](
					// Primary Constructor / Default Constructor
					// Note: Preceding 'constructor' Keyword needed if the Constructor has Visibility Modifiers or Annotations
					
					// Constructor Parameters
					// Note: Not creating a new Property in the Class, but rather allowing Constructors / Initialization Blocks to access a Value which can be used to initialize other Properties.
					<parameter>:<type> = <default-value>, ...

					// Instance Properties
					// Note: Creates a new Property on the Class.
					{ val | var } <property>:<type> = <default-value>, ...
				) {
					// ...

					// Declaring additional Class Properties / Initialize:
					var <property>:<type> = ... ;
						<{ private | public }> get() = {
							// 'field' keyword to reference <property>
							// 'this' to reference Class Instance
						}
						<{ private | public }> set() = {
							// 'field' keyword to reference <property>
							// 'this' to reference Class Instance

							// Note: Do NOT use this.<property> to set the <property> Value as it becomes an Infinite Loop.
						}

					// Initialization Block: For Code to be run during Object Instantiation.
					// Note: Executed in the order they are declared in.
					// Tip: Don't need explicit init Block for Class Properties initialized above inline.
					init {
						// ...
					}

					// Secondary Constructor:
					// Note: If there is a non-default Primary Constructor, the Secondary Constructor will have to delegate to it.
					// Note: Therefore, code from Primary Constructors, Property Initializers and Initialization Blocks are executed before Secondary Constructors.
					// Tip: Prefer Default Values in the Primary Constructor as opposed to Secondary Constructors.
					constructor(
						// Note: Specifying 'val' or 'var' here for Parameter Properties will not be correct for those already specified in the Primary Constructor.
						... 
					): this( ... ) {
						// ...
					}

					// ...

					// Companion Objects:
					// Note: Replaces Static Class Members.
					companion object [<c-object-name>]: <interface-type> {
						// ...

						// Mark the following Method as a Static Method for the JVM
						@JvmStatic
						fun <function-name>( ... ) { ... }
					}

					// Accessing Companion Objects within Classes:
						// If Companion Object was not given a Name:
						<class-name>.Companion

						<class-name>.<c-object-name>

					// ...
				}

				// Interface Implementation:
					class <implementing-class-name> ( ... ): <interface>, ... {
						override fun <interface-function-name> ( ... ) { ... }
						override suspend fun <interface-function-name> ( ... ) { ... }

						// ...
					}

				// Inheritance:
					// Note: Classes are treated as 'final' or Non-Inheritable by default.
					// Mark a Class as Inheritable by Sub-Classes via the 'open' Keyword.
					// Note: Sub-Classes must provide Arguments for the Inheritable Class's Parameter Properties, if any.
					open class <inheritable-class-name>() {
						// Mark a Class Property as Overridable by Sub-Classes via the 'open' Keyword.
						open val <property>:<type>;
					}

					// Note: Sub-Classes must have only one Parent, but they can implement multiple Interfaces.
					// Note: Sub-Classes must provide Arguments for the Inheritable Class's Parameter Properties, if any.
					class <sub-class-name>(
						// Note: Specifying 'val' or 'var' here for Parameter Properties will re-create the Inherited Property within this Sub-Class, rather than just passing it to the Base Class.
						... 
					): <inheritable-class-name>( ... ), <interface-name>, ... {
						// Override Property from <inheritable-class-name>:
						// Note: Overriden Properties are themselves considered Overridable by any Sub-Class. Use the 'final' Keyword to prevent Overriding.
						// Note: In the event of Multiple Inheritance with Common Class Properties, it is required to Override these to eliminate ambiguity.
						[final] override val <property>;

						// Access <inheritable-class-name> Implementation via the 'super' Keyword.
						// Note: In the event of Multiple Inheritance, define which <inheritable-class> 'super' refers to via:
						super<<inheritable-class>>

						// Note: Inherited Constant Properties can be changed to Variable once Overriden.
						override var <property>:<type>;

						// Note: Inherited Function Properties cannot have their default Argument Values changed when Overriding.
					}

				// Delegation: Allows usage of a secondary Class to fulfil part of a Class' API.
					interface <interface-name> {
						fun <example-function>( ... ): <return-type>
					}

					class <delegate-class>( ... ) : <interface-name> {
						override fun <example-function>( ... ) = {
							// ...
						}
					}

					class <delegating-class>(private val <delegate>: <interface-name>) : <interface-name> by <delegate> {
						// ...
					}

				// Instantiate a Class Instance:
					// Note: No 'new' Keyword.
					val instance = <class-name>();

			Operators:
				// Structural Equality Comparator: 
					// Check if two Values are equivalent: ==
					// Check if two Values are NOT equivalent: !=

				// Referential Equality Comparator: 
					// Check if two Values are equivalent and refer to the same Entity: ===
					// Check if two Values are neither equivalent, nor refers to different Entities: ===

				// Elvis Operator: 
					// Nullish Coalescing - evaluates <expression-1> and returns the result if it is not null, otherwise <expression-2> will be evaluated.
					// Tip: Avoids double-evaluation of <expression-1>.
					<expression-1> ?: <expression-2>;

				// Spread Operator: 
					*
						// Note: Only usable when passing in Arguments to a varargs Function.
						*<array-variable> // Spreads out <array-variable>

					val ( <property>, ... ) = <data-class-instance>

				// Reflection Operator:
					::

			Functions: First-Class Citizens. Higher-Order Functions possible.
				// Note: Functions with Block Body (Curly Braces) must explicitly define their <return-type>.
				// Note: <function-name> can be a String Template as well.
				fun <function-name>(<arg>:<type>, ... , <optional-arg>:<type> = <default-value>, ... ): <return-type> {
					// ...

					return <value>: <return-type>;
				}

				// Note: Main Function determines Execution Entry-Point for Program.
					fun main(args: Array<String>) {
						// ...
					}

				// Function with variable number of Arguments:
					fun <function-name>(vararg <arg-name>: <individual-arg-type>): <return-type> {
						// Note: <arg-name> will be an Array Type.
						// ...
					}

				// Function with a Function Argument:
					fun <function-name>(fnArg: <function-type>): <return-type> {
						// fnArg( ... )
					}

					// Passing an Instance of the <function-type> when calling <function-name>:
						val <some-function>: <function-type> = ( ... ) -> {
							// ...
						}

						<function-name>([<some-function-package-scope>]::<some-function>)

				// Single-Expression Function: Curly Braces can be omitted.
					fun <function-name>(<arg>: <type>, ...): <return-type> = <expression>

				// Inline Function: To allow the Compiler to inject the Code inside the Function directly at the Call Site.
					// Tip: Can improve performance where Closures are not needed.
					inline fun <inline-function-name>(<arg>: <type>, ...) {
						// ...
					}

				// Lambda Expressions / Function Literals / Arrow Functions:
					// Note: The Curly Braces are needed to obtain an Instance of the Lambda.
					val <lambda>: (<type>, ... ) -> <return-type> = {
						<arg>, ... -> 
							// Note: Function Body of a Lambda requires no Curly Braces.

							// ... 

							// Note: Last Expression in a Lambda is treated as a Return Expression.
							<return-expression>
					}

					// Lambdas with only one Argument
					val <lambda> = {
						// 'it' will refer to the Parameter
						// ...
					}

					// Lambdas with no Arguments
					val <lambda> = {
						// ...
					}

					// Tip: If the last Argument to a Function Call is a Lambda, it can be omitted from the Argument List during the Call.
					<calling-function>(<arg>, ... ) { <arg>: <type>, ... -> // ... }

					// Tip: If the sole Argument to a Function Call is a Lambda itself, the Parenthesis can be omitted entirely during the Call.
					<calling-function> { <arg>: <type>, ... -> // ... }

					// Tip: If the sole Argument to a Function Call is a Lambda with only one Argument, the following shorthand can be used:
					<calling-function>(::<lambda>)

					// Note: Withn Inline Functions, return statements from Lambdas will exit the Inline Function rather than the Lambda itself.
					// Tip: Use a Label to return the Lambda itself:
					lit@ {
						// ... 

						// if (<boolean-expression>) return@lit <return-value>;

						// ...
					}

				// Anonymous Function: 
					fun (<arg>: <type>, ... ) = // ...

			Generics:
				// Declaration Site Variance:
					// Invariant Types: Generic Types with no specified Upper or Lower Bounds. Once such a Type is inferred for <invariant-generic-type>, all other places where <invariant-generic-type> appears must be of that Type.
						// Functions:
							fun < <invariant-generic-type>, ... > <function-name>( <arg>: <invariant-generic-type>, ... ): <invariant-generic-type> {
								// ...
							}

						// Classes:
							class <parameterised-class>< <invariant-generic-type>, ... >( private val value: <invariant-generic-type>, ... ) {
								fun get(arg: <invariant-generic-type>): <invariant-generic-type> {
									return value
								}
							}

					// Type Bounding: Via the 'where' Keyword.
						// Note: If a <generic-type> has multiple Bounds, that means that the Concrete Type passed in must fulfill all Bounds.

						// Functions:
							fun < <generic-type>, ... > <function-name>( arg: <generic-type>, genericArg: <another-generic-type><<generic-type>>, ... ) where <generic-type>: <type>, <generic-type>: <another-generic-type><<generic-type>>, ... {
								// ...
							}

						// Classes:
							class <class-name>< <generic-type>, ... >( arg: <generic-type>, genericArg: <another-generic-type><<generic-type>>, ... ) where <generic-type>: <type>, <generic-type>: <another-generic-type><<generic-type>>, ... {
								// ...
							}

						// Star Type Bounding: For when the Type does not actually matter. Variables of Star Types are Read-Only.

					// Covariant Types: Cannot be used in Parameter Types (i.e. only "out" Positions such as Return Types), but allows for Types to be assigned to a Supertype Reference in the Invoking Code.
						// Classes:
							class <parameterised-producer-class>< out <covariant-generic-type>: <upper-bound-super-type>, ... >( private val value: <covariant-generic-type>, private val genericValue: <another-generic-type><<covariant-generic-type>>, ... ) {
								fun <producing-function>(): <covariant-generic-type> {
									return value
								}
							}

							val parameterizedProducerClass = <parameterised-producer-class><<sub-type>>( ... )

							// parameterizedProducerClass.<producing-function>() will return the <sub-type>, which can be cast to the <super-type> when done through ref.
							val ref: <parameterised-producer-class><<super-type>> = parameterizedProducerClass

					// Contravariant Types: Cannot be used in Return Types (i.e. only "in" Positions such as Parameter Types), but allows for Types to be given a Subtype Reference in the Invoking Code.
						// Classes:
							// Note: Contravariant Argument Types are not supported when Overriding a Class Method to support Method Overloading, but Functions can be assigned as Class Properties as a workaround.
							class <parameterised-consumer-class>< in <contravariant-generic-type>: <upper-bound-super-type>, ... >( ... ) {
								fun <consuming-function>(value: <contravariant-generic-type>): ... {
									// ...
								}
							}

							val parameterizedConsumerClass = <parameterised-consumer-class><<super-type>>( ... )

							// parameterizedConsumerClass.<consuming-function>( ... ) will accept the <super-type>, so sending in a <sub-type> is still correct when done through ref.
							val ref: <parameterised-consumer-class><<sub-type>> = parameterizedConsumerClass

				// Type Projection:
					// Covariant Type Projection: Allow for Types to be assigned to a Supertype Reference in the Invoking Code via "out", but converts all Parameter Types involved with the Generic Argument Type to be 'Nothing'.

					// Contravariant Type Projection: Allow for Types to be assigned to a Subtype Reference in the Invoking Code via "in", but converts all Return Types involved with the Generic Argument Type to be 'Any?'.

			Control-Flow:
				// Iteration:
					repeat(number) {
						// ... it ...
					}

					for (<value> in <range>) {
						// ...
					}

					for (<value> in <iterable>) {
						// ...
					}

					// Over a Collection:
						<collection>.forEach { key, value -> <code> };

				// If-Else:
					// Note: if-else is an Expression, meaning it can return Values once evaluated.
					val result = if (<boolean-expression>) {
						<result>
					} else if (<boolean-expression>) {
						<result>
					} else {
						<result>
					}
					
					// Single Line:
					if (<boolean-expression>) ? <true-expression> : <false-expression>;

				// Switch-Case:
					// Note: when is an Expression, meaning it can return Values once evaluated.
					val result = when (<variable>) {
						// Specific Case(s)
						<case-value>, ... -> {
							// ...
						}
						// Specific Conditionals
						<boolean-expression> -> {
							// ...
						}
						// Type Checking
						is <type> -> {
							// ...
						}
						// Default Case:
						else -> {
							// ...
						}
					}
					
					// Tip: when can be used without any <variable>s, which can be seen as a nicer if-else alternative.

			Utilities:
				// Print to Console:
					print("<text>");
					println("<text>"); // With Line Break

				// Execution:
					// Block Execution of the Process by the specified amount of <milliseconds>.
					// Note: Not compatable with Coroutines.
					Thread.sleep(<milliseconds>);

				// Asynchronousity:
					// Suspendable:
						// Coroutines: A tracked instance of Pausable Computation.
							// Type: Job.

							// Tip: Creating a Coroutine incurs less overhead than creating a Thread.

							// Note: Parent Coroutines cannot complete until all Child Coroutines complete (following the princple of Structured Concurrency).

							// CoroutineScope: Defines an environment for which Coroutines can be created in. Can be seen as a "Grouping" of Coroutines.
								// Constructor Functions:
									// runBlocking: A Normal Function that when executed, instantiates a local CoroutineScope and blocks current execution from continuing beyond it, and *additionally locks down the execution to the code within the created scope*. Can be used as a bridge between non-Suspendable Code and Suspendable Code.

									// coroutineScope: A Suspendable Function that when executed, instantiates a local CoroutineScope and blocks current execution from continuing beyond it, but *does not additionally lock down the execution to the code within the created scope*, and releases the calling Thread to perform other execution.

								// GlobalScope: A Globally Accessible CoroutineScope, usually meant for Top-Level Coroutines operating throughout the Application lifetime.

							// CoroutineContext: The Object that holds the Execution Metadata of a CoroutineScope (e.g. which Thread Dispatcher it is using).
								// Thread Dispatcher Types:
									// Dispatchers.Default: Coroutines defined within the Scope will run on a Thread specialized for CPU intensive work.
									// Dispatchers.IO: Coroutines defined within the Scope will run on a Thread specialized for IO intensive work.
									// Dispatchers.Unconfirmed: Coroutines defined within the Scope will run on any Thread.

							// Coroutine Builder Functions: Only usable from / within a CoroutineScope. Will inherit parent CoroutineScope and modify it.
								// launch 		Starts a new Coroutine.
								// join 		Wait for the completion of the created Coroutine.

								// async 		Starts a new Coroutine that is used to compute some Result, represented by an instance of Deferred. Note: Will NOT cause the Application to crash upon encountering an unhandled Exception.
								// await 		Wait for the completion of the created Coroutine, and realize the Result of the Deferred Instance.

							// Suspendable Function: Pausable Function; Analogous to an Asynchronous Function in JavaScript.
							// Note: Only can be used in other Suspendable Functions / Coroutines.
								suspend fun <suspendable-function-name>() {
									// Concurrent Code ...

									// Note: Calling another Suspendable Function will defer execution of this Function.

									// ...
								}

								// ...

								fun main() {
									runBlocking {
										val handle = launch { <suspendable-function-name>() }
										
										// ...

										handle.join()
									}
								}

					// Parallelism / Multi-Threaded:
						// Note: Threads are more expensive to create than Coroutines.

						// Thread-Safe Read-Write Data Structures:
							// Concurrent Map:
								val concurrentMap = ConcurrentHashMap()

								concurrentMap.keys
								concurrentMap.values

								concurrentMap.contains( <potential-key> )
								concurrentMap.getOrDefault( <potential-key>, <default-value> )

								concurrentMap.put( <key>, <value> )
								concurrentMap.putIfAbsent( <key>, <value> ) // Set-like Functionality
								concurrentMap.remove( <key> )
							
							// Concurrent Set:
							// Note: Universal Lock - multiple Concurrent Reads not supported
								val concurrentSet = Collections.newSetFromMap( <map> ) // Creates a Wrapper for Set Behaviour
								val concurrentSet = ConcurrentHashMap.newKeySet()

							// Parallel Streams: Used for Function-Oriented Parallel Processing of Immutable Element Sequences obtained from a Collection.
								// To change the number of Threads created by ForkJoinPool, of which ParallelStream uses for Thread Creation:
								// Note: Usually this defaults to # of Available Cores - 1
								System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "<number>")

								val parallelStream = <collection>.parallelStream()
								
								parallelStream
									.forEach
									.map
									.filter

									// ...

						// Semaphores:
							// CountDownLatch - simple Counting Semaphore:
								val latch = CountDownLatch(<starting-number>)

								// ...

								latch.countDown()

								// Only resume Execution once the Countdown Semaphore reaches 0.
								latch.await()

				// Date:
					// Point in Time via UTC (replaces java.util.Date & java.util.Timestamp)
					Instant
						// Quick way to get an Instance of Instant:
						val <instant> = Instant.now()

						// get LocalTime
						<instant>
							.atZone(ZoneOffset.UTC).toLocalTime()

						// set
						<instant>
							// Convert to ZonedDateTime
							.atZone(ZoneOffset.UTC)
								.withYear(<year>)

								.withMonth(<month>)
								.withDay(<day>)

								// OR

								.withDayOfYear(<day>) // 1 - 365

								.withHour(<hour>)
								.withMinute(<minute>)
								.withSecond(<second>)
								.withNano(<nano>)

							// Convert back to Instant
							.toInstant()

					// Point in Time via Offset from UTC
					OffsetDateTime

					// Point in Time via Timezone Specification (Continent/Region) (replaces java.util.GregorianCalendar & javax.xml.datatype.XMLGregorianCalendar)
					ZonedDateTime

					// Date and Time Representation
					// Note: Cannot represent Point in Time because it lacks Timezone
					LocalTime // Replaces java.sql.Time
					LocalDate // Replaces java.sql.Date
					LocalDateTime

				// IO:
					// Files:
						val fileHandle = File("<absolute-file-path>")

						// Read
							// Obtain a List of Lines in the File.
							// Tip: Suitable for Large Files, as this uses a Lazy Evaluation over a Stream, which is good for open File Handle count.
								<file-handle>.useLines {
									// ... it.toList() ...
								}

							// Execute a Function for each Line in the File.
								<file-handle>.forEachLine {
									// ... it ...
								}

						// Write
							// Write Content piecewise into the File via a PrintWriter.
							// Note: PrintWriter internally uses a BufferedWriter.
							// Note: PrintWriter not officially declared as Thread-safe, but can assume it is.
								<file-handle>.printWriter().use {
									out -> 
										// ... out.print(<content>) ...
										// ... out.println(<line-content>) ...

										out.flush()
										out.close()
								}

							// Write Text into the File.
								<file-handle>.writeText(<file-content>)

				// JSON Manipulation
					// Relevant Packages:
						com.fasterxml.jackson.* // Serialization / Deserialization Library for JSON Objects
							// Relevant Types:
								ObjectMapper

								JsonNode // Documentation: https://fasterxml.github.io/jackson-databind/javadoc/2.8/com/fasterxml/jackson/databind/JsonNode.html
									ContainerNode
										ObjectNode
										ArrayNode

									ValueNode
										TextNode
										NumericNode
										BooleanNode
										NullNode
										MissingNode

							// Helper to Serialize Class Instances to JSON Strings / Deserialize Class Instances from JSON Strings.
							// Note: Costly to instantiate - use for multiple uses.
							val mapper = ObjectMapper()
								// Configure Serialization / Deserialization Behaviour
									// mapper.configure( ... )

								// JSON String <-> Jackson JsonNode
									// mapper.readTree(<json-string>)

									// mapper.writeValue(<destination>, <jackson-node>)

									// mapper.writeValueAsString(<node>)

								// JSON String <-> Java Object
									// mapper.readValue(<json-string>, <class>)

									// mapper.writeValue(<output-stream>, <class-instance>)
									// mapper.writeValueAsString(<class-instance>)

								// Java Object <-> Jackson JsonNode
									// mapper.valueToTree(<java-object>)

									// mapper.valueToTree(<jackson-node>, <class>)

							// Node Creation
								val node: JsonNode = mapper.createObjectNode()

							// Detecting the Node Type
								// node.isObjectNode
								// node.isArray
								// node.isValueNode
									// node.isTextual

								// node.isMissingNode

							// Get a Node Value
								// get - returns null for Missing Nodes
									val value = <object-node>.get("<key>")?.as<kotlin-built-in-type>()
									// Note: textValue will return null if the Value is NOT an actual Text Value (i.e. isTextual).
									val value = <object-node>.get("<key>")?.textValue()

								// path - returns a Node for which isMissingNode() will return true if no Node exists at that path.
									val node: JsonNode = <object-node>.path("<key>").path("<sub-key>")
									// node.isMissingNode() === true

								// with - upserts a Node at "<key>" if it does not exist, and returns it
									val node = <object-node>.with("<key>")
									val node = <object-node>.withArray("<key>")

							// Set a Node Value
								// put
									val node = <object-node>.put("<key>", <primitive-value>)

								// replace
									val oldNode: JsonNode = <object-node>.replace("<key>", <json-node>)

								// set
									val node: ObjectNode = <object-node>.set("<key>", <json-node>)

							// Removing a Node Value
								// remove
									val removedNode: JsonNode = <node>.remove("<key>")
									val adjustedNode: JsonNode = <node>.remove(listOf("<key>", ...))

							// Converting from one type of Value to another type of Value (via Serializing the Source Class Instance to JSON String -> Deserializing from that JSON String into an Instance of the Target Class).
								class <target-class> (
									Create a Property that can be both Deserialized and Serialized.
									@JsonProperty("<json-field>") val <json-field>:<type>? = null,

									// Create a Property that can only be Deserialized.
									@JsonProperty("<source-json-field>") @JsonIgnore private val <non-serializable-property>:<type>? = null,

									// ...
								) {
									// Create a Property that can only be Serialized.
									@JsonGetter("<target-json-field>")
									fun get<target-json-field>() {
										return <property-value>
									}
								}

								mapper.convertValue(<source-instance-object>, <target-class>)
								

				// Client-Server Interactivity:
					// Relevant Packages:
						org.http4k.core.*
						org.http4k.routing.* // Library for setting up Server Routes
							// Relevant Types:
								// Server
									HTTPHandler // Data Type that specifies API Routes and their associated Handler Functions.
									Request
									Response

							// Setting up the Server
								fun <handler-function>( ... ): HTTPHandler {
									return routes(
										"<route>/{<path-parameter>}" bind Method.<http-method-type> { 
											req ->
												val pathParam = req.path("<path-parameter>")
												val queryParam = req.query("<query-parameter>")

												// ...

												Response(Status.<status>)
													.header(<header-field>, <header-value>)
													.header()
													// ...
													.body("<value>")
										},

										"<route>" bind <another-handler-function>( ... ),
									)
								}

								fun main() {
									<handler-function>.asServer(<server>(<port>)).start()
										// <server>
											// SunHttp
								}

							// Setting up and using the Client
								fun main() {
									val client: HTTPHandler = <http-client>()

									val request = Request(Method.<http-method-type>, "<url>")

									val response = client(request)
								}

		Project Configuration:
			// IntelliJ + Gradle + Maven
				// build.gradle
					// Build Script Config Section
					buildscript {
						// ...

						repositories {
							// ...

							maven {
								// Specify URI of accessible Kotlin Distributable in case it's not accessible from the Central Maven Repository.
								url "https://dl.bintray.com/kotlin/kotlin-eap-<version>"
							}

							// ...
						}

						// ...
					}

					// ...

					// Main Script Config Section 

					// ...

					repositories {
						mavenCentral()

						maven {
							// Specify URI of accessible Kotlin Distributable in case it's not accessible from the Central Maven Repository.
							url "https://dl.bintray.com/kotlin/kotlin-eap-<version>"
						}
					}

					// ...

		Compilation: Kotlin will convert <name>.kt Kotlin Files into <name>Kt Class Files when it detects during Compilation some Top-Level Functions inside.

	Commands:
		# Kotlin
			set KOTLIN_HOME

			# Start Interactive REPL:
			kotlinc

			# Generate Class File from Kotlin Files:
			kotlinc <kotlin-file> ...

			# Compile JAR File:
			kotlinc <kotlin-file> ... -include-runtime -d <jar-name>.jar

		# Java
			# Run generated Class File with Java:
			java -cp .;<kotlin-runner-JAR-path> <generated-class-file-without-extension>

			# Run generated JAR File in Java:
			java -jar <jar-name>.jar
	
