Kotlin
	Abbreviations:
		
	
	Description: Programming Language that is compatable with Java, and can target JVM and JavaScript Environments. Designed by JetBrains.
	
	Resources: 
	
	Concepts:
		Coroutines: Unit of Suspendable Concurrent Execution.

		JAR Files: Java Archive. Contains Libraries, Resources and Assets.
		WAR Files: Web Application Archive. Contains the Web Application in a specific structure that can be deployed on any Web Container / Java Application Server.

	Details:
		Designed to be a "better" Java.

		Features:
			Functional Programming.
			Immutability Support.

		Syntax:
			Types:
				// Primitive Types:
					Any?

					[Mutable]Map
					[Mutable]List

					ClosedRange<T> // For Ranges

					Character
					String

					Double
					Float
					Int
					
					Boolean

					Unit // Void Type for Functions that don't return anything.
					Void // Void Type from Java.
					Nothing // Analogous to never Type in TypeScript

				// Nullable Type:
					<type>?

				// Function Type:
					typealias <function-type> = (<arg>: <arg-type>,  ...) -> <return-type>

				// Suspendable Function Type:
					suspend (<arg>: <arg-type>, ...) -> <return-type>

				// Tip: Use Reflection to find out the Type of a Variable during Runtime:
					println(<variable>!!::class.simpleName)
					println(<variable>!!::class.qualifiedName)
				
			Constants:
				val <runtime-constant-name>: <type> = <value>;

				// For Properties known at Compile Time:
				// Tip: Faster Performance.
				const val <compile-constant-name>: <type> = <value>;

			Ranges:
				<inclusive-min> .. <inclusive-max> [step <step>]
				<inclusive-min> until <exclusive-max> [step <step>]
					.first 		// Get First Value within the Range
					.last 		// Get Last Value within the Range
					.step		// Get Step Amount for the Range

					.reversed()	// Reverse the Order of the Range
					.filter <lambda>
					.map <lambda>
					.reduce <lambda>

			Variables:
				var <variable-name>: <type> = <value>;

			Strings:
				// Note: Use Double Quotes to define String Values; Single Quotes define Character Values.

				// Multiline Strings:
				val multiline = """
				<text>
				...
				""";

				// Templates:
					// Simple: For just referencing Values / Variables
					val i = <value>;
					val string = "$i ...";

					// Expression: For referencing the result of an Inline Expression
					val string = "${ i + 5 } ...";

			Collections:
				// Lists
					var mutableList = mutableListOf( <item>, ... )
					val list = listOf( <item>, ... )

					mutableList.size

					mutableList.add( <new-item> )

				// Maps
					var mutableMap = mutableMapOf(
						<key> to <value>,
						// ...
					)
					val map = mapOf(
						<key> to <value>,
						// ...
					)

					mutableMap.keys
					mutableMap.values

					map.contains( <potential-key> )
					map.get( <key> )

			Objects:
				// Note: Lazily Initalized only during the first access.
					// Tip: Effectively Singleton Classes:
					object <object-name>: <interface-type> {
						// ... Class-Compatable Member Declarations here ...
					}

			Interfaces: Used to declare Public API for Implementing Constructs.
				interface <interface-name> {
					fun <function-name>(<arg>: <type>, ... ): <return-type>
					suspend <function-name>(<arg>: <type>, ... ): <return-type>

					// ...
				}

			Classes:
				// Note: Classes can omit the Curly Braces if the Class has no Body.
				// Tip: Define Data Objects as Classes with no Braces.
				class <class-name>(<property>:<type> = <default-value>, ...)

				class <class-name>[ {public | private} @<annotation> constructor](
					// Primary Constructor / Default Constructor
					// Tip: Allows for Parameter Properties (Instance Properties defined in Constructor Signature)
					// Note: Preceding 'constructor' Keyword needed if the Constructor has Visibility Modifiers or Annotations
					[{ val | var }] <property>:<type> = <default-value>, ...
				) {
					// ...

					// Declaring additional Class Properties / Initialize:
					var <property>:<type> = ... ;

					// Initialization Block: For Code to be run during Object Instantiation.
					// Note: Executed in the order they are declared in.
					// Tip: Don't need explicit init Block for Class Properties initialized above inline.
					init {
						// ...
					}

					// Secondary Constructor:
					// Note: If there is a non-default Primary Constructor, the Secondary Constructor will have to delegate to it.
					// Note: Therefore, code from Primary Constructors, Property Initializers and Initialization Blocks are executed before Secondary Constructors.
					// Tip: Prefer Default Values in the Primary Constructor as opposed to Secondary Constructors.
					constructor(
						// Note: Specifying 'val' or 'var' here for Parameter Properties will not be correct for those already specified in the Primary Constructor.
						... 
					): this( ... ) {
						// ...
					}

					// ...

					// Companion Objects:
					// Note: Replaces Static Class Members.
					companion object [<c-object-name>]: <interface-type> {
						// ...

						// Mark the following Method as a Static Method for the JVM
						@JvmStatic
						fun <function-name>( ... ) { ... }
					}

					// Accessing Companion Objects within Classes:
						// If Companion Object was not given a Name:
						<class-name>.Companion

						<class-name>.<c-object-name>

					// ...
				}

				// Data Class: Classes meant to describe Objects that just hold Data. Analogous to POJOs.
				// Tip: Kotlin will automatically define a default 'equals', 'hashCode', 'copy' and 'toString' Utility Methods for the created Data Class.
				// Tip: Properties on a Data Class Instance can be Deconstructed via Spreading.
				data class ( ... ) 

				// Interface Implementation:
				class <class-name>( ... ): <interface-name> {
					// ... Usual Function Definitions ...

					override fun <function-name> ( ... ) { ... }
					override suspend fun <function-name> ( ... ) { ... }
				}

				// Inheritance:
					// Note: Classes are treated as 'final' or Non-Inheritable by default.
					// Mark a Class as Inheritable by Sub-Classes via the 'open' Keyword.
					open class <inheritable-class>() {
						// Mark a Class Property as Overridable by Sub-Classes via the 'open' Keyword.
						open val <property>:<type>;
					}

					// Note: Multiple Inheritance is possible.
					// Note: Sub-Classes must provide Arguments for the Inheritable Class's Parameter Properties, if any.
					class <sub-class>(
						// Note: Specifying 'val' or 'var' here for Parameter Properties will re-create the Inherited Property within this Sub-Class, rather than just passing it to the Base Class.
						... 
					): <inheritable-class>( ... ), ... {
						// Override Property from <inheritable-class>:
						// Note: Overriden Properties are themselves considered Overridable by any Sub-Class. Use the 'final' Keyword to prevent Overriding.
						// Note: In the event of Multiple Inheritance with Common Class Properties, it is required to Override these to eliminate ambiguity.
						[final] override val <property>;

						// Access <inheritable-class> Implementation via the 'super' Keyword.
						// Note: In the event of Multiple Inheritance, define which <inheritable-class> 'super' refers to via:
						super<<inheritable-class>>

						// Note: Inherited Constant Properties can be changed to Variable once Overriden.
						override var <property>:<type>;

						// Note: Inherited Function Properties cannot have their default Argument Values changed when Overriding.
					}

				// Instantiate a Class Instance:
					// Note: No 'new' Keyword.
					val instance = <class-name>();

			Operators:
				// Type Checking:
					// Note: Boolean Expression.
					is <type>

				// Structural Equality Comparator: 
					// Check if two Values are equivalent: ==
					// Check if two Values are NOT equivalent: !=

				// Referential Equality Comparator: 
					// Check if two Values are equivalent and refer to the same Entity: ===
					// Check if two Values are neither equivalent, nor refers to different Entities: ===

				// Elvis Operator: 
					// Nullish Coalescing - evaluates <expression-1> and returns the result if it is not null, otherwise <expression-2> will be evaluated.
					// Tip: Avoids double-evaluation of <expression-1>.
					<expression-1> ?: <expression-2>;

				// Spread Operator: 
					*
						// Note: Only usable when passing in Arguments to a varargs Function.
						*<array-variable> // Spreads out <array-variable>

					val ( <property>, ... ) = <data-class-instance>

			Functions: First-Class Citizens. Higher-Order Functions possible.
				// Note: Functions with Block Body (Curly Braces) must explicitly define their <return-type>.
				// Note: <function-name> can be a String Template as well.
				fun <function-name>(<arg>:<type>, ... , <optional-arg>:<type> = <default-value>, ... ): <return-type> {
					// ...

					return <value>: <return-type>;
				}

				// Note: Main Function determines Execution Entry-Point for Program.
					fun main(args: Array<String>) {
						// ...
					}

				// Function with variable number of Arguments:
					fun <function-name>(vararg <arg-name>: <individual-arg-type>): <return-type> {
						// Note: <arg-name> will be an Array Type.
						// ...
					}

				// Single-Expression Function: Curly Braces can be omitted.
					fun <function-name>(<arg>: <type>, ...): <return-type> = <expression>

				// Generic-Type Function
					fun <<generic-type>> <function-name>(<arg>: <generic-type>, ...): <return-type> {
						// ...
					}

				// Inline Function: To allow the Compiler to inject the Code inside the Function directly at the Call Site.
					// Tip: Can improve performance where Closures are not needed.
					inline fun <inline-function-name>(<arg>: <type>, ...) {
						// ...
					}

				// Suspendable Function: Analogous to Asynchronous Function in JavaScript.
					suspend fun <suspendable-function-name>() {
						// Concurrent Code ...

						// Note: Calling another Suspendable Function will defer execution of this Function.

						// ...
					}

				// Lambda Expressions / Function Literals / Arrow Functions:
					// Note: The Curly Braces are needed to obtain an Instance of the Lambda.
					val <lambda>: (<type>, ... ) -> <return-type> = {
						<arg>, ... -> 
							// Note: Function Body of a Lambda requires no Curly Braces.

							// ... 

							// Note: Last Expression in a Lambda is treated as a Return Expression.
							<return-expression>
					}

					// Lambdas with only one Argument
					val <lambda> = {
						// 'it' will refer to the Parameter
						// ...
					}

					// Lambdas with no Arguments
					val <lambda> = {
						// ...
					}

					// Tip: If the last Argument to a Function Call is a Lambda, it can be omitted from the Argument List during the Call.
					<calling-function>(<arg>, ... ) { <arg>: <type>, ... -> // ... }

					// Tip: If the sole Argument to a Function Call is a Lambda itself, the Parenthesis can be omitted entirely during the Call.
					<calling-function> { <arg>: <type>, ... -> // ... }

					// Tip: If the sole Argument to a Function Call is a Lambda with only one Argument, the following shorthand can be used:
					<calling-function>(::<lambda>)

					// Note: Withn Inline Functions, return statements from Lambdas will exit the Inline Function rather than the Lambda itself.
					// Tip: Use a Label to return the Lambda itself:
					lit@ {
						// ... 

						// if (<boolean-expression>) return@lit <return-value>;

						// ...
					}

				// Anonymous Function: 
					fun (<arg>: <type>, ... ) = // ...

			Control-Flow:
				// Iteration:
					repeat(number) {
						// ... it ...
					}

					for (<value> in <range>) {
						// ...
					}

					for (<value> in <iterable>) {
						// ...
					}

					// Over a Collection:
						<collection>.forEach { key, value -> <code> };

				// If-Else:
					// Note: if-else is an Expression, meaning it can return Values once evaluated.
					val result = if (<boolean-expression>) {
						<result>
					} else if (<boolean-expression>) {
						<result>
					} else {
						<result>
					}
					
					// Single Line:
					if (<boolean-expression>) ? <true-expression> : <false-expression>;

				// Switch-Case:
					// Note: when is an Expression, meaning it can return Values once evaluated.
					val result = when (<variable>) {
						// Specific Case(s)
						<case-value>, ... -> {
							// ...
						}
						// Specific Conditionals
						<boolean-expression> -> {
							// ...
						}
						// Default Case:
						else -> {
							// ...
						}
					}
					
					// Tip: when can be used without any <variable>s, which can be seen as a nicer if-else alternative.

				// Coroutines: Deals with Asynchronous Programming Constructs.
					// Note: Coroutines can only be launched inside certain Builder Functions, which bridges regular Blocking Code with Concurrent Code.
					<coroutine-builder-function> {
						// Regular Code

						// Create a new Coroutine
						val <handle> = launch {
							// Concurrently-Executed Code
							// Suspendable Function Call
						}

						// Block Regular Code execution and Await Coroutine completion
						<handle> join();

						// Regular Code
					}

					// Coroutine Builder Functions:
						// runBlocking: Regular Function that when executed, blocks the current Thread. Waits for all Child Coroutines to complete before releasing.
						// coroutineScope: Suspendable Function that when executed, blocks and releases the current Thread for other usage. Waits for all Child Coroutines to complete before releasing.

			Utilities:
				// Print to Console:
					print("<text>");
					println("<text>"); // With Line Break

				// Date:
					// Point in Time via UTC (replaces java.util.Date & java.util.Timestamp)
					Instant
						// Quick way to get an Instance of Instant:
						val <instant> = Instant.now()

						// get LocalTime
						<instant>
							.atZone(ZoneOffset.UTC).toLocalTime()

						// set
						<instant>
							// Convert to ZonedDateTime
							.atZone(ZoneOffset.UTC)
								.withYear(<year>)

								.withMonth(<month>)
								.withDay(<day>)

								// OR

								.withDayOfYear(<day>) // 1 - 365

								.withHour(<hour>)
								.withMinute(<minute>)
								.withSecond(<second>)
								.withNano(<nano>)

							// Convert back to Instant
							.toInstant()

					// Point in Time via Offset from UTC
					OffsetDateTime

					// Point in Time via Timezone Specification (Continent/Region) (replaces java.util.GregorianCalendar & javax.xml.datatype.XMLGregorianCalendar)
					ZonedDateTime

					// Date and Time Representation
					// Note: Cannot represent Point in Time because it lacks Timezone
					LocalTime // Replaces java.sql.Time
					LocalDate // Replaces java.sql.Date
					LocalDateTime

				// IO:
					// Files:
						val fileHandle = File("<absolute-file-path>")

						// Read
							// Obtain a List of Lines in the File.
							// Tip: Suitable for Large Files, as this uses a Lazy Evaluation over a Stream, which is good for open File Handle count.
								<file-handle>.useLines {
									// ... it.toList() ...
								}

							// Execute a Function for each Line in the File.
								<file-handle>.forEachLine {
									// ... it ...
								}

						// Write
							// Write Content piecewise into the File via a PrintWriter.
							// Note: PrintWriter internally uses a BufferedWriter.
								<file-handle>.printWriter().use {
									out -> 
										// ... out.print(<content>) ...
										// ... out.println(<line-content>) ...

										out.flush()
										out.close()
								}

							// Write Text into the File.
								<file-handle>.writeText(<file-content>)

				// Execution:
					// Block Execution of the Process by the specified amount of <milliseconds>.
					// Note: Not compatable with Coroutines.
					Thread.sleep(<milliseconds>);

		Project Configuration:
			// IntelliJ + Gradle + Maven
				// build.gradle
					// Build Script Config Section
					buildscript {
						// ...

						repositories {
							// ...

							maven {
								// Specify URI of accessible Kotlin Distributable in case it's not accessible from the Central Maven Repository.
								url "https://dl.bintray.com/kotlin/kotlin-eap-<version>"
							}

							// ...
						}

						// ...
					}

					// ...

					// Main Script Config Section 

					// ...

					repositories {
						mavenCentral()

						maven {
							// Specify URI of accessible Kotlin Distributable in case it's not accessible from the Central Maven Repository.
							url "https://dl.bintray.com/kotlin/kotlin-eap-<version>"
						}
					}

					// ...

		Compilation: Kotlin will convert <name>.kt Kotlin Files into <name>Kt Class Files when it detects during Compilation some Top-Level Functions inside.

	Commands:
		# Kotlin
			set KOTLIN_HOME

			# Start Interactive REPL:
			kotlinc

			# Generate Class File from Kotlin Files:
			kotlinc <kotlin-file> ...

			# Compile JAR File:
			kotlinc <kotlin-file> ... -include-runtime -d <jar-name>.jar

		# Java
			# Run generated Class File with Java:
			java -cp .;<kotlin-runner-JAR-path> <generated-class-file-without-extension>

			# Run generated JAR File in Java:
			java -jar <jar-name>.jar
	
