Web Dev:
	Abbreviations:
		HTTP:					HyperText Transfer Protocol.

		URI: 					Universal Resource Identifier.
		URL:					Universal Resource Locator.

		JSON:					Javascript Object Notation.
		
		RPC:					Remote Procedure Call.
		SOAP:					Simple Object Access Protocol.
		XML:					EXtensible Markup Language.
		WSDL:					Web Services Description Language.

		RMI:					Remote Method Invocation.

		REST: 					Representational State Transfer.

		SPA:					Single Page Application.

		HTTPS:					HyperText Transfer Protocol Secure.
		CSP:					Content Security Policy.
		CORS:					Cross Origin Resource Sharing.
		CSRF:					Cross Site Request Forgery.
	
	Concepts:
		Web Site:				A Service hosted on the Web - meant for Humans.
		Web Service:			A Service hosted on the Web - meant for Applications.

		Web Application:		Generic Term for either a Web Site or Web Service.

		Web Server:				A running Process that listens for incoming Requests for information over the Web and sends back Responses.
		App Server:				Hosts and Exposes Business Logic and Processes.

		URL:					A String that specifies the location of a Resource / Site / Service on the Web. Consists of:
			Protocol:			The Protocol used to specify the communication mode with the Server.
			Host and Domain:	The Entity that the Server is running on, and the Administrative Space the Entity is in.
			Port:				The Network Port used to interact with the Server Process that is running on the Host.
			Path:				The part that points to a Resource within the Host (i.e. one or more of {"/<simple>" | "/:<parameter>" | "/:<parameter><regex>"}).
			Query:				Optional appended String to the Path that represents URL Arguments in Key-Value Pairs (i.e. <path>/?<key>=<value>& ...).

		Origin: 				Protocol + Host + Domain + Port.

		HTTP Request Methods:
			Create / POST 
				Status Code: 
					Success - 201 Created
					Fail - 400 Bad Request
			Read / GET
				Status Code: 
					Success - 200 OK
					Fail - 404 Not Found
			Update Entire / PUT
				Status Code: 
					Success - 200 OK
					Fail - 404 Not Found
			Update Partial / PATCH
				Status Code:
					Success - 200 OK
					Fail - 404 Not Found
			Delete / DELETE
				Status Code: 
					Success - 204 No Content
					Fail - 404 Not Found

			Safe Request Type:	HTTP Request Types which do not cause Side-Effects on Server State.
			Idempotent Request Type: HTTP Request Types which, if applied multiple times, have the same result as when it is applied only once.

		Routing: 				The process of using URLs to determine the part of the Web Application exposed to the User. Traditionally handled Server-Side.

		JSON:					A readable implementation-independent Data Interchange Format.
		XML:					A readable implementation-independent Data Interchange Format.

		SOAP:					Messaging definition for the interaction between Web Services.
		WSDL:					XML File that describes the Web Service it details (Methods, Arguments, Return Types, etc.).

		Cookie:					A Key-Value Pair Data Structure used to store persistent Session State on the Browser when using Stateless HTTP, set via 'set-cookie' HTTP Response Headers. Each Field Attribute consists of:
			Name:				Field Key.
			Value: 				Field Value.

			Domain:				Determines which Domain can access the associated Field.
			Path:				Determines which part of the Web Application is allowed to access the associated Field.
			Expires / Max Age: 	Determines validity lifespan of the associated Field.
			Size:				Number of characters for associated Field Name and Value.

			// Security-Related Fields:
			HTTP / HttpOnly:	Prevents Client-Side manipulation of the Cookie via JS and other vectors - the Cookie is only used for Server-Side meta-session activity.
			Secure:				Only transmit the assosicated Field over HTTPS.
			SameSite:			Prevents the Response of a Request from being read in another Domain.

		CSP: 					A backwards-compatable HTTP Response mechanism that allows a Web Application to specify the acceptable types and sources of Resources that can be used by the Client for the Web Application's Resource currently loaded. This allows increased flexibility from the default Same-Origin only policy whilst still preventing the Web Application from inadvertedly loading malicious Resources from a Third-Party, and is helpful in mitigating Injection Attacks, particularly XSS.
			The Web Application defends against being compromised by its own activity.
	
		CORS:					A HTTP Response mechanism that allows a Web Application running on one Origin to dictate to Clients which Third-Party Resources from different Origins can access its Resources, and how they can do so. This allows increased flexibility from the default Same-Origin only policy whilst still preventing unauthorized Third-Parties from potentially doing something malicious to the User with respect to the Web Application.
			The Web Application defends against being compromised by the activity of other Web Applications.

			Pre-flight Request: The requesting Client should send a prior HTTP Request to determine the Web Application's allowance for the actual HTTP Request, before sending the actual HTTP Request (which may cause side effects to the Server - HTTP Methods other than GET, or POST with certain MIME Types). This also gives the Server a chance to specify that the Client should send over credentials as part of the HTTP Request.

		Caching: 				Browsers have the option to store a Local Copy of a Requested Resource so that it need not execute another Network Request to the Server for the same Resource needlessly in the future.
			Fresh Resource:		A Local Copy is said to be Fresh when its age is below the set Expiration Time.
			Stale Resource: 	A Local Copy is said to be Stale when its age is above the set Expiration Time.

		Cache Invalidation:  	To force the Browser to discard their Local Copy of a Resource, and to Request it again from the Server.
		Cache Eviction:			To remove some Local Copies and free up space for other Resources.

		Above-the-Fold Content:	Content in the Web Application that would be initially in view in the Browser's Viewport.
		Below-the-Fold Content:	Content in the Web Application that would be outside of the view in the Browser's Viewport.

		Attachment:				The performance heavy Browser-level process of combining the Browser DOM Tree with a re-calculated CSSOM Tree to create a Render Tree. This is invoked whenever the Browser DOM Tree changes.
		Layout:					The synchronous Browser-level process of the exact coordinates of DOM Nodes onto the Browser Screen via the information stored in the Render Tree, once Attachment is done.
		Painting:				The Browser-Level process of using the Layout and the Render Tree to display what is needed on the Browser Screen.

	Details:
		Summary of Full-Stack:
			The Front-End of a Web Site or Application consists of the HTML, CSS, JavaScript, and static assets sent to a Client, like a Web Browser.

			A Web Server is a running Process that listens for incoming Requests for information over the Web and sends back Responses.

			The Server-Side of a Web Application, sometimes called the Application Server, handles important tasks such as Authentication and Authorization.

			The Back-End of a Web Application often has a Web API which is a way of interacting with an Application’s Data through Requests and Responses.
				Creating, Reading, Updating and Deleting Data is a large part of a Web Application’s Back-End. Operational Processes record Data to Databases via Transactions, and may be accessed from Databases or Data Warehouses.

			Together the technologies used to build the Front-End and Back-End of a Web Application are known as the Stack, and many different Languages and Frameworks can be used to build a robust Back-End.

		Architectural Considerations:
			Web Service Secrets: Do not store Secrets (i.e. API Keys) in things which are sent to Users. Instead, make your FE request related information from the BE, and try to control usage from BE.

			REST: An Architectural Style to facilitate cleaner communication and interaction between Systems via the Web.
				Background:
					The core problem is that in the past, it was only necessary to facilitate communication between a small group of Machines in the Business' Local Network to operate. However, it has become increasingly necessary to talk to Machines outside of the Business Network (i.e. other Businesses, etc).

					When HTTP was designed, it was with the intention to allow for communication between Machines anywhere in the world.

				Exposition:
					The idea is to represent Concepts / Resources / Nouns as URLs. Any other related Concepts / Resources / Nouns are also stored as URLs. Machines can then use HTTP with the URLs to reach other Machines elsewhere and perform operations on the Concepts / Resources / Nouns.
						Example:
							http://MyRestaurant:8080/Orders/Order?OrderNumber=asdf (POST: {Tacos object})
							http://MyRestaurant:8080/Orders/Order?OrderNumber=asdf (GET)
							http://MyRestaurant:8080/Orders/Order?OrderNumber=asdf (PUT: {Pineapple Tacos object})

						The combination allows for a standardized way of communication between all Entities to refer to things.
							URLs used per API Call can be the same, but the accompanying HTTP Verbs used would result in different effects.

						If the URL contains a Verb, it is an indicator that that URL does not represent a Concept / Resource / Noun.

					Additionally, on the premise that all Web Applications only require 4 Universal Verbs to operate on all things successfully:
						POST: Accompanying Data is used to modify the Resource represented in the given URI, following the rules documented by the Resource Type.
						PUT: Replace the Resource represented by the given URI, if anything.
						PATCH: Apply this Diff to the Resource, if the Resource has the same State as it did the last time it was queried.
						
						Create / POST
						Read / GET
						Update (Replacement) / PUT
						Update (Partial-Update) / PATCH
						Delete / DELETE

					The structure of the information in the Application has been mapped directly onto a structure of HTTP URLs, using only standard HTTP operations that allow for HTTP body content.

				Pros:
					No additional Special Handler required on Client and Server, since HTTP is widely supported. This makes it suitable for external APIs.
						Standardized HTTP Operations help in making consistent API.

					Loose Coupling between the Client and the Server in terms of the API Contract, as the URLs are an additional layer of abstraction.

					Each Request / Response is complete. All information that the Server requires to process the Client's Request is in the HTTP Request, and that the Client would get all other related information or Resources of the requested Resource from the Server alongside the original Client Request as part of the HTTP Response.
						Statelessness: No need to keep Session State as a result of the above.
							Scalability.
							Cacheability.

				Cons:
					Requires in-depth HTTP knowledge.
					Less Performant with a complex underlying Protocol Layer to get through.
			
			RPC: A Mechanism that models Communication between two Processes as straightforward Procedure / Function Calls to exchange Data.
				Background:
					RPC formed the basis for SOAP, which used XML Schema and WSDL to indicate what the Data should contain, and where it should go.

					RMI is closely related to RPC, but uses Object-Oriented control to execute. This is prevalent in Java.

				Exposition:
					An RPC Mechanism usually defines a Network Protocol, some Format for exchanging Messages, a portable way of serializing and deserializing Data and specific Programming Language support (like Code Generators).

					It typically involves generating some Function Stubs on the Client Process that makes the Function Call appear local, but behind the stub is logic to marshall the Request and send it to the Server Process.
					The Server Process then unmarshalls the Request and invokes the actual Function before repeating the process in reverse to send whatever the Function returns back to the Client Process. 
					
					RPC's Function Calls are more akin to Verbs representing Operations to perform on Resources. This differs from REST, in which each URL represents a Concept / Noun / Resource.

				Pros:
					Does not require in-depth HTTP knowledge to implement (e.g. every HTTP Request would either be a GET or POST Request).
					Performant without any complex underlying Protocol Layer to get through.

				Cons:
					Special, non-standard Handler required on both Client and Server, which makes RPC more suitable for internal APIs.
						High Coupling between the Client and Server in terms of the API Contract.
						
					Client would need to know how to entirely handle the Response given by the Server.

				The modern gRPC framework provides additional features:
					Protobuff vs JSON: Protobuff is a more performant alternative to the JSON format.
					Client-Initiated Duplex Streaming Capability vs Request-Response: As a result of leveraging on HTTP 2.0.
					Strong-Typing vs Serialization for Payload Data.
					In-Built Load Balancing.

			SPA: An Application Style that controls Application Routing through Client Side JavaScript.
				Background:
					Before SPA, Applications had to be split up between different HTML, CSS, and JavaScript Files with regards to the Frontend Resources.
						This meant that Clients would have to repeatedly Request Resources each time they accessed a different part of the Application.

					With the advent of Bundlers, it is now possible to send the entirety of the Application Frontend Resources over to the Client with one Request-Response.
						Clients see different parts of the Application through simulation via JavaScript, even if they are just accessing the same Frontend Resources.

			Micro-Frontend: An Application Style that allows for the consolidation of separate SPAs into Frontend Resource. Can be seen as a "Single-SPA" approach.

		Web Security:
			OWASP:
				CSRF:
					Example: Email with HTML Content is received and read by a User that is currently logged on to <some-important-site>.
						<img src="https://<bank-site>/api/transfer?recipient=<malicious-id>&amount=1000" />

			HTTP Headers:
				// Sending Credentials over to the Server:
				// Note: Use HTTPS as base-64 Encoding can be reversed.
					// Client-Request Headers:
						Authorization: <type> <base-64 username:password string>

				// HTTPS Only:
				// Tip: Should be supplemented with automatic redirects to HTTPS connections if a Client attempts to load a URL with the regular HTTP protocol.
					// Server Response Headers:
						Strict-Transport-Security:
							max-age=<expire-time> // The time in seconds that the Client should remember this Strict-Transport-Security configuration for this Site.
							includeSubDomains // Optional Flag to indicate if this rule should apply to sub Network Domains as well.

				// CSP:
					// Server Response Headers:
						Content-Security-Policy: <policy-directive>; ...
							// Tip: The more <policy-directive>s specified (including duplicated directives), the more restricted it becomes.
							
							// Policy Directives
								default-src: <source> [<source>]; // Can be seen as a fallback for other Directives if they are not specified. Specify this at the beginning of the Content-Security-Policy Directive string.
									'self' // Specify that all Resources should only originate from the Web Site's own Origin.

								script-src: <source> [<source>]; // Specify the source of JS Resources.
									'self' // Specify that all JS Resources should only originate from the Web Site's own Origin.

									// The following dangerous sources allow for more flexibility, but also increasing degrees to which XSS Attacks can be conducted.
									'unsafe-hashes' // Danger: Allow processing of inline HTML Event Handlers.
									'unsafe-inline' // Danger: Allow processing of inline JS Resources.
									'unsafe-eval' // Danger: Allow processing of JS code specified within Strings.

				// CORS:
					// Reminder: Source (Third-Party) Web Application -> Requesting Resource -> Client -> Request -> Web Application -> Requested Resources.

					// Pre-Flight:
						// Client Request Headers:
							Origin: <url> 
								// Sent by the Client to primarily indicate to the Server the identity of the Source Web Application whose Requesting Resource has made the HTTP Request.
								// Forbidden Header - cannot programmatically change this.
							
							Access-Control-Request-Method: <HTTP-method>
								// Inform the Server the type of interaction the requesting Resource on the Client would want to do with the Requested Resources.
								// Additionally serves to notify the Server that this HTTP Request (along with the OPTIONS HTTP Method specification at the top of the HTTP Request) is a Pre-Flight HTTP Request.
							
							Access-Control-Request-Headers: <custom-HTTP-header>, ... // Specify any custom HTTP Request Headers that the Requesting Resource on the Client might additionally send over.

						// Server Response Headers:
							Access-Control-Allow-Origin: { * | <origin> } // Specify allowed Source Web Applications that can access the Requested Resources.
								// If the allowed Origin is specific, the Server should additionally include a 'Vary' HTTP Response Header to indicate to the Client that the Server Response will differ based on different Origins.

							Access-Control-Allow-Methods: <HTTP-method> // Specify the allowed HTTP Methods that the Server will handle under CORS.

							Access-Control-Allow-Headers: <[custom]-HTTP-header>, ... // Specify any additional custom HTTP Headers (custom or the default CORS safelisted ones) that the Server will accept during a CORS Interaction.

							Access-Control-Max-Age: <delta-seconds>, ... // Indicate the length of time that the results of the CORS Preflight Request can be cached on the Client for, afterwhich another Preflight Request would need to be sent.
								// Note: Certain Browsers will have a maximum Internal Value that they will use instead of the specification if it is longer than the Internal Value.

							Access-Control-Allow-Credentials: true // Specify if the actual HTTP Request can be made using supplied Credentials.

					// Actual:
						// Server Response Headers:
							Access-Control-Expose-Headers: <[custom]-HTTP-header>, ... // Specify any additional custom HTTP Headers (custom or the default CORS safelisted ones) that the Server will allow Requesting Resources on Clients to access programmatically.

							Access-Control-Allow-Credentials: true // Specify that Credential Cognizant Content for the Web Application should be exposed to the Requesting Resource on the Client, in the scenario where the Requesting Resource of the Source Web Application has enabled the 'withCredentials' Flag in their HTTP Request.
								// Usually the Client will handle the Credential Cognizant Content, and direct accesses by loaded Resources to the Authentication Information will be blocked. Specifying this will allow the Requesting Resource on the Client to be able to access the Credential Cognizant Content. 

								// Note: This also requires that the Access-Control-Allow-Origin Header have a specific <origin> value, rather than the '*' wildcard.

								// Tip: Omit this if it should not be exposed.
					
			Cookie Configuration: See the Security-Related Fields section of the Cookie concept above for more exposition on each Field listed below.
				HttpOnly
				Secure
				SameSite

		Caching:
			HTTP Headers:
				// Server Response Headers:
					ETag: '<resource-id>' // Something that uniquely identifies the Resource. Often a Content Hash of the Resource is generated and used by the Server for this purpose.

					// Note: Multiple Cache-Control Directives can be listed in separate lines in the HTTP Response.
					Cache-Control:
						no-store // Indicate to the Browser that the Requested Resource should never have a Local Copy made for future reference (i.e. always Request the Resource from the Server).

						no-cache // Indicate to the Browser that the Requested Resource can have a Local Copy made for future reference, but with each reference, to check with the Server (with the ETag stored with the Local Copy). A smaller 304 Network Response is sent from the Server to indicate that the Requested Resource has not changed from the last time, and that the Local Copy can still be used.

						must-revalidate // Indicate to the Browser that the Requested Resource can reference a prior Local Copy, but must revalidate when the Local Copy becomes Stale.

						private // Indicates that Caching should only occur on Browsers.
						max-age=<seconds> // Determines the duration in which a stored Local Copy by the Browser is considered Fresh, and can be referred to correctly. The recommended value is 1 year.

						public // Indicates that Caching can occur on Shared Caches (i.e. CDN).
						s-max-age=<seconds> // Determines the duration in which a stored Local Copy by Shared Caches is considered Fresh, and can be refered to correctly.
					
			Revving: An approach to change the name (and hence, the URI) of the Resource, each time it is changed. This helps with correct Cache Invalidation of the Resource itself, as well as other Resources that use it (so that Stale Local Copies are not used together with Fresh Local Copies).
			
		Debugging Tips:
			If the Network Request is stuck on Pending, it might mean that there is an infinite loop in the UI Layer.
		