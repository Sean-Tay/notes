Kotlin
	Abbreviations:
		
	
	Description: Programming Language that is compatable with Java, and can target JVM and JavaScript Environments. Designed by JetBrains to be a "better" Java.
	
	Resources: 
		Generic Types: https://typealias.com/guides/illustrated-guide-covariance-contravariance/
		Coroutines: https://proandroiddev.com/understanding-kotlin-coroutines-a-deep-dive-into-blocking-vs-non-blocking-and-concurrent-vs-7667dfe77fbb
	
	Concepts:
		Coroutines: Unit of Suspendable Concurrent Execution.

		JAR Files: Java Archive. Contains Libraries, Resources and Assets.
		WAR Files: Web Application Archive. Contains the Web Application in a specific structure that can be deployed on any Web Container / Java Application Server.

	Details:
		Features:
			Functional Programming.
			Immutability Support.

		Syntax:
			Types:
				// Primitive Types:
					Any?

					Character
					String

					Number
						Double 		// 15-16 Decimal Places
						Float 		// 6-7 Decimal Places

						Byte		// -ve 2^7 to +ve 2^7 - 1
						Short		// -ve 2^15 to +ve 2^15 - 1
						Int			// -ve 2^31 to +ve 2^31 - 1
						Long		// -ve 2^63 to +ve 2^63 - 1

					Boolean

					Unit // Void Type for Functions that don't return anything.
					Void // Void Type from Java.
					Nothing // Analogous to never Type in TypeScript

				// Nullable Type:
					<type>?

				// Function Type:
					typealias <function-type> = (<arg>: <arg-type>,  ...) -> <return-type>

				// Suspendable Function Type:
					suspend (<arg>: <arg-type>, ...) -> <return-type>

				// Utilities:
					// Runtime Type Checking:
						// Note: Boolean Expression.
						<value> is <type>
						<value> !is <type>

					// Runtime Type Casting:
						<value> as <type> // Unsafe - will throw Exception upon failure
						<value> as? <type> // Silent - will return null upon failure

					// Reflection:
						// Note: Reflection has a heavy Performance Penalty.
						// Tip: Use Reflection to find out the Type of a Variable during Runtime:
							println(<variable>!!::class.simpleName)
							println(<variable>!!::class.qualifiedName)

						// Function Reference:
							val kFunction: KFunction<<kotlin-function>>

						// Class Reference:
							val kClass: KClass<<kotlin-class>> = <kotlin-class>::class

							// Tip: Get the underlying Java Class from a given Kotlin Class
								<kotlin-class>::class.java 

							// Tip: Get the Kotlin Class that corresponds to a Java Class
								<java-class>.javaClass.kotlin

						// Class Property Reference:
							// Note: The number after 'KProperty' represents the number of Parameters accepted.
							val kProperty: KProperty0<<property-value-type>> = <kotlin-class>::<property>

							// Example: Type Narrowing of a Nullable Class Property
							fun <N: Any> <name>(<arg-name>: KProperty<*: N?>): N {
								// ...
							}
					
			// Package Declaration: Defines which Package the File belongs to.
				// Note: Common Prefixes among the Files can be omitted from the Folder Structure (i.e. no need create such a deep nesting).
				package <path>. ...

			Constants:
				val <runtime-constant-name>: <type> = <value>;

				// For Properties known at Compile Time:
				// Tip: Faster Performance.
				const val <compile-constant-name>: <type> = <value>;

			Ranges:
				// val range: ClosedRange<Int>
				val range: IntRange = <inclusive-min> .. <inclusive-max> [step <step>]
				val range: IntRange = <inclusive-min> until <exclusive-max> [step <step>]

				range
					.first 		// Get First Value within the Range
					.last 		// Get Last Value within the Range
					.step		// Get Step Amount for the Range

					.reversed()	// Reverse the Order of the Range
					.filter <lambda>
					.map <lambda>
					.reduce <lambda>

				// range for loops
				for (i in <range>) {
					// ...
				}

			Variables:
				var <variable-name>: <type> = <value>;

			Strings:
				// Note: Use Double Quotes to define String Values; Single Quotes define Character Values.

				// Multiline Strings:
				val multiline = """
				<text>
				...
				""";

				val multiline = """
					<indented-content>
					...
				""".trimIndent();

				// Templates:
					// Simple: For just referencing Values / Variables
					val i = <value>;
					val string = "$i ...";

					// Expression: For referencing the result of an Inline Expression
					val string = "${ i + 5 } ...";

			Collections:
				// Iterables
					// Stable Sort
					<iterable-instance>.sortedWith(
						{ compareBy | compareByDescending } <<type>> { it.<field> }
							.{ thenBy | thenByDescending } { it.<another-field> }
					)

				// Lists
					val mutableList: MutableList<<type>> = mutableListOf( <item>, ... )
					val list: List<<type>> = listOf( <item>, ... )

					mutableList.size

					mutableList.add( <new-item> )

				// Maps
					val mutableMap: MutableMap<<key-type>, <value-type>> = mutableMapOf(
						<key> to <value>,
						// ...
					)
					val map: Map<<key-type>, <value-type>> = mapOf(
						<key> to <value>,
						// ...
					)

					mutableMap.keys
					mutableMap.values

					mutableMap.getOrDefault( <key>, <value> )
					mutableMap.putIfAbsent( <key>, <value> )

					map.contains( <potential-key> )
					map.get( <key> )

				// Streams: Used for Function-Oriented Processing of Immutable Element Sequences obtained from a Collection.
					val stream = <collection>.stream()

					stream
						.forEach
						.map
						.filter

						// ...

			Objects:
				// Note: Lazily Initalized only during the first access.
					// Tip: Effectively Singleton Classes:
					object <object-name>: <interface-type> {
						// ... Class-Compatable Member Declarations here ...
					}

			Interfaces: Used to declare Public API for Implementing Constructs.
				interface <interface-name>: <parent-interface>, ... {
					fun <function-name>(<arg>: <type>, ... ): <return-type>
					suspend <function-name>(<arg>: <type>, ... ): <return-type>

					// ...
				}

			Classes:
				// Note: Classes can omit the Curly Braces if the Class has no Body.

				// Data Class: Classes meant to describe Objects that just hold Data. Analogous to POJOs.
					// Note: Cannot allow Overridance.
					// Tip: Kotlin will automatically define a default 'equals', 'hashCode', 'copy' and 'toString' Utility Methods for the created Data Class if there are no explicit definitions for those Methods in the Class Body.
					// Tip: Properties on a Data Class Instance can be Deconstructed via Spreading.
					data class <data-class-name>( { val | var } <property>:<type> = <default-value>, ... ) {
						// Note: Properties declared in the Body of the Data Class will not be considered during the invocation of the automatically generated Utility Methods mentioned above.

						// ...
					}
						// Tip: For Instances of Immutable Data Classes, use the 'copy' Method to avoid having to copy every unchanged Property if the Instance is to be 'updated'.

				// Annotation Class:
					// @<meta-annotation>
					// ...
					annotation class <annotation-class>( ... )
						// @<meta-annotation>s
							// @Target - Specifies which Code Elements the Annotation Class can be used on via AnnotationTarget Enum
							// @Retention - Specifies whether the Annotation should be stored alongside a .class File and whether it should be visible for Reflection.
							// @Repeatable - Specifies if the Code Element can have multiple Instances of the Annotation Class attached to it.

					// ...

					// Processing:
						<target-class>::class.<code-element>.annotations: List<Annotation>
							// <Annotation>
								// .annotationClass - Gets the Kotlin Class via Reflection.

				class <class-name>[{ public | internal | private } @<annotation> constructor](
					// Primary Constructor / Default Constructor
					// Note: Preceding 'constructor' Keyword needed if the Constructor has Visibility Modifiers or Annotations
					
					// Constructor Parameters
					// Note: Not creating a new Property in the Class, but rather allowing Constructors / Initialization Blocks to access a Value which can be used to initialize other Properties.
					<parameter>:<type> = <default-value>, ...

					// Instance Properties
					// Note: Creates a new Property on the Class.
					{ public | internal | private } { val | var } <property>:<type> = <default-value>, ...
				) {
					// ...

					// Declaring additional Class Properties / Initialize:
					var <property>:<type> = ... ;
						<{ private | internal | public }> get() = {
							// 'field' keyword to reference <property>
							// 'this' to reference Class Instance
						}
						<{ private | internal | public }> set() = {
							// 'field' keyword to reference <property>
							// 'this' to reference Class Instance

							// Note: Do NOT use this.<property> to set the <property> Value as it becomes an Infinite Loop.
						}

					// Initialization Block: For Code to be run during Object Instantiation.
					// Note: Executed in the order they are declared in.
					// Tip: Don't need explicit init Block for Class Properties initialized above inline.
					init {
						// ...
					}

					// Secondary Constructor:
					// Note: If there is a non-default Primary Constructor, the Secondary Constructor will have to delegate to it.
					// Note: Therefore, code from Primary Constructors, Property Initializers and Initialization Blocks are executed before Secondary Constructors.
					// Tip: Prefer Default Values in the Primary Constructor as opposed to Secondary Constructors.
					// Tip: If some logic is needed before the delegation, consider using the Alternative Secondary Constructor in the companion object below.
					constructor(
						// Note: Specifying 'val' or 'var' here for Parameter Properties will not be correct for those already specified in the Primary Constructor.
						... 
					): this( ... ) {
						// ...
					}

					// ...

					// Companion Objects:
					// Note: Replaces Static Class Members.
					companion object [<c-object-name>]: <interface-type> {
						// ...

						// Mark the following Method as a Static Method for the JVM
						@JvmStatic
						fun <function-name>( ... ) { ... }

						// Alternative Secondary Constructor:
						operator fun invoke( ... ): <class-name> {
							return <class-name>( ... )
						}
					}

					// Accessing Companion Objects within Classes:
						// If Companion Object was not given a Name:
						<class-name>.Companion

						<class-name>.<c-object-name>

					// Lazily-Initialized Property:
					val <variable>:<type> by lazy { <initializaton-code> }

					// ...
				}

				// Interface Implementation:
					class <implementing-class-name> ( ... ): <interface>, ... {
						override fun <interface-function-name> ( ... ) { ... }
						override suspend fun <interface-function-name> ( ... ) { ... }

						// ...
					}

				// Inheritance:
					// Note: Classes are treated as 'final' or Non-Inheritable by default.
					// Mark a Class as Inheritable by Sub-Classes via the 'open' Keyword.
					// Note: Sub-Classes must provide Arguments for the Inheritable Class's Parameter Properties, if any.
					open class <inheritable-class-name>() {
						// Mark a Class Property as Overridable by Sub-Classes via the 'open' Keyword.
						open val <property>:<type>;
					}

					// Note: Sub-Classes must have only one Parent, but they can implement multiple Interfaces.
					// Note: Sub-Classes must provide Arguments for the Inheritable Class's Parameter Properties, if any.
					class <sub-class-name>(
						// Note: Specifying 'val' or 'var' here for Parameter Properties will re-create the Inherited Property within this Sub-Class, rather than just passing it to the Base Class.
						... 
					): <inheritable-class-name>( ... ), <interface-name>, ... {
						// Override Property from <inheritable-class-name>:
						// Note: Overriden Properties are themselves considered Overridable by any Sub-Class. Use the 'final' Keyword to prevent Overriding.
						// Note: In the event of Multiple Inheritance with Common Class Properties, it is required to Override these to eliminate ambiguity.
						[final] override val <property>;

						// Access <inheritable-class-name> Implementation via the 'super' Keyword.
						// Note: In the event of Multiple Inheritance, define which <inheritable-class> 'super' refers to via:
						super<<inheritable-class>>

						// Note: Inherited Constant Properties can be changed to Variable once Overriden.
						override var <property>:<type>;

						// Note: Inherited Function Properties cannot have their default Argument Values changed when Overriding.
					}

				// Delegation: Allows usage of a secondary Class to fulfil part of a Class' API.
					interface <interface-name> {
						fun <example-function>( ... ): <return-type>
					}

					class <delegate-class>( ... ) : <interface-name> {
						override fun <example-function>( ... ) = {
							// ...
						}
					}

					class <delegating-class>(private val <delegate>: <interface-name>) : <interface-name> by <delegate> {
						// ...
					}

				// Instantiate a Class Instance:
					// Note: No 'new' Keyword.
					val instance = <class-name>();

			Enums:
				enum class <enum-name>[ (val <value-arg>: <value-arg-type>) ] {
					<key>[ (<value-arg>) ],
					// ...
				}

				// Tip: Kotlin Enums are instances of the Enum Class, so the usual Class Syntax and Features can also apply.
				// Note: Enum Classes cannot inherit from other Classes.
				enum class <enum-name>[ (val <value-arg>: <value-arg-type>) ]: [ <interface-name>, ... ] {
					<key> {
						// Anonymous Class
						// ...
					},
					// ...
					<key> { 
						// ...
					}; // Separate the Constant Definitions from additional Class Members with a Semicolon.

					// ... Class Members ...
				}

				// Note: If the String representation of the <key> requires spaces, it might be better to set and use the <value> of the Enum as the desired String representation of the <key> instead.
				// Getting the <key> as a String for a given <enum-name> instance:
					<enum-name>.<key>.name()

				// Getting the corresponding <enum-name> instance for a <key> in String form:
					<enum-name>.valueOf(<key>)

			Operators:
				// Structural Equality Comparator: 
					// Check if two Values are equivalent: ==
					// Check if two Values are NOT equivalent: !=

				// Referential Equality Comparator: 
					// Check if two Values are equivalent and refer to the same Entity: ===
					// Check if two Values are neither equivalent, nor refers to different Entities: ===

				// Elvis Operator: 
					// Nullish Coalescing - evaluates <expression-1> and returns the result if it is not null, otherwise <expression-2> will be evaluated.
					// Tip: Avoids double-evaluation of <expression-1>.
					<expression-1> ?: <expression-2>;

				// Spread Operator: 
					*
						// Note: Only usable when passing in Arguments to a varargs Function.
						*<array-variable> // Spreads out <array-variable>

					val ( <property>, ... ) = <data-class-instance>

			Functions: First-Class Citizens. Higher-Order Functions possible.
				// Note: Functions with Block Body (Curly Braces) must explicitly define their <return-type>.
				// Note: <function-name> can be a String Template as well.
				fun <function-name>(<arg>:<type>, ... , <optional-arg>:<type> = <default-value>, ... ): <return-type> {
					// ...

					return <value>: <return-type>;
				}

				// Note: Main Function determines Execution Entry-Point for Program.
					fun main(args: Array<String>) {
						// ...
					}

				// Function with variable number of Arguments:
					fun <function-name>(vararg <arg-name>: <individual-arg-type>): <return-type> {
						// Note: <arg-name> will be an Array Type.
						// ...
					}

				// Function with a Function Argument:
					fun <function-name>(fnArg: <function-type>): <return-type> {
						// fnArg( ... )
					}

					// Passing an Instance of the <function-type> when calling <function-name>:
						val <some-function>: <function-type> = ( ... ) -> {
							// ...
						}

						<function-name>([<some-function-package-scope>]::<some-function>)

				// Single-Expression Function: Curly Braces can be omitted.
					fun <function-name>(<arg>: <type>, ...): <return-type> = <expression>

				// Inline Function: To allow the Compiler to inject the Code inside the Function directly at the Call Site.
					// Tip: Can improve performance where Closures are not needed.
					inline fun <inline-function-name>(<arg>: <type>, ...) {
						// ...
					}

				// Lambda Expressions / Function Literals / Arrow Functions:
					// Note: The Curly Braces are needed to obtain an Instance of the Lambda.
					val <lambda>: (<type>, ... ) -> <return-type> = {
						<arg>, ... -> 
							// Note: Function Body of a Lambda requires no Curly Braces.

							// ... 

							// Note: Last Expression in a Lambda is treated as a Return Expression.
							<return-expression>
					}

					// Lambdas with only one Argument
					val <lambda> = {
						// 'it' will refer to the Parameter
						// ...
					}

					// Lambdas with no Arguments
					val <lambda> = {
						// ...
					}

					// Tip: If the last Argument to a Function Call is a Lambda, it can be omitted from the Argument List during the Call.
					<calling-function>(<arg>, ... ) { <arg>: <type>, ... -> // ... }

					// Tip: If the sole Argument to a Function Call is a Lambda itself, the Parenthesis can be omitted entirely during the Call.
					<calling-function> { <arg>: <type>, ... -> // ... }

					// Tip: If the sole Argument to a Function Call is a Lambda with only one Argument, the following shorthand can be used:
					<calling-function>(::<lambda>)

					// Note: Withn Inline Functions, return statements from Lambdas will exit the Inline Function rather than the Lambda itself.
					// Tip: Use a Label to return the Lambda itself:
					lit@ {
						// ... 

						// if (<boolean-expression>) return@lit <return-value>;

						// ...
					}

				// Anonymous Function: 
					fun (<arg>: <type>, ... ): <return-type> = // ...

			Generics:
				// Declaration Site Variance:
					// Invariant Types: Generic Types with no specified Upper or Lower Bounds. Once such a Type is inferred for <invariant-generic-type>, all other places where <invariant-generic-type> appears must be of that Type.
						// Functions:
							fun < <invariant-generic-type>, ... > <function-name>( <arg>: <invariant-generic-type>, ... ): <invariant-generic-type> {
								// ...
							}

						// Classes:
							class <parameterised-class>< <invariant-generic-type>, ... >( private val value: <invariant-generic-type>, ... ) {
								fun get(arg: <invariant-generic-type>): <invariant-generic-type> {
									return value
								}
							}

					// Type Bounding: Via the 'where' Keyword.
						// Note: If a <generic-type> has multiple Bounds, that means that the Concrete Type passed in must fulfill all Bounds.

						// Functions:
							fun < <generic-type>, ... > <function-name>( arg: <generic-type>, genericArg: <another-generic-type><<generic-type>>, ... ) where <generic-type>: <type>, <generic-type>: <another-generic-type><<generic-type>>, ... {
								// ...
							}

						// Classes:
							class <class-name>< <generic-type>, ... >( arg: <generic-type>, genericArg: <another-generic-type><<generic-type>>, ... ) where <generic-type>: <type>, <generic-type>: <another-generic-type><<generic-type>>, ... {
								// ...
							}

						// Star Type Bounding: For when the Type does not actually matter (not the same as bounding by Any). Variables of Star Types are Read-Only.

					// Covariant Types: Cannot be used in Parameter Types (i.e. only "out" Positions such as Return Types), but allows for Types to be assigned to a Supertype Reference in the Invoking Code.
						// Classes:
							class <parameterised-producer-class>< out <covariant-generic-type>: <upper-bound-super-type>, ... >( private val value: <covariant-generic-type>, private val genericValue: <another-generic-type><<covariant-generic-type>>, ... ) {
								fun <producing-function>(): <covariant-generic-type> {
									return value
								}
							}

							val parameterizedProducerClass = <parameterised-producer-class><<sub-type>>( ... )

							// parameterizedProducerClass.<producing-function>() will return the <sub-type>, which can be cast to the <super-type> when done through ref.
							val ref: <parameterised-producer-class><<super-type>> = parameterizedProducerClass

					// Contravariant Types: Cannot be used in Return Types (i.e. only "in" Positions such as Parameter Types), but allows for Types to be given a Subtype Reference in the Invoking Code.
						// Classes:
							// Note: Contravariant Argument Types are not supported when Overriding a Class Method to support Method Overloading, but Functions can be assigned as Class Properties as a workaround.
							class <parameterised-consumer-class>< in <contravariant-generic-type>: <upper-bound-super-type>, ... >( ... ) {
								fun <consuming-function>(value: <contravariant-generic-type>): ... {
									// ...
								}
							}

							val parameterizedConsumerClass = <parameterised-consumer-class><<super-type>>( ... )

							// parameterizedConsumerClass.<consuming-function>( ... ) will accept the <super-type>, so sending in a <sub-type> is still correct when done through ref.
							val ref: <parameterised-consumer-class><<sub-type>> = parameterizedConsumerClass

				// Type Projection:
					// Covariant Type Projection: Allow for Types to be assigned to a Supertype Reference in the Invoking Code via "out", but converts all Parameter Types involved with the Generic Argument Type to be 'Nothing'.

					// Contravariant Type Projection: Allow for Types to be assigned to a Subtype Reference in the Invoking Code via "in", but converts all Return Types involved with the Generic Argument Type to be 'Any?'.

			Control-Flow:
				// Iteration:
					repeat(number) {
						// ... it ...
					}

					for (<value> in <range>) {
						// ...
					}

					for (<value> in <iterable>) {
						// ...
					}

					// Over a Collection:
						<collection>.forEach { key, value -> <code> };

				// If-Else:
					// Note: if-else is an Expression, meaning it can return Values once evaluated.
					val result = if (<boolean-expression>) {
						<result>
					} else if (<boolean-expression>) {
						<result>
					} else {
						<result>
					}
					
					// Single Line:
					if (<boolean-expression>) ? <true-expression> : <false-expression>;

				// Scoping Functions: Useful for embedding logic within Call Chains.
					// let: Useful for executing logic only if the calling <result> is not null.
						<result>?.let {
							// it === <result>
						}

						// Inversion of let:
						<result> ?: run {
							// ...
						}

					// apply / also:
						// Note: apply is used primarily for configuring and modifying the <result> inline
						// Tip: Can be used for the Builder Design Pattern.
						<result>.apply {
							// this === <result>
						}

						// Note: also is conventionally used for side-effects that involve the <result> (i.e. the <result> is not the main focus)
						<result>.also {
							// it === <result>
						}

					// takeIf / takeUnless:
						<result>.takeIf { <lambda-conditional> }?. // ...
						<result>.takeUnless { <lambda-conditional> }?. // ...

					// with
						with(<result>) { // it === <result> }

				// Switch-Case:
					// Note: when is an Expression, meaning it can return Values once evaluated.
					val result = when (<variable>) {
						// Specific Case(s)
						<case-value>, ... -> {
							// ...
						}
						// Specific Conditionals
						<boolean-expression> -> {
							// ...
						}
						// Type Checking
						is <type> -> {
							// ...
						}
						// Default Case:
						else -> {
							// ...
						}
					}
					
					// Tip: when can be used without any <variable>s, which can be seen as a nicer if-else alternative.

			Utilities:
				// Print to Console:
					print("<text>");
					println("<text>"); // With Line Break

				// Execution:
					// Block Execution of the Process by the specified amount of <milliseconds>.
					// Note: Not compatable with Coroutines.
					Thread.sleep(<milliseconds>);

				// Asynchronousity:
					// Suspendable:
						// Suspendable Function: Pausable Function.
						// Note: Only can be invoked in other Suspendable Functions / CoroutineScopes.
							suspend fun <suspendable-function-name>() {
								try {
									// Note: Calling another Suspendable Function will defer execution of this Function.
									<another-suspendable-function-name>()

									// ...

									// Suspend execution of this Function, allowing the Thread to pick up other execution work.
									yield()

									// ...
								} finally {
									// CancellationException is thrown when the Coroutine is cancelled.
									// ... clean up Resources ...
								}
							}

							// Suspendable Lambdas:
							val suspendableLambda: suspend ( ... ) -> <return-type> = {
								// ...
							}

						// Coroutines: A tracked instance of Pausable Computation. Good for non-Blocking Computation.
							// Tip: Creating a Coroutine incurs less overhead than creating a Thread - Kotlin will auto assign Threads from a specified pool to execute one or more created Coroutines.
							// Tip: Consider Coroutines an abstraction over how Threads are used.
							// Note: A given Coroutine may be executed by one or more Threads when it yields - the Thread is not always the same.
							// Note: Parent Coroutines cannot complete until all Child Coroutines complete (following the princple of Structured Concurrency).

							// Types:
								<coroutine-scope>(<optional-coroutine-context>) { ... <coroutine-builder-function> { ... } ... }

								// Coroutine Builder Functions: Only usable from / within a CoroutineScope. Will inherit parent CoroutineScope and modify it.
									// Note: If a Coroutine Builder is not used to run a Suspendable, the Function executes serially.

									// launch 		Creates a Coroutine to execute concurrently, represented by an instance of Job. Used for fire-and-forget scenarios.
										// join 	Wait for the completion of the created Coroutine.
										// cancel	Stop execution of the created Coroutine (but the Suspendable Functions being executed by the Coroutine must be cooperative).
										// joinAll	Waits for the successful completion of one or more Coroutines.

									// async 		Creates a Coroutine to execute concurrently, represented by an instance of Deferred<T>. Used for scenarios where the return value of a suspendable is important.
										// await 	Wait for the completion of the created Coroutine, and return the final result of the Deferred Instance.
										// cancel	Stop execution of the created Coroutine (but the Suspendable Functions being executed by the Coroutine must be cooperative).
										// awaitAll	Waits for the successful completion of one or more Deferred Instances.

								// CoroutineScope: Defines an environment for which Coroutines can be created in. Can be seen as a "Grouping" of Coroutines.
									// Constructor Functions:
										// runBlocking: A Normal Function that when executed, instantiates a local CoroutineScope and blocks current execution from continuing beyond it (i.e. *additionally locks down the execution to the code within the created scope*, until all execution within it is completed). Can be used as a bridge between non-Suspendable Code and Suspendable Code.

										// coroutineScope: A Suspendable Function that when executed, instantiates a local CoroutineScope and suspends current execution from continuing beyond it (i.e. *does NOT lock down the execution to the code within the created scope*, and releases the calling Thread to perform other execution, until all execution within it is completed).

									// GlobalScope: A Globally Accessible CoroutineScope, usually meant for Top-Level Coroutines operating throughout the Application lifetime.

									// Utility Function:
										// withContext(<coroutine-context>) { // ... }: Allows for swtiching / defining the CoroutineContext midway within the parent CoroutineScope.

								// CoroutineContext: The Object that holds the Execution Metadata of a CoroutineScope.
									// Note: Optional to pass this into a CoroutineScope. If no CoroutineContext is passed (i.e. no ThreadDispatcher specified), it uses the current running Thread, otherwise a pool of other Threads is used (i.e. Parellelism enabled, not just Concurrency).

									// Thread Dispatcher Types:
										// Dispatchers.Default: Coroutines defined within the Scope will run on a Thread specialized for CPU intensive work.
										// Dispatchers.IO: Coroutines defined within the Scope will run on a Thread specialized for IO intensive work (i.e. Blocking Workloads).
										// Dispatchers.Unconfined: Coroutines defined within the Scope will run on any Thread.

							// Utility Methods:
								// suspendCoroutine: Similar to a Promisify operation in JavaScript - allows wraparound of Asynchronous APIs implemented by Callback Handlers so that Coroutines executing these are suspended properly:
									suspendCoroutine { continuation ->
										// ...
											continuation.resume(<value>)

										// ...
											continuation.resumeWithException(<exception>)
									}

									// Example: Promisfying AsynchronousFileChannel's read Method:
									suspend fun AsynchronousFileChannel.readSuspending(
										buffer: ByteBuffer,
										position: Long
									) = suspendCoroutine { continuation -> 
										read(buffer, position, null, object: CompletionHandler<Int, Nothing?> {
											override fun completed(result: Int?, attachment: Nothing?) {
												continuation.resume(result)
											}

											override fun failed(exc: Throwable, attachment: Nothing?) {
												continuation.resumeWithException(exc)
											}
										})
									}

							// Mutexes (Coroutine-variant): Suspends the Coroutine attempting to access the shared Resource if another Coroutine is already using it.
								// Note: Better than blocking the Thread with the suspension Block, as it removes a Thread from the pool that can execute Coroutines for the duration.
								fun main() {
									runBlocking {
										val <mutex-name> = Mutex()

										launch {
											// ...
											<mutex-name>.withLock {
												// ... Critical Code Segment
											}
										}
									}
								}

							// Channels: Mechanism by which Coroutines can communicate with one another. Producer-Consumer Model.
								fun main() {
									runBlocking {
										val channel = Channel<<type>>(<capacity>);

										val producer = launch { 
											channel.send( ... )

											// ...

											channel.close();
										}

										val consumer = launch {
											// ...

											while(!channel.isClosedForReceive) {
												val value = channel.receive()

												// ...
											}
										}

										producer.join()
										consumer.join()
									}
								}

						// Summary
							fun main() {
								// Note: Optional to pass this into a CoroutineScope. If no CoroutineContext is passed, it uses the current running Thread, otherwise a pool of other Threads is used (i.e. Parallelism enabled, not just Concurrency).
								<coroutine-scope>(<optional-coroutine-context>) {
									// Note: If a Coroutine Builder is not used to run a Suspendable Function, the Function executes serially.
									val handle = <coroutine-builder-function> {
										<suspendable-function-name>()
									}
									
									// ...

									handle.join()
								}
							}

					// Parallelism / Multi-Threaded:
						// Note: Threads are more expensive to create than Coroutines, but they offer features such as Thread Prioritization and Affinity.

						// Thread-Safe Read-Write Data Structures:
							// Concurrent Map:
								val concurrentMap = ConcurrentHashMap()

								concurrentMap.keys
								concurrentMap.values

								concurrentMap.contains( <potential-key> )
								concurrentMap.getOrDefault( <potential-key>, <default-value> )

								concurrentMap.put( <key>, <value> )
								concurrentMap.putIfAbsent( <key>, <value> ) // Set-like Functionality
								concurrentMap.remove( <key> )
							
							// Concurrent Set:
							// Note: Universal Lock - multiple Concurrent Reads not supported
								val concurrentSet = Collections.newSetFromMap( <map> ) // Creates a Wrapper for Set Behaviour
								val concurrentSet = ConcurrentHashMap.newKeySet()

							// Parallel Streams: Used for Function-Oriented Parallel Processing of Immutable Element Sequences obtained from a Collection.
								// To change the number of Threads created by ForkJoinPool, of which ParallelStream uses for Thread Creation:
								// Note: Usually this defaults to # of Available Cores - 1
								System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "<number>")

								val parallelStream = <collection>.parallelStream()
								
								parallelStream
									.forEach
									.map
									.filter

									// ...

						// Parallel Execution:
							// Note: Coroutines can also be executed with multiple Threads by providing the CoroutineScope with a CoroutineContext.

							// Executor Service: Interface that specifies methods to manage the execution of one or more Asynchronous Tasks.
								val executorService = ThreadPoolExecutor(
									<number-of-core-threads-to-allocate>,
									<maximum-number-of-threads-to-grow-to>,
									<keep-alive-time>, // Threads will be shutdown when unused beyond this period, and started again when needed.
									LinkedBlockingQueue<Runnable>(),
									handler = <handler> // Submitted Tasks may be rejected with an Exception, this will allow handling of when that happens.
								)
									// In-Built Types that internally use ThreadPoolExecutor
									Executors.newFixedThreadPool(<maximum-number-of-threads-to-grow-to>)
									Executors.newSingleThreadExecutor() // For Tasks that absolutely require Sequential Execution

								val taskHandle: Future<*> = executorService.submit<*> {
									// ...
								}

								// OR

								executorService.execute {
									// ...
								}

								// ...

								val taskResult = taskHandle.get() // Blocks until Task is done
								// OR
								val taskResult = taskHandle.get(<number>, TIMEUNIT.<unit>) // Blocks until Task is done, or the Timeout specified is reached.

								// ...

								executorService.shutdown() // Allows pending Tasks to be executed before the Threads are released.

							// Control Flow:
								// Semaphores:
									// CountDownLatch - simple Counting Semaphore:
										val latch = CountDownLatch(<starting-number>)

										// ...

										latch.countDown()

										// Only resume Execution once the Countdown Semaphore reaches 0.
										latch.await()

								// Synchronized: Ensures only one Thread executes a particular Code Block at a time
								// Tip: Useful to update shared State.
									fun synchronousExecution() {
										synchronized {
											// ...
										}
									}

				// Date:
					// Point in Time via UTC (replaces java.util.Date & java.util.Timestamp with java.time.Instant)
					// Tip: Use .toInstant() to convert from java.util.Date to java.time.Instant.
					Instant
						// Quick way to get an Instance of Instant:
						val <instant> = Instant.now()

						// get LocalTime
						<instant>
							.atZone(ZoneOffset.UTC).toLocalTime()

						// set
						<instant>
							// Convert to ZonedDateTime
							.atZone(ZoneOffset.UTC)
								.withYear(<year>)

								.withMonth(<month>)
								.withDay(<day>)

								// OR

								.withDayOfYear(<day>) // 1 - 365

								.withHour(<hour>)
								.withMinute(<minute>)
								.withSecond(<second>)
								.withNano(<nano>)

							// Convert back to Instant
							.toInstant()

					// Point in Time via Offset from UTC
					OffsetDateTime

					// Point in Time via Timezone Specification (Continent/Region) (replaces java.util.GregorianCalendar & javax.xml.datatype.XMLGregorianCalendar)
					// Tip: Use .atZone(<zone-id-enum>) to convert from java.time.Instant to java.time.ZonedDateTime.
					ZonedDateTime
						.of(<LocalDateTime>, <zone-id-enum>)
						
						.parse(<string>, DateTimeFormatter.ofPattern(<string-format>)) // Create a ZonedDateTime Instance from a Timestamp String

					// Date and Time Representation
					// Note: Cannot represent Point in Time because it lacks Timezone
					// Tip: Use .toLocalDate() or .toLocalDateTime() to convert from java.time.ZonedDateTime to java.time.LocalDate or java.time.LocalDateTime.
					LocalTime // Replaces java.sql.Time
					LocalDate // Replaces java.sql.Date
					LocalDateTime
						.of(<year>,<month>,<day>,<hour>,<minute>,<second>)

						.parse(<string>, DateTimeFormatter.ofPattern(<string-format>)) // Create a LocalTime / LocalDate / LocalDateTime Instance from a Timestamp String

				// IO:
					// Files:
						// Obtain BufferedReader of Resource File meant to be packaged with the Application:
						// Note: No BufferedWriter available.
						val resourceBufferedReader = this::class.java.classLoader.getResourceAsStream("<path-relative-to-resources-folder>")?.bufferedReader()

						// Obtain Handle of File on System:
						val fileHandle = File("<absolute-file-path>")

						// Read
							<file-handle>.bufferedReader().use {
								in ->
									// ...
							}

							// Obtain a List of Lines in the File.
							// Tip: Suitable for Large Files, as this uses a Lazy Evaluation over a Stream, which is good for open File Handle count.
								<file-handle>.useLines {
									// ... it.toList() ...
								}

							// Execute a Function for each Line in the File.
								<file-handle>.forEachLine {
									// ... it ...
								}

						// Write
							<file-handle>.bufferedWriter().use {
								out ->
									// ...
							}

							// Write Content piecewise into the File via a PrintWriter.
							// Note: PrintWriter internally uses a BufferedWriter.
							// Note: PrintWriter not officially declared as Thread-safe, but can assume it is.
								<file-handle>.printWriter().use {
									out -> 
										// ... out.print(<content>) ...
										// ... out.println(<line-content>) ...

										out.flush()
										out.close()
								}

							// Write Text into the File.
								<file-handle>.writeText(<file-content>)

					// FileChannel:
						// Provides support for more advanced and flexible I/O Operations compared to File - particularly suited for Large Files, Random Access and Performance (Non-Blocking IO).
						FileChannel.open(
							"<absolute-file-path>", // Tip: Can use File here to get the Path Instance
							// Options
								StandardOpenOption.READ

								StandardOpenOption.WRITE
								StandardOpenOption.CREATE
								StandardOpenOption.APPEND / StandardOpenOption.TRUNCATE_EXISTING
						).use { channel ->
							// Memory Mapped Files - good when the File is relatively large but still able to fit entirely into available Virtual Memory / SSD:
							// Note: May cause Blocking IO if Memory Page is not cached.
							val buffer = channel.map(FileChannel.MapMode.READ_WRITE, <starting-byte-offset>, <expected-number-of-bytes>)

							// Current Byte Position
							// Note: Some Channel Operations do not implicitly modify the Channel Position; need to set explicitly.
							val byteOffset = channel.position()
							channel.position(<new-byte-offset>)

							// File Size
							val byteSize = channel.size()

							// Transfer Data between different FileChannels.
							// Tip: Bypasses loading the File Data into Java Heap Memory, making this more efficient.
								// Source -> Current
								channel.transferFrom( 
									<source-channel>,
									<channel-starting-byte-offset>, // Current Channel, not <source-channel>
									<number-of-bytes> // Note: Will alter the <source-channel> position by the <number-of-bytes>.
								)

								// Current -> Target
								channel.transferTo(
									<channel-starting-byte-offset>, // Current Channel, not <target-channel>
									<number-of-bytes>, // Note: Will alter the <target-channel> position by the <number-of-bytes>.
									<target-channel>
								)

							// Read:
							channel.read(<byte-buffer>)

							// Write:
							// Note: If Channel was initialized to APPEND, this will set Channel position to EOF, before the actual Write Operation.
							val byteBuffer = ByteBuffer.wrap("<string-value>".toByteArray(<encoding>))
							byteBuffer.flip() // Set the ByteBuffer to Read-Only mode
							channel.write(<byte-buffer>)
						}

						// Similar to FileChannel, but with Asychronous Read / Write Operations 
						AsynchronousFileChannel.open(
							// ...
						).use { asyncChannel ->
							// ... 
						}

				// JSON / XML Manipulation
					// Relevant Packages:
						com.fasterxml.jackson.* // Serialization / Deserialization Library for JSON Objects
							// Relevant Types:
								ObjectMapper
								XMLMapper // For XML

								JsonNode // Documentation: https://fasterxml.github.io/jackson-databind/javadoc/2.8/com/fasterxml/jackson/databind/JsonNode.html
									ContainerNode
										ObjectNode
										ArrayNode

									ValueNode
										NullNode // Defines a Field explicitly set to null.
										MissingNode // Defines a Field that's missing.

										TextNode
										NumericNode
										BooleanNode

							// Helper to Serialize Class Instances to JSON Strings / Deserialize Class Instances from JSON Strings.
							// Note: Costly to instantiate - use for multiple uses.
							val mapper = ObjectMapper()
								// Configure Serialization / Deserialization Behaviour
									// mapper.configure( ... )

								// JSON String <-> Jackson JsonNode
									// mapper.readTree(<json-string>)

									// mapper.writeValue(<destination>, <jackson-node>)

									// mapper.writeValueAsString(<node>)

								// JSON String <-> Java Object
									// mapper.readValue(<json-string>, <class>)

									// mapper.writeValue(<output-stream>, <class-instance>)
									// mapper.writeValueAsString(<class-instance>)

								// List of JSON String -> Java Object
									// mapper.readerForListOf(<class>).readValue(<array-of-json-string>)

								// Java Object <-> Jackson JsonNode
									// mapper.valueToTree(<java-object>)

									// mapper.valueToTree(<jackson-node>, <class>)

							// Node Creation
								val node: JsonNode = mapper.createObjectNode()

							// Detecting the Node Type
								// node.isNull
								// node.isMissingNode

								// node.isObjectNode
								// node.isArray
								// node.isValueNode
									// node.isTextual

							// Get a Node Value
								// get - returns null for Missing Nodes
									val value = <object-node>.get("<key>")?.as<kotlin-built-in-type>()
									// Note: textValue will return null if the Value is NOT an actual Text Value (i.e. isTextual).
									val value = <object-node>.get("<key>")?.textValue()

								// path - returns a Node for which isMissingNode() will return true if no Node exists at that path.
									val node: JsonNode = <object-node>.path("<key>").path("<sub-key>")
									// node.isMissingNode() === true

								// at - more convenient form of path
									val node: JsonNode = <object-node>.at("/<key>/<sub-key>")
									// node.isMissingNode() === true

								// with - upserts a Node at "<key>" if it does not exist, and returns it
									val node = <object-node>.with("<key>")
									val node = <object-node>.withArray("<key>")

							// Set a Node Value
								// put
									val node = <object-node>.put("<key>", <primitive-value>)

								// replace
									val oldNode: JsonNode = <object-node>.replace("<key>", <json-node>)

								// set
									val node: ObjectNode = <object-node>.set("<key>", <json-node>)

							// Removing a Node Value
								// remove
									val removedNode: JsonNode = <node>.remove("<key>")
									val adjustedNode: JsonNode = <node>.remove(listOf("<key>", ...))

							// Converting from one type of Value to another type of Value (via Serializing the Source Class Instance to JSON String -> Deserializing from that JSON String into an Instance of the Target Class).
								class <target-class> (
									Create a Property that can be both Deserialized and Serialized.
									@JsonProperty("<json-field>") val <json-field>:<type>? = null,

									// Create a Property that can only be Deserialized.
									@JsonProperty("<source-json-field>") @JsonIgnore private val <non-serializable-property>:<type>? = null,

									// ...
								) {
									// Create a Property that can only be Serialized.
									@JsonGetter("<target-json-field>")
									fun get<target-json-field>() {
										return <property-value>
									}
								}

								mapper.convertValue(<source-instance-object>, <target-class>)

				// Configuration:
					// Relevant Packages:
						com.natpryce.konfig.*
							// Relevant Types
								Key // Entity that identifies a named, typed property. Associated with a PropertyType in the context of a PropertyGroup.
								PropertyType // Lambda (inbuilt or otherwise) that represents a way to parse the read string value from the Configuration.

								PropertyGroup // Entity representing a "subset" of an actual Configuration, or one or more Keys and associated PropertyTypes.

								Configuration // Entity wrapping a set of Environment Variables and their Values.
									// Override <second> Configuration with <first> Configuration.
									<first> overriding <second>

									// Retrieve value from Configuration:
									<config>[<property-group>. ... .<key>]

							// Relevant Methods
								// Getting a Configuration Instance
									EnvironmentVariables() // Get Configuration based on the Process.
									ConfigurationProperties.systemProperties() // Get Configuration based on System Defaults.
									ConfigurationProperties.fromResource("<relative-path-from-resources-folder>") // Get Configuration stored in a File located within a resources Folder.
										// Note: When importing a Library, the Library's resources Folder will get merged in with the Project's resources Folder, with priority going to the Project in case of conflicting contents.

									// In-Memory Configuration for Testing
									ConfigurationMap(
										"<key>.<subkey>. ... " to "<value>",
										// ...
									)

								// PropertyGroup
									PropertyGroup() // Returns a base PropertyGroup that an Object Class can inherit from.
										object <group>>: PropertyGroup() {
											object <sub-group>: PropertyGroup() {
												// ...
												val <key> by <property-type>
											}
										}

				// Testing
					// mockk
						// Relevant Packages:
							io.mockk.*
								// Argument Matchers:
									any()
									eq(<value>) // Default if no wrapping Argument Matcher is specified for the <value> in the Function Call Mock.
									more(<value>)
									less(<value>)
									or(<arg-matcher>, ...)

								// Test Structure:
									class TestClass {
										// Generating Mocks of Dependencies:
											// Note: If unmocked Functions are called on this <dependency>, an Exception will be thrown.
											val <dependency> = mockk<<class-name>>() ( ... )

											// Note: If unmocked Functions are called on this <dependency>, no Exceptions will be thrown.
											val <relaxed-dependency> = mockk<<class-name>>(relaxed = true) ( ... )

											// OR

											// Ensuring every <dependency> Instance created is a Mock:
											mockkConstructor(<class>)

											// Mock a Singleton Kotlin Object:
											mockkObject(<object>)

											// Spies
											val <spy> = spyk(<class>( ... ))

										// Reset a Mocked <dependency>:
											<dependency>.clear()
											
											// OR

											clearMocks(<dependency>)

											// OR
											unmockkConstructor(<class-name>)

										// Revert a <dependency> back to pre-Mock state:
											<dependency>.unmock()

										@Test
										fun `<test-description>`() {
											// Assertions:
												assertEquals(<expected-value>, <value>)

											// Mocking a Class Dependency:
												// Note: Can re-declare same Mock to override prior Mock behaviour.

												// Mocking the results of a <dependency>'s <function> called with specific <arg>s:
													// Note: Use anyConstructed / constructedWith in case the Mock was created via mockkConstructor:
													every { anyConstructed<<class-name>>().<function>( ... ) } ...
													every { constructedWith<<class-name>>( <matcher>, ... ).<function>( ... ) } ...

													every { <dependency>.<function>(<arg> = <arg-matcher>, ... ) } returns <value> [ andThen <nextValue> ... ]
													every { <dependency>.<function>(<arg> = <arg-matcher>, ... ) } throws RuntimeException( ... )

													// To customize the results of a <function> based on <arg> Value:
														every { <dependency>.<function>(<arg> = <arg-matcher>, ... ) } answers { 
															// ... arg<<arg-type>>(<arg-index-position>) ...
														}

														// Partial Mocking - To return the result of the original Function:
														every { <dependency>.<function>(<arg> = <arg-matcher>, ... ) } answers { 
															callOriginal()
														}

														// Mocking the results of a <dependency>'s <function> called with specific <arg>s, whilst Capturing the <arg-value>s sent:
														val argSlot = slot<<arg-type>>() // Per Call
														val argList = mutableList<<arg-type>>() // For every Call in the Test
														every { <dependency>.<function>(<arg> = capture(argSlot), ... ) } 
															returns <value>( ... , argSlot.captured , ...)

															// OR

															answers {
																val original = callOriginal()
																original( ... , argSlot.captured , ... )
															}

													// For a <function> that has the Unit Return Type:
														every { <dependency>.<function>(<arg> = <arg-matcher>, ... ) } just Runs

											// Substituting a <spy>'s Functionality:
												every { <spy>.<function>(any(), ... ) } answers {
													// ... arg<<arg-type>>(<arg-index-position>) ...
												}

											// ... <system-under-test>(<dependency>, ...) ...

											// Verifying the behaviour of a <dependency>:
												// Note: every and verify can be used on the same <function>.

												// Note: Use anyConstructed / constructedWith in case the Mock was created via mockkConstructor:
												verify { anyConstructed<<class-name>>().<function>( ... ) } ...
												verify { constructedWith<<class-name>>( <matcher>, ... ).<function>( ... ) } ...

												// Verify that a <dependency>'s <function> was called with specific <arg>s:
													verify([exactly=<num-times>]) {
														<dependency>.<function>(<arg> = <arg-matcher>, ... )
													}
												
												// Verify that all <dependency>'s <function>s were not called:
													verify {
														<dependency> wasNot Called
													}

												// Verify that all <dependency>'s <function>s that were mocked were called:
													confirmVerified(<dependency>, ...)

												// Verify that the <function>s called in specified <dependency>s are the only ones that were called:
													verifyAll {
														<dependency>.<function>(<arg> = <arg-matcher>, ... )
														// ...
													} 

												// Verify that a <dependency>'s <function>s were called in some strict order:
													verifySequence {
														<dependency>.<function>(<arg> = <arg-matcher>, ... )
														// ...
													}

												// Verify that a <dependency>'s <function>s were called in some order (not necessarily one after the other):
													verifyOrder {
														<dependency>.<function>(<arg> = <arg-matcher>, ... )
														// ...
													}
										}
									}

					// JUnit 5 + Jupiter
						class TestClass {
							// Basic Test
								@Test
								@Timeout(<seconds>)
								fun `<test-description>`() {
									// ...
								}

							// Parameterized Test
								@ParameterizedTest
								@EnumSource(<enum>::class) 
								// OR
								@EnumSource(<enum>::class, names = ["<enum-name>", ...])
								fun `<test-description>`(<arg>) {
									// ...
								}

								@ParameterizedTest
								@CsvSource(
									value = [
										"<arg1>, ... ",
										"<arg1>, ... ",

										// Example with Null Values - do not put in any value for the Argument content between commas.
										"",
										",, ... ",

										// Tip: Use .split() on Quoted String Values to pass in Array <arg>s.
										"<arg1>,'<arg2a>;<arg2b>; ...' ..."
									],

									delimiter = '<char>', // OR
									delimiterString = "<char>",
								)
								fun `<test-description>`(<arg1>, <arg2>: String, ...) {
									// ...
								}

								companion object {
									@JvmStatic
									fun <static-arg-provider-function>(): Stream<Arguments> {
										// Tip: Each Stream Element corresponds to one run of the Test:
										return Stream.of(
											Arguments.of( <arg>, ... ),
											// ...
										)
									}
								}

								@ParameterizedTest
								@MethodSource("<static-arg-provider-function")
								fun `<test-description>`( <arg>, ... ) {
									// ...
								}
						}

		Project Configuration:
			// IntelliJ + Gradle + Maven
				// build.gradle
					// Build Script Config Section
					buildscript {
						// ...

						repositories {
							// ...

							maven {
								// Specify URI of accessible Kotlin Distributable in case it's not accessible from the Central Maven Repository.
								url "https://dl.bintray.com/kotlin/kotlin-eap-<version>"
							}

							// ...
						}

						// ...
					}

					// ...

					// Main Script Config Section 

					dependencies {
						// Dependency Configurations
							api("...") // Dependency available during Compile-Time and Runtime, and whose API is exposed to consuming Projects of this Project
							
							implementation("...") // Dependency available during Compile-Time and Runtime
							testImplementation("...") // Dependency available during Compile-Time and Runtime for Tests

						// Noteworthy Dependencies:
							// To enable Kotlin Reflection
							implementation(kotlin("reflect"))

							// To use mockk for Testing:
							testImplementation("io.mockk:mockk:${mockkVersion}")
					}

					// ...

					repositories {
						mavenCentral()

						maven {
							// Specify URI of accessible Kotlin Distributable in case it's not accessible from the Central Maven Repository.
							url "https://dl.bintray.com/kotlin/kotlin-eap-<version>"
						}
					}

					// ...

					allprojects / subprojects {
						// Setup Tests with JUnit
						tasks.withType(Test) {
							useJUnitPlatform()
							
							// OR

							useJUnitPlatform {
								include '<path>'
								exclude '<path>'
							}

							testLogging {
								events "passed", "skipped", "failed"
							}
						}
					}

		Compilation: Kotlin will convert <name>.kt Kotlin Files into <name>Kt Class Files when it detects during Compilation some Top-Level Functions inside.

	Commands:
		# Kotlin
			set KOTLIN_HOME

			# Start Interactive REPL:
			kotlinc

			# Generate Class File from Kotlin Files:
			kotlinc <kotlin-file> ...

			# Compile JAR File:
			kotlinc <kotlin-file> ... -include-runtime -d <jar-name>.jar

		# Java
			# Run generated Class File with Java:
			java -cp .;<kotlin-runner-JAR-path> <generated-class-file-without-extension>

			# Run generated JAR File in Java:
			java -jar <jar-name>.jar
				java -D<java-application-property>=<value> ... -jar <jar-name>.jar

			# Check Running Java Process Heap Usage:
			jhsdb jmap --heap --pid <pid>
	
