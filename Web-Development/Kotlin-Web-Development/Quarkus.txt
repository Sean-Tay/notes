Quarkus
	Abbreviations:
		META-INF: Meta Information.
	
	Description: Java Stack for creating Applications tailored to run on a OpenJDK HotSpot (Java) or GraalVM (Native) Container within a Kubernetes (Container-Based) Environment.
	
	Resources: 
	
	Concepts:
		OpenJDK Hotspot: High Performance VM for running Java Applications.
		GraalVM: High Performance VM for running Applications written in different languages.

		META-INF: Directory that traditionally contains Meta-Information about the jar File being generated.
		META-INF.resources: Directory that would contain Static Assets to be served when the Quarkus Application is running.

		uber-jar: Contains all the Dependencies needed to run the Application within.
	
	Details:
		Typical Template Project Structure:
			// <module>
				// build

				// gradle
					// wrapper
						// graddle-wrapper.jar
						// graddle-wrapper.properties

				// src
					// main
						// docker

						// kotlin

						// resources
							// META-INF.resources
								// index.html

							// application.properties
								

					// native-test
						// kotlin

					// test
						// kotlin

					// gradle.properties
					// settings.gradle.kts
					// build.gradle.kts
					// gradlew
					// gradlew.bat
	
		Configuration:
			// Profiles: Designate which set of Configuration Variables should be used during Runtime:
				// Set the quarkus.profile Configuration Property:
					// gradlew quarkusDev "-Dquarkus.profile=<value>"
			
				// Standard Profiles:
					dev: quarkusDev
					test: When Running Tests
					prod: When there is no Active Profile

			// In Decreasing Order of Priority:
				// System Properties:
					// gradlew ... "-D<key>.<subKey> ... <subKey>=<value>"

				// Environment Properties:
					// export <key>_<subKey> ... <subKey>=<value>; gradlew ...

				// .env File:
					// _<profile>_<key>_<subKey> ... <subKey>=<value>

				// application.properties / application-<profile>.properties:
					// <key>.<subKey> ... <subKey>=<value>
					// <key>.<subKey> ... <subKey>=${ ... }

					// <key>.<arrayKey>=<value>,<value>, ...
					// <key>.<arrayKey>[0]=<value>
					// <key>.<arrayKey>[1]=<value>
					// ...

					// Set Quarkus to search w.r.t the Classpath (includes the root of the jar File it gets bundled into):
					// <filpath-property>=classpath:<filepath-value>

					// %<profile>.<key>.<subKey> ... <subKey>=<value>

		Non-Default Dependencies:
			io.quarkus:quarkus-smallrye-health: Dependency that adds Liveness and Readiness Endpoints for a Quarkus Application.
				/q/health/started: If the Application has started.

				/q/health/live: If the Application is up and running; if this returns false the Application would be restarted by the Cloud Platform.

				/q/health/ready: If the Application is ready to serve Requests.
					// Example Readiness Check:
						// If using the quarkus-rest-client Dependency, define a Function to get the Health of the external Service on the Client Class.
						@ApplicationScoped
						@Readiness
						class <custom-healthcheck>: HealthCheck {
							@Inject
							@RestClient
							lateinit var <service-name>: <client-name>

							override fun call(): HealthCheckResponse {
								val healthCheckResponseBuilder = HealthCheckResponse.named("<service-name>")

								try {
									val response = <service-name>.<get-health-function>()
									healthCheckResponseBuilder.up().withData("success", response)
								} catch (e: Exception) {
									healthCheckResponseBuilder.down().withData("error", e.stackTraceToString())
								}

								return healthCheckResponseBuilder.build()
							}
						}

			io.quarkus:quarkus-rest-client: Dependency that adds support for querying other Services via HTTP(S).
			io.quarkus:quarkus-rest-client-jackson: Dependency that adds jackson Processing Support for the above.
				// application.properties
					// Set the Rest Client that is registered under "<config-key>" to use Mutual TLS when communicating to other Service.
					quarkus.rest-client."<config-key>".key-store
					quarkus.rest-client."<config-key>".key-store-password

					// Set the Rest Client that is registered under "<config-key>" to query this URL to communicate with the other Service.
					quarkus.rest-client."<config-key>".url

				// Example Client:
					// Note: Use javax.* Annotations here as they can accommodate for different JAX-RS implementations.
					// Note: Use org.eclipse.microprofile.rest.* Annotations here.

					// Interceptor: Use a Client Interceptor to intercept a Request before it is sent to the external Service Endpoint, and a Response before it is returned to our Application.
						// Declare a custom Interceptor NameBinding Annotation to enforce that an Interceptor should only be used on Clients / Client Methods annotated with @<interceptor-binder-name>.
						// Note: Without this, the Interceptor would by default act on all Clients in the Application.
						@NameBinding
						@Retention(AnnotationRetention.RUNTIME)
						annotation class <interceptor-binder-name>

						@<interceptor-binder-name>
						class <interceptor-name>: ClientRequestFilter, ClientResponseFilter {
							// ...
						}

					// Client
						// Specify that the Client is to be a Singleton, managed by the CDI Container throughout the lifecycle of the Application.
						@ApplicationScoped
						@RegisterRestClient(configKey = "<config-key>")
						@<interceptor-binder-name>
						interface <client-name> {
							// Specify an external Service Endpoint that is callable by the Application.
							@<uppercase-http-verb>
							@Path("/<value>/{<path-param>}/...")
							@Produces(MediaType.<media-type>)
							fun <fun-name>(
								// Tip: The arguments defined in a Client's Function allow our Application to augment the HTTP Request made to the external Service when calling this Function.
								@PathParam("<path-param>") <path-param-variable>: <path-param-type>,
								@QueryParam("<query-param>") <query-param-variable>: <query-param-type>,

								// Set HTTP Request Headers when the Request is made to the external Service.
								@HeaderParam("<http-header>") <http-header-variable>: <http-header-variable-type>,

								// ...

								payload: JsonNode
							): <service-return-type>

							// ...
						}

			io.quarkus:quarkus-resteasy: Dependency that adds support for exposing RESTful APIs.
			io.quarkus:quarkus-resteasy-jackson: Dependency that adds jackson Processing Support for the above.
				// application.properties
					// Set Application to use SSL / HTTPs when communicating with Clients.
					// Note: Port will change to 8443 if used.
					quarkus.http.ssl.certificate.key-store-file
					quarkus.http.ssl.certificate.key-store-password

				// Example Resource:
					// Note: Use javax.* Annotations here as they can accommodate for different JAX-RS implementations.
					// Note: Use org.eclipse.microprofile.rest.* Annotations here.

					private const val RESOURCE_PATH = "/<value>"
					val RESOURCE_PATH_REGEX = "$RESOURCE_PATH/.*".toRegex()

					// Interceptor: Use an Interceptor to intercept a Request before it reaches a Resource Endpoint, or a Response before it gets sent back to the User-Agent.
						// Declare a custom Interceptor NameBinding Annotation to enforce that an Interceptor should only be used on Resources / Resource Methods annotated with @<interceptor-binder-name>.
						// Note: Without this, the Interceptor would by default act on all Resources in the Application.
						@NameBinding
						@Retention(AnnotationRetention.RUNTIME)
						annotation class <interceptor-binder-name>

						@<interceptor-binder-name>
						// Register the Interceptor with the JAX-RS Runtime.
						@Provider
						class <interceptor-name>(
							@RestClient val <service-name>: <client-name>,
							// ...
						): ContainerRequestFilter, ContainerResponseFilter {
							// Alternative to setting the Rest Client in the Constructor:
							@Inject
							@RestClient
							lateinit val <service-name>: <client-name>

							// Request Interceptor: Intercept Requests before they are passed to the Resource Endpoint.
							override fun filter(requestContext: ContainerRequestContext?) {
								// Cookie Upsert Example
									// Get Cookie Value
									val <cookie-value> = requestContext?.cookies?.get("<cookie-key>")

									if (<cookie-value> == null || <cookie-value>.value.isNullOrEmpty()) {
										// Create a new Cookie on the fly
										val newCookie = NewCookie(
											"<cookie-key>",
											<cookie-value>,
											<cookie-applicability-path>,
											<cookie-applicability-domain>,
											<comment>,
											<max-age>,
											<secure>
										)

										// Add to the Request Header so that Resource Endpoints will receive the Cookie Value
										requestContext?.headers?.add(HttpHeaders.COOKIE, newCookie.toString())

										// Store the new Cookie on the Request, to be used in the later Response Interceptor
										requestContext?.setProperty("<cookie-key>", newCookie)
									}
								
								// Call a Service via the Client defined for it:
								// <service-name>.<fun-name>( ... )

								// ...

								// ...
							}

							// Response Interceptor: Intercept Responses before they are passed to the User-Agent.
							override fun filter(requestContext: ContainerRequestContext, responseContext: ContainterResponseContext) {
								// Cookie Upsert Example
									// Retrieve the Cookie created in the Request Interceptor
									val newCookie = requestContext?.getProperty("<cookie-key>")

									if (newCookie != null) {
										requestContext?.headers?.add(HttpHeaders.SET_COOKIE, newCookie.toString())
									}

								// Call a Service via the Client defined for it:
								// <service-name>.<fun-name>( ... )

								// ...

								// ...
							}
						}

					// Resource:
						@<interceptor-binder-name>
						@Path(RESOURCE_PATH)
						class <resource-name>(
							@RestClient val <service-name>: <client-name>,
							// ...
						) {
							// Alternative to setting the Rest Client in the Constructor:
							@Inject
							@RestClient
							lateinit val <service-name>: <client-name>

							@<uppercase-http-verb>
							@Path("/<value>/{<path-param>}/...")
							@Produces(MediaType.<media-type>)
							fun <fun-name>(
								// Tip: The arguments defined in a Resource's Function allow the Framework to feed in the associated values in the Client's Request to our Function to be read.
								@PathParam("<path-param>") <path-param-variable>: <path-param-type>,
								@QueryParam("<query-param>") <query-param-variable>: <query-param-type>,

								// Receive HTTP Request Headers when the Request is marshalled here.
								@HeaderParam("<http-header>") <http-header-variable>: <http-header-variable-type>,

								// Read Cookies attached to the HTTP Request by the User-Agent.
								@CookieParam("<cookie-key>") <cookie-value-variable>: <cookie-value-type>,

								// ...

								payload: JsonNode
							): Response {
								// ...

								return Response
									.ok(
										<response-body>,
										MediaType.<media-type>
									)
									// if needed
									.cookie(
										<cookie>
									)
									.build()
							}
						}

			io.quarkus:quarkus-junit5-mockito: Dependency that allows for Mocking during Testing.
			org.mockito.kotlin:mockito-kotlin:4.1.0
			io.rest-assured:rest-assured: Dependency that faciliates Testing of RESTful Web Services.
				// Example Test Class:
					@QuarkusTest
					class <test-suite> {
						// Stub Client that is typically injected via @Inject in the Class to be tested.
						// Note: Not compatible if the Clients are passed in via Class Constructor Arguments.
						// Note: Only works with @ApplicationScoped Clients.
						@InjectMock
						@RestClient
						lateinit var <service-name>: <client-name>

						@Test
						fun `<test-name>`() {
							// Stub Client Call:
							Mockito.`when`(<service-name>.<method-name>(eq(<arg>), anyOrNull(), ...)).thenReturn(
								// Tip: Use Jackson ObjectMapper.valueToTree to convert mapOf() values to JsonNode.
								<stub-value>
							)

							// ...

							// Assert via RestAssured
							given()
								// Section to configure Test Request
									// Check that Header is set:
									.header(<http-header>, <http-header-value>)

									// Check that Header is not set:
									.header(<http-header>, Matchers.nullValue())


									// Assert Request Body Content:
									.contentType(MediaType.<content-type>)
									.body(
										// Tip: Use Jackson ObjectMapper.writeValueAsString to convert mapOf() values to JSON Content.
										// ...
									)

								.`when`().<http-verb>("<path>")
								// Section to configure Expected Response
									// Assert Response has particular Status Code:
									.statusCode(<value>)

									// Assert Response Body Content:
									.body(
										// Tip: Use Jackson ObjectMapper.writeValueAsString to convert mapOf() values to JSON Content.
										`is`("<text-value>`)
									)
						}
					}

			io.mockk:mockk:1.13.4

			io.quarkiverse.quinoa:quarkus-quinoa:1.2.9: Dependency for integrating a Web UI with a Quarkus Server.

		Syntax:
			// Getting Configuration Properties via MicroProfile Config Annotations:
				@ConfigProperty(
					name = "<key>.<subkey> ... <subkey>",

					// If defaultValue is not set, the Annotation will throw a Runtime Exception.
					defaultValue = <value>
				) val <runtime-constant-name>: <type>

			// Quarkus Tests
				@QuarkusTest
				class <test-suite> {
					@Test
					fun `<test-name>`() {

					}

					// ...
				}

	Commands:
		# Quarkus CLI
			quarkus create

		# Gradle Wrapper
			# Start a Local Development Server with Hot Reload capabilities for the Quarkus Application.
			gradlew quarkusDev

			# Clear the Build Directory. Useful to run just before a Build.
			gradlew clean

			# Compile and Build the Quarkus Application into a .jar File.
			gradlew build

			# Compile and Build the Quarkus Application into an uber-jar File.
			gradlew build "-Dquarkus.package.type=uber-jar"

		# Java
			# Run the built jar with a defined Configuration Profile:
			java -Dquarkus.profile=<profile> -jar <name>.jar

			# Preview jar Directory Structure and Files
			jar tf <name>.jar

