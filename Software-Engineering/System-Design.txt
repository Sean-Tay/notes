System Design:
	Abbreviations:
		CDN:					Content Delivery Network.
	
	Description: Problems designed to test your ability to keep progressing through scenarios with Limited Detail but Greater Flexibility.
	
	Resources:
		
	
	Concepts:
		Reliability: 			Working in the face of Faults for both Software and Hardware.
			CAP Theorem: 		Describes the tradeoff between (Data) Consistency, Availability and Partitioning Tolerance for a System (choose 2 of 3). Usually either Consistency or Availability is compromised (in favour of Partitioning Tolerance) for a Distributed System - a Centralized System need not have Partitioning Tolerance, so both Consistency and Availability is achievable.
				Consistency:	Defines the degree at which replicated redundant copies of Data are the same between Nodes in a System. See Consistency Models in Database Notes.
				Availability:	Observable via the ratio of handled Requests to dropped Requests.
				Partitioning Tolerance: Enforces that the Distributed System can still operate even if parts of it are unreachable.

			Continuous Availability: Full Availability 24/7.
			High Availability:	Operational Performance for a higher than normal period.

		Scalability: 			Working as the System faces increased Traffic, Usage, and Data.
			Horizontal Scaling: Adding more Resources to meet demand (i.e. Quantity).
			Vertical Scaling:	Upgrading existing Resources to be more capable (i.e. Quality).

		Maintenability: 		Ease at which parts of the System can be modified / added / removed by others.

		Response Time:			The time it takes for a Client to receive a Response from a submitted Request.
		Latency:				The time in which a Pending Request is waiting to be handled by the System.
			Tail Latency:		A metric which describes the percentage of Requests which would not exceed a specified Latency Amount.

		Bandwidth:				The maximum number of Requests that the System can theoretically handle at a given time.
		Throughput:				The number of Requests that the System can actually handle at a given time.

		80-20 Rule: 			20% of Writes will lead to 80% of subsequent Reads.

		Forward Proxy:			An intermediary that sits between a User and a Web Application, acting on behalf of the User.
		Reverse Proxy: 			An intermediary that sits between a Web Application and a User, acting on behalf of the Web Application.

		Service Oriented Architecture: Style of Software Design where Servcies are provided to other Components by Application-related Components, through a Communication Protocol over a Network.

		API Gateway:			An Interceptor for API / Microservice Requests that acts as a Single Entry Point to help implement Standardized Access across all APIs / Microservices.
	
	Details:
		Typical System Components grouped via Function:
			Data Storage: See Database Notes.

			System Data Transport:
				Message Queue: Enables Asynchronous Communication between two or more Components. A Messaging Broker typically manages the Queues and simplifies the connection of consuming Components via a Publisher / Subscriber Pattern.
					Examples:
						Kafka
						RabbitMQ
						Azure Bus Service
						AWS SQS
						Google Cloud Pub/Sub

			Optimization:
				(In-Memory) Cache: Simple Key-Value Object Store that is very quick on Read / Write operations. Can be used for storing information about User Sessions.
					Examples:
						Memcached
						Redis

			Data Processing:
				Custom Services: The Components in the System that executes Application-specific Logic.
					Examples:
						Kafka Consumer

						REST Server
						Serverless Function

						Spark Job

			User-Facing Data Transport:
				Load Balancer: A Reverse Proxy that distributes Network Traffic across different Nodes in a Distributed System.
					Examples:
						Cloudflare
						DigitalOcean
						Azure Load Balancer
						WS Load Balancer
						Google Cloud

						HAProxy

				DNS: Translates a Human-Readable Domain Name into an IP Address.

				CDN: A Cache for all kinds of Static Content.
					Types:
						Push CDN: Application is responsible for pushing updated content to the CDN and maintaining the URL used to access them. Works well when content is not updated frequently.
						Pull CDN: CDN pulls content from Application when the first User initiates a Request for that content. A TTL can be ascribed to such content in order to save space on the CDN. Works well with Applications that have heavy traffic, as no additional traffic incurred from pushing content to CDN unnecessarily.

					Examples:
						Fastly
						Cloudflare CDN
						Azure CDN
						AWS CloudFront
						Google CDN

				Web Server (Reverse Proxy): A running Process on a Host Machine that is designed to just serve Static Content and Resources via HTTP. Requests for Dynamic Content gets sent to the App Server, although Plugins can be installed to generate Dynamic Content via Scripting Languages as well.
					Examples:
						NGINX

			Data Presentation:
				Desktop
				Web
				Mobile

		Systems are Designed with the intent of being Reliable, Scalable and Maintenable.
			Reliable:
				Availability:
					Failover:
						Active-Passive: Only one Node is actively handling Requests - the rest of the cloned Nodes are reserved for backup (either in Cold or Hot State). The Active Node is sending a regular heartbeat to the Passive Nodes - after a certain duration of not receiving a heartbeat one of the Passive Nodes takes over the Active Node's IP Address and role.

						Active-Active: More than one Node is actively handling Requests. The DNS and Application Logic needs to know about all Active Nodes.

					Replication: See Database Notes.

					Uptime Standards:
						90% -> 36.5 Days Offline per Year
						95% -> 18.25 Days Offline per Year
						99% -> 3.65 Days Offline Per Year
						99.9% -> 8.77 Hours Offline Per Year
						99.99% -> 1 Hour Offline Per Year
	
	Commands:
		
	
