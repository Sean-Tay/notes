System Design:
	Abbreviations:
		CDN:					Content Delivery Network.
	
	Description: Problems designed to test your ability to keep progressing through scenarios with Limited Detail but Greater Flexibility.
	
	Resources:
		
	
	Concepts:
		Reliability: 			Working in the face of Faults for both Software and Hardware.
			Continuous Availability: Full Availability 24/7.
			High Availability:	Operational Performance for a higher than normal period.

		Scalability: 			Working as the System faces increased Traffic, Usage, and Data.
			Horizontal Scaling: Adding more Resources to meet demand (i.e. Quantity).
			Vertical Scaling:	Upgrading existing Resources to be more capable (i.e. Quality).

		Maintenability: 		Ease at which parts of the System can be modified / added / removed by others.

		Response Time:			The time it takes for a Client to receive a Response from a submitted Request.
		Latency:				The time in which a Pending Request is waiting to be handled by the System.
			Tail Latency:		A metric which describes the percentage of Requests which would not exceed a specified Latency Amount.

		Bandwidth:				The maximum number of Requests that the System can theoretically handle at a given time.
		Throughput:				The number of Requests that the System can actually handle at a given time.

		80-20 Rule: 			20% of Writes will lead to 80% of subsequent Reads.

		Forward Proxy:			An intermediary that sits between a User and the Internet, acting on behalf of the User.
		Reverse Proxy: 			An intermediary that sits between a Web Application and the Internet, acting on behalf of the Web Application.

		Service Oriented Architecture: Style of Software Design where Servcies are provided to other Components by Application-related Components, through a Communication Protocol over a Network.

		API Gateway:			An Interceptor for API / Microservice Requests that acts as a Single Entry Point to help implement Standardized Access across all APIs / Microservices.
	
	Details:
		Typical System Components grouped via Function:
			Data Storage:
				Databases

				Distributed File Storage: Store Files in a System with Redundancy / Replication for Availability.
					Examples:
						Hadoop: Tailored towards eventual Data Processing of the Data in the Files stored.

			System Data Transport:
				Message Queue: Enables Asynchronous Communication between two or more Components. A Messaging Broker typically manages the Queues and simplifies the connection of consuming Components via a Publisher / Subscriber Pattern.
					Examples:
						Kafka
						RabbitMQ
						Azure Bus Service
						AWS SQS
						Google Cloud Pub/Sub

			Optimization:
				(In-Memory) Cache: Simple Key-Value Object Store that is very quick on Read / Write operations. Can be used for storing information about User Sessions.
					Examples:
						Memcached
						Redis

			Data Processing:
				Custom Services: The Components in the System that executes Application-specific Logic.
					Examples:
						Kafka Consumer

						REST Server
						Serverless Function

				Batch: Offline; Bounded Data - assumes all Data available before starting.
					Examples:
						Hadoop MapReduce
						Spark Job

					Scenarios:
						Sorting

				Streaming: Online; Unbounded Data - not all Data available at once.
					Scenarios:
						Maintaining top N Items according to some metric.

			User-Facing Data Transport:
				Load Balancer: A Reverse Proxy that distributes Network Traffic across different Cluster Nodes in a Distributed System.
					Examples:
						Cloudflare
						DigitalOcean
						Azure Load Balancer
						WS Load Balancer
						Google Cloud

						HAProxy

				DNS: Translates a Human-Readable Domain Name into an IP Address.
					Examples:
						Cloudflare
						Route 53

				CDN: A Cache for all kinds of Static Content.
					Types:
						Push CDN: Application is responsible for pushing updated content to the CDN and maintaining the URL used to access them. Works well when content is not updated frequently.
						Pull CDN: CDN pulls content from Application when the first User initiates a Request for that content. A TTL can be ascribed to such content in order to save space on the CDN. Works well with Applications that have heavy traffic, as no additional traffic incurred from pushing content to CDN unnecessarily.

					Examples:
						Fastly
						Cloudflare CDN
						Azure CDN
						AWS CloudFront
						Google CDN

				Web Server (Reverse Proxy): A running Process on a Host Machine that is designed to just serve Static Content and Resources via HTTP. Requests for Dynamic Content gets sent to the App Server, although Plugins can be installed to generate Dynamic Content via Scripting Languages as well.
					Examples:
						NGINX

			Data Presentation:
				Desktop
				Web
				Mobile

		Systems are Designed with the intent of being Reliable, Scalable and Maintenable.
			Reliable:
				Strategies:
					Failover:
						Active-Passive: Only one Node is actively handling Requests - the rest of the cloned Nodes are reserved for backup (either in Cold or Hot State). The Active Node is sending a regular heartbeat to the Passive Nodes - after a certain duration of not receiving a heartbeat one of the Passive Nodes takes over the Active Node's IP Address and role.

						Active-Active: More than one Node is actively handling Requests. The DNS and Application Logic needs to know about all Active Nodes.

					Replication: See Database Notes.

				(Availability) Uptime Standards:
					90% -> 36.5 Days Offline per Year
					95% -> 18.25 Days Offline per Year
					99% -> 3.65 Days Offline Per Year
					99.9% -> 8.77 Hours Offline Per Year
					99.99% -> 1 Hour Offline Per Year
	
		Synchronization in Distributed Systems:
			Time:
				Network Time Protocol: Mechanism occasionally used by Machines to synchronize their internal clocks.
				Monotonic Clock: Only used to measure Time Deltas - specific value of the Clock means nothing.
			
			Consensus:
				Fencing Token: Token with a monotonically increasing value used in Consensus-based Distributed Scenarios to ensure correct behaviour even when parts of it have been paused / are unreliable. Entities obtain a Token from a Token Service, and will only be successful in performing the operation on another Entity if the other Entity has not seen a Token with a higher value before.

	Commands:
		
	
