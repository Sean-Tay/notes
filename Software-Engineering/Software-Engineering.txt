Application Development:
	Design:
		Bad Code:					Mainly caused by Coupling.
			Rigidity:				Modification of one part of code requires changes to other parts of the code due to non-isolation and coupling.
			Fragility:				Modification of one part of code requires changes to many other non-related parts of the code.
			Non-Reusability:		
		
		OOP:						"OO is about managing Dependencies by selectively inverting key Dependencies in the architecture to prevent the problems with Bad Code."
			Abstraction:			To hide away low level implementation details and only expose high level functionality.

			Encapsulation:			The act of grouping all the Elements of a Concern within a Structure.
				Tip: Functions, Classes, Objects and Modules can be "Structures".

			Inheritance:			Extend parent Class functionality with child Classes that have a "is-a" relationship.

			Polymorphism: 			The provision of a single Symbol / Interface to represent Entities of different types.
				Note: The behaviour of the more specific Entity overrides whatever behaviour it may have Inherited from the less specific Entity, even if it is referenced as a less specific Entity.
		
		SOLID:						Set of Design Principles to make Software more Flexible, Understandable and Maintainable.
			Single Responsibility:	Components should only handle one part of the Software's Specification, and it should only have one reason to change.
				Tip: Bad for Maintenability if two things are Coupled, which could change differently / at different times.
				Example: Module for Compiling a Report, and Module for Printing the Report.

			Open-Close:				Components should be Open to Extension but Closed for Modification. Basically, Inherit rather than modify.
				Tip: More about improving Code Maintenability by reducing chance of Regression / Bugs.
				Tip: Avoid using Private Variables when considering this.

			Liskov Substitution:	Instances of a Higher Level should be replaceable by Instances of a Lower Level, without breaking the Application.
				Note: Not just in terms of the Contractual Interface, but also the behaviour of the two.
				Example: Ellipse and Circle. A Circle may be modelled as a special kind of Ellipse, but it violates the Liskov Substituion Principle.

			Interface Segregation:	No Module should be forced to depend on Functionality it does not use, given an Interface.
				Tip: Prefer Simple Interfaces for Composability over Large, General ones. Classes can then more easily implement these Interfaces.
				Tip: Prefer adjectives in Interface Names that more concretely document the functionality and purpose of the Interface (i.e. IOrderCalculator instead of IOrderManager).

			Dependency Inversion:	High Level Modules should not depend on concrete Low Level Modules, both should depend on Abstractions which dictate the details.
				Tip: Avoid coupling High Level Modules with specific types of Low Level Modules by introducing Abstractions on the Lower Level Modules.
			
		Dependency Injection:		Allow Dependencies of one Entity be initialized and passed in by another Entity.
		
		Inversion of Control:		Rather than having the Application determine when the Framework Functionality is used, the flow is reversed, and the Framework will trigger specified Application Functionality. It helps with Dependency Injection.
			Analogy: Hollywood Principle - Don't Call Us, We'll Call You.
		
		DRY:						Don't Repeat Yourself. Avoid Code Duplication whenever possible.
		WET:						Write Everything Twice. Avoid Over Abstraction, which can be more harmful than Code Duplication. 
		AHA:						Avoid Hasty Abstractions. Wait until a piece of Code has been Duplicated several times before looking into Abstraction to get a better sense of what the potential use-case for that piece of Code is.

	Constructs:
		Polyglot:					A single Entity which is designed to express the same functionality across usage of multiple Programming Languages at the same time.

		Shims:						Emulation of API for Legacy Environments that would not have them implemented / repair incorrect implementations of the API in Problematic Environments.
		
		Stub:						Dummy implementation of some part of a Program / Software / System, usually used in scenarios where the full functionality of the Program / Software / System is not strictly required.

		Mixins:						Classes with implemented Methods meant for reuse amongst other Classes, forgoing direct Inheritance to acquire said functionality.

	Metaprogramming:				The practice of making Programs that makes other Programs.
		Introspection:				Finding out the structure and semantics of the Code that makes up the Program.
		Reflection:					Finding out and adjusting the structure and semantics of the of the Code that makes up the Program.

Application Lifecycle:
	Containerization:				Bundling an Application, related Binaries and Libaries into some Self-Contained Package for execution.

	Container Orchestration: 		Schedules and Manages Container Deployment.
