System Design Interview: Login Backend
	A Login Backend, or in a more precise term, an Identity System is something we interact with every day on the Internet. There are countless resources online that detail every aspect of it, but I can’t find a good one that lays out the end to end mechanics from a System Design angle. So I would like to give it a try. Bear in mind that this post focuses on the Information Model of an Identity System, which I believe is the core. I’ll start with a Username Password System and build up the features along the way as I lay out the technicalities.

	Let’s start with a very simple ask: store the necessary data to support a Login System. Well, first of all, Username and Ppassword. However, it’s not as simple as just having Database Columns for the Username and Password.

	Username
		Many Legacy Systems just use the Username (sometimes the Email) as the Immutable ID for an Account. This has many problems, the most obvious of which is that Users can’t change their Usernames. It’s particularly annoying when the System uses Emails as Usernames. The ability to switch/add Email(s) attached to an Account is a very important capability. If we don’t allow that, Users will invent their own workarounds — creating unnecessary new Accounts, abandoning the old ones, sharing Passwords, etc, which lead to chaos for Users and the System itself. The other aspect is that usually the Identity System is integrated with various services in the Organization. Being able to pass around an Immutable and Opaque User ID is very beneficial to the overall System Architecture. Because it’s stable; it’s obscured so integrators won’t try to interpret into it (versus Username / Email); and the Identity System can provide integrators with a reasonable contract about the ID length and character set.

		Thus we will create a User ID for every user. Then the Username and/or Email are just metadata of the Account along with other User Profile Data we may collect during signup, though we may create dedicated Indices on them for fast lookup. It’s perfectly reasonable to allow Users to login with either Username or Email. The User ID is internal information that we won’t expose.

	Password
		It’s common sense now we should not store Passwords as they are because even if our Database is encrypted at rest, Hackers who find a way to exfiltrate the Data Files out might still access the content. Passwords are just too sensitive to be exposed to that kind of risks. You may say just store the Hash of the Passwords and compare the Hash at runtime for login. That’s a step forward, but still not all the way there. The most obvious problem is that if two Users happen to choose the same Password, their stored Password Hashes will be the same. And that’s something we don’t want to reveal. So typically we’ll choose a Random Nonce for each User and HMAC their Password. To be more secure, we could introduce a Server Secret in the HMAC. The Server Secret will be kept elsewhere. Otherwise Hackers could simply try Heuristic Brute Force as certain well-explored patterns exist when people are choosing Passwords (like username1234). To be even more secure, we can compound the HMAC recursively — the output of one feeds into the input of another through many rounds — to make it a little bit expensive to generate the final stored Password. This will add an almost negligible cost to the login runtime but a considerable amount of cost to Hackers who want to Brute Forcefully try out billions of possibilities. And as computers advance, we just do more rounds of HMAC to maintain the level of computational difficulty. Another added bit of security is that the rounds and details of HMAC is unknown to hackers who only have access to the Data Files, though generally Security by Obscurity is not a strong guarantee.

	Workflows
		Now we have a solid storage layer for User Accounts, let’s work out some typical workflows of a Login System.

	Signup
		First thing first, Users need to sign up. This is accomplished by presenting a Signup Page to collect the necessary information. The system will create a new User ID, attach the metadata (Username, Email, etc), and record the obfuscated Password. A typical Login System will require Email Verification of the Signup. So the System will create an opaque URL and send it to the user’s Email Address. Once clicked, the system receives a request which it can then tie to the User Account and update the Account as verified. The URL can be generated in many ways. But the bottom line is that the system has to establish a way to link the URL back to the to-be-verified Account. This can be easily facilitated by including a unique string handle in the URL and storing the handle temporarily with the User Account until it’s verified or expired (some Systems impose a Time Window in which the Account must be verified).

	Login
		The Login flow is critical. After all, that’s the title of this post. When the System receives the Username / Email and Password, it loads up the corresponding obfuscated password for that Username / Email, employs the same obfuscation to process the received Password, and then compare to see if they match. A typical Login System will restrict the number of Login Attempts (within a certain Time Window). This is to prevent Malicious Users from guessing and trying to login others’ Accounts. When the max Login Attempt is reached, the System will lock down the Account and require reactivation through Email. This capability requires the System to log the failed attempts with the Account until they can be cleared up. We can handle reactivation in a similar way to the signup verification above.

		The Identity System’s Response upon a successful Login varies. If it’s a Monolithic Application in which the Identity and other Services are bundled together, then the System may return the Protected Resources immediately after the Authentication. In the Modern Internet Era, Organizations typically decouple out the Identity System and share that with other Services — for instance, Email, File Storage, Office Web Services they may all share the same User Account. In such case, the Identity System should return an Access Token after a Successful Login, which represents the fact that Login is done. This token is normally passed to the Integrated Services via HTTP Redirects.

		The Token should be opaque and different every time. The validity of the Access Token should be short-lived so that even if it’s compromised, the damage is limited. The Access Token is used by Integrated Services to authorize access (based on the User Identity the Token represents), manage Sessions or Single Sign-On. More advanced Access Token logic can be applied here. For example, depending on what the User is signing in for — this information is usually obtained through Integrated Services — the System may return Tokens of different powers (Read / View Account Info vs. Write / Changing Password).

		Ideally, Integrated Services don’t need to ask the Identity System to validate the Access Token. For example, if the Access Token is a JWT that contains the User Profile and Login Timestamp, and signed by the Identity System’s Private Key; then Integrated Services can just verify the signature with the Identity System’s Public Key and trust the information. In practice, Integrated Services often have to talk to the Identity System because the Identity System wants to remain in control of Token Validation. And that’s a good practice because we want only one Source of Truth for the Token Validation logic. In addition, the Identity System may have more auxiliary information than it can stuff in a small JWT to pass back to the Integrators after validating the Token.

	More Features
		Additional Security Safeguards can be implemented. We usually ask Users to configure Security Questions as part of the signup so that we have a way to double confirm their identities. Those need to be stored and potentially used as a Login alternative. Two-Factor Authentication is also popular nowadays — in addition to the Password, the System also requires SMS / Email / Auth Code during Login. The transient Two-Factor Verification Code doesn’t need to be stored in Database. We can keep that in Memory Cache until it’s verified or expired. Many Systems provide Abnormality Detection. When the Account is signed in on a new Device, in a drastically different Location, or at an unlikely time of the day, the User will get an Email Notification. This of course requires the System to collect Data about Login History, which can be stored with the User Account. Some Systems will try to recycle Inactive Accounts. Recycle is probably the wrong word because an Identity System should try to avoid reusing Accounts if possible as that creates so much confusion for Users, Integrators, and the System itself. Cleaning up Inactive Account, however, is still a valid operation. Users should get a series of notifications before their Inactive Accounts are finally deactivated and deleted. A Login System should also allow Users to delete their Accounts for UX and Compliance Reasons. When an Account is deleted (often soft deleted at first), the Integrated Services should receive notifications to act on the event. This gives a chance for the entire System Fleets to propagate the Account deletion and clean up User Data appropriately.

	Closing
		I suppose that’s for now. I didn’t go into any specific Technology Stack in this post because I believe as always, when we understand the principles, we can select the concrete methods. This is not to say implementing an Identity System is an easy quest. In fact, you should always frown at yourselves if you think that you need to reinvent / implement one from scratch as there are many mature Systems out there (or even inside your Organization) that you should try leveraging first. Always, do not dig into a rabbit hole unless you absolutely have to. But if you truly have to, I wish you good luck and hope that this post helps a tiny bit.

WRITTEN BY
Eileen Pangu
Eng @ FANG. Enthusiastic tech generalist. Enjoy distilling wisdom from experiences. Believe in that learning is a lifelong journey.
