Python
	Abbreviations: 
	
	Description: 
	
	Resources: 
	
	Concepts: 
	
	Details:
		# Python 3

		# Variable Assignment:
			<variable-name>: <type> = <value>

			<true-variable> = True
			<false-variable> = False
			<null-variable> = None

		# Value Conversion:
			# Integer: int(<value>)
			# String: string(<value>)

		# Math:
			# Methods:
				floor()
				max()
				min()

			# Operators:
				//= # Floor Division
				% 	# Modulo

		# For Loops:
			# range - inclusive <start> (default 0), exclusive <stop>
			for i in range(<stop>):
				# ...

			for i in range(<start>, <stop>, <step>):
				# ...

			for item in <iterable>:
				# ...

			for key, value in enumerate(<iterable>, start=<index>):
				# ... 

		# Lists:
			<list-variable> = []

			# Create a filled List of a given <value> of size <n>:
			<filled-list-variable> = [<value>] * <n>

			<list-variable>.insert(<index>, <item>)
			<list-variable>.append(<value>)

			item = <list-variable>.pop()

			size = len(<list-variable>)
	
		# Deque:
			from collections import deque
			
			<queue-variable> = deque([<initial-element>, ... ])
			<queue-variable>.append(<value>)
			item = <queue-variable>.popLeft()

		# Heaps:
			# Note: Min Heap Implementation
			import heapq

			<pqueue-variable> = []
			heapq.heappush(<pqueue-variable>, [<priority>, <item>])
			item = heapq.heappop()
			# Peek: <pqueue-variable>[0]

		# Sets:
			<set-variable> = set()

			<set-variable>.add(<item>)
			<set-variable>.remove(<item>)

			# Test Membership: item in <set-variable>
			# Test Non-Membership: item not in <set-variable>

		# Dicts / Maps:
			<map-variable> = {}

			item = <map-variable>.get(<key>, <default-value>)
			<map-variable>[<key>] = item

			del <map-variable>[<key>]
			removed_item = <map-variable>.pop(<key>, <default-value>)

			# Test Membership: item in <map-variable>
			# Test Non-Membership: item not in <map-variable>

			for key in <map-variable>:
				# ...

		# Iterables:
			# Indexing:
				<iterable>[<0-based-index>] # get element at index w.r.t front of <iterable>, starting at 0
				<iterable>[-<1-based-index>] # get element at index w.r.t back of <iterable>, starting at -1

			# Slicing:
				<iterable>[<inclusive-start>]

				<iterable>[<inclusive-start>:<exclusive-end>]
				<iterable>[:<exclusive-end>]

				<iterable>[<inclusive-start>:<exclusive-end>:<step>]
				<iterable>[<inclusive-start>::<step>]
				<iterable>[:<exclusive-end>:<step>]

		# Functions:
			def <function-name>(arg: <arg-type>, ... ) -> <return-type> :
				# ...

		# Classes:
			class <class-name>:
				def __init__(self, <param>, ...):
					self.<variable> = <data>

				def <class-method>(self, <param>, ...):
					# Tip: Don't feed in self when invoking <another-class-method>
					self.<another-class-method>(<argument>, ...)

				# ...

	Commands:
		
	
